<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言实现变色贪吃蛇]]></title>
    <url>%2F2018%2F05%2F30%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%89%B2%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[今天我们实现一下用C语言编写一个能变色、能调速、能调整地图大小、并且能用文件保存分数的贪吃蛇游戏工具：VS2013语言：C 头文件TCS.h123456789101112131415161718192021222324252627282930313233343536373839404142434445#ifndef __TCS_H__#define __TCS_H__#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define U 1#define D 2#define L 3#define R 4 //蛇的状态，U：上 ；D：下；L:左 R：右typedef struct SNAKE //蛇身的一个节点&#123; int x; int y; struct SNAKE * next;&#125;snake;typedef struct PLAYER&#123; char name[20]; int scores;&#125;player;//声明全部函数//void Pos(); //改变光标位置 void creatMap(); //创建地图 void initsnake(); //初始化蛇 int biteself(); //判断是否咬到自己 void createfood(); //生成食物 void cantcrosswall();//判断是否撞墙 void snakemove(); //蛇的移动函数 void pause(); //暂停 void gamecircle(); //游戏运行 void welcometogame();//介绍页面 void gamestart(); //初始化游戏 void endgame(); //结束游戏 void print(); //打印边框 void menu(); //打印主菜单 void inittop(); //初始化排行榜 void showtop(); //展示排行榜 void sorttop(); //排序排行榜 void startshow(); //进入游戏的动画 void selectmap(); //选择地图 void mapmenu(); //地图菜单 int topmenu(); //选择排行榜 #endif 源文件test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714#define _CRT_SECURE_NO_WARNINGS#include "TCS.h"//全局变量//int level = 0; //关卡数，0表示无尽模式int score = 0, add = 10; //总得分与每次吃食物得分int status, sleeptime = 200; //每次运行的时间间隔snake *head, *food; //蛇头指针，食物指针snake *q; //遍历蛇的时候用到的指针int endgamestatus = 0; //游戏结束的情况，1：撞到墙；2：咬到自己；3：主动退出游戏。int run = 0; //判断游戏是否还能运行player top[61]; //排行榜int MAX_LL = 130;int MAX_CC = 36;int MAX_L = 92;int MAX_C = 35;void color(int x) &#123; if (!x) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), rand()%6+9); //只有一个参数，改变字体颜色 else SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), x);&#125;void Pos(int x, int y)//设置光标位置&#123; COORD pos; HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput, pos);&#125;void creatMap()//创建地图&#123; int i; for (i = 0; i&lt;MAX_L; i += 2)//打印上下边框 &#123; Pos(i, 0); color(0); printf("■"); Pos(i, MAX_C); color(0); printf("■"); Sleep(10); &#125; for (i = 1; i&lt;MAX_C; i++)//打印左右边框 &#123; Pos(0,i); color(0); printf("■"); Pos(MAX_L-2,i); color(0); printf("■"); Sleep(10); &#125;&#125;void initsnake()//初始化蛇身&#123; snake *tail; int i; tail=(snake*)malloc(sizeof(snake));//从蛇尾开始，头插法，以x,y设定开始的位置// tail-&gt;x=24; tail-&gt;y = 15; tail-&gt;next = NULL; for (i = 1; i &lt;= 4; i++) &#123; head = (snake*)malloc(sizeof(snake)); head-&gt;next = tail; head-&gt;x = 24 + 2 * i; head-&gt;y = 15; tail = head; &#125; while (tail != NULL)//从头到尾，输出蛇身 &#123; Pos(tail-&gt;x, tail-&gt;y); printf("■"); tail = tail-&gt;next; &#125;&#125;int biteself()//判断是否咬到了自己&#123; snake * self; self = head-&gt;next; while (self != NULL) &#123; if (self-&gt;x == head-&gt;x &amp;&amp; self-&gt;y == head-&gt;y) &#123; return 1; &#125; self = self-&gt;next; &#125; return 0;&#125;void createfood()//随机出现食物&#123; snake *food_1;res: food_1 = (snake*)malloc(sizeof(snake)); food_1-&gt;x = (rand() % (MAX_L-4) + 2)/2*2;//保证其为偶数，使得食物能与蛇头对其 food_1-&gt;y = rand() % (MAX_C-1) + 1; q = head; //food_1 = (snake*)malloc(sizeof(snake)); //while ((food_1-&gt;x % 2) != 0) //保证其为偶数，使得食物能与蛇头对其 //&#123; // food_1-&gt;x = rand() % (MAX_L - 4) + 2; //&#125; //food_1-&gt;y = rand() % (MAX_C - 3) + 1; //q = head; while (q != NULL) &#123; if (q-&gt;x == food_1-&gt;x &amp;&amp; q-&gt;y == food_1-&gt;y) //判断蛇身是否与食物重合 &#123; free(food_1); goto res; &#125; q = q-&gt;next; &#125; Pos(food_1-&gt;x, food_1-&gt;y); food = food_1; color(0); printf("★");&#125;void cantcrosswall()//不能穿墙&#123; if (head-&gt;x == 0 || head-&gt;x == MAX_L-2 || head-&gt;y == 0 || head-&gt;y == MAX_C) &#123; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgamestatus = 1; endgame(); &#125;&#125;void snakemove()//蛇前进,上U,下D,左L,右R&#123; snake * nexthead; cantcrosswall(); if (run)return; nexthead = (snake*)malloc(sizeof(snake)); if (status == U) &#123; nexthead-&gt;x = head-&gt;x; nexthead-&gt;y = head-&gt;y - 1; if (nexthead-&gt;x == food-&gt;x &amp;&amp; nexthead-&gt;y == food-&gt;y)//如果下一个有食物// &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; score = score + add; createfood(); &#125; else //如果没有食物// &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q-&gt;next-&gt;next != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); printf(" "); free(q-&gt;next); q-&gt;next = NULL; &#125; &#125; if (status == D) &#123; nexthead-&gt;x = head-&gt;x; nexthead-&gt;y = head-&gt;y + 1; if (nexthead-&gt;x == food-&gt;x &amp;&amp; nexthead-&gt;y == food-&gt;y) //有食物 &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; score = score + add; createfood(); &#125; else //没有食物 &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q-&gt;next-&gt;next != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); printf(" "); free(q-&gt;next); q-&gt;next = NULL; &#125; &#125; if (status == L) &#123; nexthead-&gt;x = head-&gt;x - 2; nexthead-&gt;y = head-&gt;y; if (nexthead-&gt;x == food-&gt;x &amp;&amp; nexthead-&gt;y == food-&gt;y)//有食物 &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; score = score + add; createfood(); &#125; else //没有食物 &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q-&gt;next-&gt;next != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); printf(" "); free(q-&gt;next); q-&gt;next = NULL; &#125; &#125; if (status == R) &#123; nexthead-&gt;x = head-&gt;x + 2; nexthead-&gt;y = head-&gt;y; if (nexthead-&gt;x == food-&gt;x &amp;&amp; nexthead-&gt;y == food-&gt;y)//有食物 &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; score = score + add; createfood(); &#125; else //没有食物 &#123; nexthead-&gt;next = head; head = nexthead; q = head; while (q-&gt;next-&gt;next != NULL) &#123; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); q = q-&gt;next; &#125; Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); printf(" "); free(q-&gt;next); q-&gt;next = NULL; &#125; &#125; if (biteself() == 1) //判断是否会咬到自己 &#123; endgamestatus = 2; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgame(); &#125; if (run)return;&#125;void pause()//暂停&#123; while (1) &#123; Sleep(300); if (GetAsyncKeyState(VK_SPACE)) &#123; break; &#125; &#125;&#125;void gamecircle()//控制游戏&#123; Pos(MAX_L+4, 15); printf("不能穿墙，不能咬到自己\n"); Pos(MAX_L + 4, 16); printf("用↑.↓.←.→分别控制蛇的移动."); Pos(MAX_L + 4, 17); printf("F1 为加速，F2 为减速\n"); Pos(MAX_L + 4, 18); printf("ESC ：退出游戏.Space：暂停游戏."); Pos(MAX_L + 4, 20); printf("\n"); status = R; while (1) &#123; Pos(MAX_L + 6, 10); printf("得分：%d ", score); Pos(MAX_L + 6, 11); printf("每个食物得分：%d分", add); if (GetAsyncKeyState(VK_UP) &amp;&amp; status != D) &#123; status = U; &#125; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; status != U) &#123; status = D; &#125; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; status != R) &#123; status = L; &#125; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; status != L) &#123; status = R; &#125; else if (GetAsyncKeyState(VK_SPACE)) &#123; pause(); &#125; else if (GetAsyncKeyState(VK_ESCAPE)) &#123; endgamestatus = 3; break; &#125; else if (GetAsyncKeyState(VK_F1)) &#123; if (sleeptime &gt;= 50) &#123; sleeptime = sleeptime - 30; add = add + 2; if (sleeptime == 320) &#123; add = 2;//防止减到1之后再加回来有错 &#125; &#125; &#125; else if (GetAsyncKeyState(VK_F2)) &#123; if (sleeptime&lt;350) &#123; sleeptime = sleeptime + 30; add = add - 2; if (sleeptime == 350) &#123; add = 1; //保证最低分为1 &#125; &#125; &#125; Sleep(sleeptime); snakemove(); if (run)return; &#125;&#125;void welcometogame()//简介界面&#123; system("cls"); //int i = 7; //color(13); //Pos(6, 7); //printf("■■■■ ★"); //for (i = 8; i &lt; 20; i++) //&#123; // Pos(6, i); // printf("■"); // Pos(MAX_L + 6, i); // printf("■"); //&#125; //Pos(6, i); //for (i = 6; i &lt;= MAX_L + 6; i+=2) // printf("■"); print(); Pos(MAX_L/2-12, 7); color(15); printf("用"); color(10); printf("↑ ↓ ← →"); color(15); printf("分别控制蛇的移动"); Pos(MAX_L / 2 - 12, 9); color(12); printf("F1 "); color(15); printf("为加速"); color(12); printf(" F2 "); color(15); printf("为减速\n"); Pos(MAX_L / 2 - 12, 11); color(15); printf("可以多点几下"); color(11); printf(" F1 "); color(15); printf("或者"); color(11); printf(" F2 "); color(15); printf("切换到你认为最适合你的难度\n"); Pos(MAX_L/2-12, 13); printf("加速将能得到"); color(13); printf("更高的分数。"); Pos(MAX_L / 2 - 12, 15); color(14); printf("开始进行愉快的贪吃蛇游戏吧 ^ _ ^\n"); Pos(MAX_L / 2-12, 25); color(15); system("pause"); system("cls");&#125;void endgame()//结束游戏&#123; char c; system("cls"); print(); Pos(MAX_L/2, 12); if (endgamestatus == 1) &#123; color(12); printf("对不起，您撞到墙了。游戏结束."); &#125; else if (endgamestatus == 2) &#123; color(12); printf("对不起，您咬到自己了。游戏结束."); &#125; else if (endgamestatus == 3) &#123; color(12); printf("您已经结束了游戏。"); &#125; Pos(MAX_L / 2, 13); printf("您的得分是%d\n", score); if (score &gt;= top[(MAX_LL-70)/30*20-1].scores) &#123; Pos(MAX_L / 2, 14); system("pause"); top[60].scores = score; Pos(MAX_L / 2, 14); printf("恭喜你进入排行榜！！！！"); Pos(MAX_L / 2, 15); while ((c = getchar()) != '\n' &amp;&amp; c != EOF); printf("是否留下你的名字？(y/n)"); scanf("%c", &amp;c); if ('y' == c || 'Y' == c) &#123; Pos(MAX_L / 2, 16); printf("请输入你的昵称:&gt;"); scanf("%s", top[60].name); sorttop(); Pos(MAX_L / 2, 17); printf("排行榜已更新..."); &#125; else &#123; strcpy(top[60].name, "noname"); sorttop(); Pos(MAX_L / 2, 17); printf("排行榜已更新..."); &#125; &#125; run = 1; Pos(MAX_L / 2, 18); system("pause");&#125;void gamestart()//游戏初始化&#123; char p[50]; sleeptime = 200; score = 0; add = 10; system("cls"); //system("mode con cols=150 lines=30"); run = 0; sprintf((char * )p, "mode con cols=%d lines=%d", MAX_LL, MAX_CC); system((const char*)p); creatMap(); initsnake(); createfood();&#125;void mapmenu()&#123; print(); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 5); printf("■■■■■■■■ ★ ■■■■■■■■"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 5); printf("1.地图：小"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 3); printf("2.地图：中"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 1); printf("3.地图：大"); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2+1); printf("选择你的地图大小:&gt;");&#125;void selectmap()&#123; int input; do &#123; system("cls"); mapmenu(); fflush(stdin); scanf("%d", &amp;input); switch (input) &#123; case 1: MAX_LL = 100; MAX_CC = 30; MAX_L = 64; MAX_C = 29; return; break; case 2: MAX_LL = 130; MAX_CC = 36; MAX_L = 92; MAX_C = 35; return; break; case 3: MAX_LL = 160; MAX_CC = 45; MAX_L = 120; MAX_C = 44; return; break; default: Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 2); printf("输入有误！"); Sleep(500); break; &#125; &#125; while (1);&#125;void print()&#123; int i; for (i = 0; i&lt;MAX_LL; i += 2)//打印上下边框 &#123; Pos(i, 0); color(0); printf("■"); Pos(i, MAX_CC - 1); color(0); printf("■"); &#125; for (i = 1; i&lt;MAX_CC; i++)//打印左右边框 &#123; Pos(0, i); color(0); printf("■"); Pos(MAX_LL - 2, i); color(0); printf("■"); &#125;&#125;void menu()&#123; print(); Pos((MAX_LL-78)/2-1, MAX_CC / 5); printf("■■■■■■■■ ★ ■■■■■■■■"); Pos(MAX_LL / 2-6, MAX_CC / 2-5); printf("1.开始游戏"); Pos(MAX_LL / 2-6, MAX_CC / 2-3); printf("2.游戏简介"); Pos(MAX_LL / 2 - 6, MAX_CC / 2-1); printf("3.排行榜"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 + 1); printf("0.退出游戏");&#125;void game()&#123; //system("color 3f"); selectmap(); gamestart(); gamecircle(); system("cls");&#125;void startshow()&#123; int i = 0; Pos((MAX_LL - 56) / 2-6, (MAX_CC - 10) / 2 + i++); Sleep(5); color(0); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(55); printf("██ █ █ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("██ █ █ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(35); printf("██ ██████████ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(25); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(15); printf("██ ███◣ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(15); printf("██ ██◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(25); printf("██ ██ ◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(35); printf("██ ██ ◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("█████████ ██ ◥█◣ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(55); printf("█████████ ██ ◥█◣ ████████"); Sleep(500); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i+3); color(13); printf("★"); Pos(0, (MAX_CC - 10) / 2 +i+3); color(14); for (i = 0; i &lt; MAX_LL; i += 2) &#123; printf("■"); Sleep(i/3); &#125;&#125;int main()&#123; int input; char p[50]; srand((unsigned)time(NULL)); inittop(); sprintf((char * )p, "mode con cols=%d lines=%d", MAX_LL, MAX_CC); system((const char*)p); startshow(); do&#123; system("cls"); menu(); Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 3); printf("请选择:&gt;"); fflush(stdin); scanf("%d", &amp;input); switch (input) &#123; case 3: showtop(); break; case 2: welcometogame(); break; case 1: game(); break; case 0: break; default: Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 4); printf("输入有误请重新输入！\n"); Sleep(500); break; &#125; &#125; while (input); Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 4); printf("感谢你的游玩，再见！"); Sleep(800); return 0;&#125; top.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#define _CRT_SECURE_NO_WARNINGS#include "TCS.h"//全局变量//extern int level ; //关卡数，0表示无尽模式extern int score , add ; //总得分与每次吃食物得分extern int status, sleeptime ; //每次运行的时间间隔extern snake *head, *food; //蛇头指针，食物指针extern snake *q; //遍历蛇的时候用到的指针extern int endgamestatus ; //游戏结束的情况，1：撞到墙；2：咬到自己；3：主动退出游戏。extern int run ; //判断游戏是否还能运行extern player top[61]; //排行榜extern int MAX_LL ;extern int MAX_CC ;extern int MAX_L ;extern int MAX_C ;void inittop()&#123; int j = 0; for (j = 0; j &lt; 3; j++) &#123; int i = 0; top[20 * j + i].scores = 999; for (i = 1; i &lt; 20; i++) &#123; top[20 * j + i].scores = 480 - 20 * i; &#125; for (i = 0; i &lt; 21; i++) &#123; strcpy(top[20 * j + i].name, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"); strcpy(top[20 * j + i].name, "LRS"); &#125; &#125; top[60].scores = 0; loadtop();&#125;int topmenu()&#123; int input; do &#123; system("cls"); mapmenu(); fflush(stdin); scanf("%d", &amp;input); switch (input) &#123; case 1: return 0; break; case 2: return 1; break; case 3: return 2; break; default: Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 2); printf("输入有误！"); Sleep(500); break; &#125; &#125; while (1);&#125;void showtop()&#123; int i = 0; int j = topmenu(); system("cls"); print(); Pos(MAX_LL / 5, i + 3); color(15); printf("%-10s\t%-20s\t%-10s", "名次", "昵称", "分数"); for (i = 0; i &lt; 20; i++) &#123; Pos(MAX_LL / 5, i + 4); if (i &lt; 20)color(15); if (i &lt; 10)color(10); if (i &lt; 5)color(9); if (i &lt; 3)color(13); if (i &lt; 2)color(14); if (i &lt; 1)color(12); printf("%-10d\t%-20s\t%-10d", i + 1, top[j * 20 + i].name, top[j * 20 + i].scores); &#125; system("pause"); system("cls");&#125;void sorttop()&#123; int i = 0; int j = 0; int m = (MAX_LL - 100) / 30 * 20; for (i = 0; i &lt; 20; i++) &#123; if (top[60].scores &gt;= top[m + i].scores) &#123; for (j = 19 + m; j &gt;(i + m); j--) &#123; top[j] = top[j - 1]; &#125; top[i + m] = top[60]; break; &#125; &#125; savetop();&#125;void loadtop()&#123; int ret = 0; FILE* c = fopen("tcs.dat","a+"); FILE* load = fopen("tcs.dat", "r"); fclose(c); c = NULL; if (load == NULL) &#123; perror("load top"); exit(1); &#125; ret = fread(&amp;top[0], sizeof(player), 60, load); fclose(load); load = NULL;&#125;void savetop()&#123; FILE* save = fopen("tcs.dat","w"); if (save == NULL) &#123; perror("save top"); exit(1); &#125; fwrite(&amp;top[0], sizeof(player), 60, save); fclose(save); save = NULL;&#125; 这样我们的贪吃蛇游戏就做好了…给你们展示一下效果吧··因为本人比较懒，所以用了很多全局变量 &gt;_&lt; 怎么样？是不是相当…花里胡哨呢？]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建动态通讯录]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[今天我们用自定义类型和动态内存管理实现一个通讯录程序，能够实现以下要求: 添加联系人信息 删除指定联系人信息 查找指定联系人信息 修改指定联系人信息 显示所有联系人信息 清空所有联系人 以名字排序所有联系人 头文件 Contact.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef __TEST_H__#define __TEST_H__#pragma once //2.实现一个通讯录；//通讯录可以用来存储1000个人的信息，每个人的信息包括://姓名、性别、年龄、电话、住址////提供方法：//1. 添加联系人信息//2. 删除指定联系人信息//3. 查找指定联系人信息//4. 修改指定联系人信息//5. 显示所有联系人信息//6. 清空所有联系人//7. 以名字排序所有联系人#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt;#include &lt;windows.h&gt;#include&lt;time.h&gt;#define Filename "Contact.txt"typedef struct PERSON&#123; char Name[20]; char Sex[5]; int Age; char Tel[20]; char Address[50];&#125;Person;typedef struct BOOK&#123; int max; //当前上限 int count; //当前已存储人数 Person* Data;&#125;Book;void Initbook(Book* people);void Add_person(Book * people);void show_person(Book* people);void Del_person(Book* people);void Find_person(Book* people);void Change_person(Book* people);void BubbleSort_person(Book* people);void Req_mem(Book* people);void Desbook(Book* people);#endif //__TEST_H__ 源文件 Test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357#include "test.h"//仅查找static int find_person(Book* people)&#123; int i = 0; assert(people); char name[20]; printf("\t\t 输入姓名："); scanf("%s", name); for (; i&lt;people-&gt;count; i++) &#123; if (strcmp(people-&gt;Data[i].Name, name) == 0) &#123; return i; &#125; &#125; //printf("没有找到该联系人！\n"); //system("pause"); return -1;&#125;//加载文件void load(Book*people)&#123; FILE* op = fopen(Filename, "a+"); FILE* load = fopen(Filename,"r"); fclose(op); if (load == NULL) &#123; perror("load file,please try again"); exit(1); &#125; while (fread(&amp;(people-&gt;Data[people-&gt;count]), sizeof(Person), 1, load)) &#123; people-&gt;count++; Req_mem(people); &#125; fclose(load); load = NULL;&#125;//保存文件void save(Book*people)&#123; int i = 0; FILE* save = fopen(Filename,"w"); if (save == NULL) &#123; perror("save file"); exit(1); &#125; while (i&lt;people-&gt;count) &#123; fwrite(&amp;(people-&gt;Data[i]), sizeof(Person), 1, save); i++; &#125; //fwrite(people-&gt;Data, sizeof(Person), (size_t)people-&gt;count, save); fclose(save); save = NULL;&#125;//初始化 void Initbook(Book* people)&#123; (people)-&gt;Data = (Person*)malloc(2*sizeof(Person)); (people)-&gt;count = 0; (people)-&gt;max = 2; load(people);&#125;//清空void Desbook(Book* people)&#123; free(people-&gt;Data); people-&gt;Data = NULL; people-&gt;max = 0; people-&gt;count = 0; save(people); printf("\t\t 清空完毕！\n"); Sleep(300);&#125;//打印void show_person(Book* people)&#123; int i = 0; if (people == NULL) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; printf("\t\t |%-15s\t|%-5s\t|%-5s\t|%-15s\t|%-20s\n", "姓名", "性别", "年龄", "电话", "地址"); for (; i&lt;=people-&gt;count-1; ++i) &#123; printf("\t\t |%-15s\t", people-&gt;Data[i].Name); printf("|%-5s\t", people-&gt;Data[i].Sex); printf("|%-5d\t", people-&gt;Data[i].Age); printf("|%-15s\t", people-&gt;Data[i].Tel); printf("|%-20s\n", people-&gt;Data[i].Address); &#125; printf("\n\t\t "); system("pause");&#125;//申请内存void Req_mem(Book *people)&#123; Person* p; if (people-&gt;count &lt; people-&gt;max - 1)return; p = (Person*)realloc((people)-&gt;Data,((people)-&gt;max+=5)*sizeof(Person)); if (p != NULL) &#123; (people)-&gt;Data = p; return; &#125; else &#123; perror("realloc"); exit(EXIT_FAILURE); &#125;&#125;//增加成员 void Add_person(Book *people)&#123; int i = 0; assert(people); if ((people)-&gt;count == 1000) &#123; printf("\t\t 通讯录已满！\n"); return; &#125; Req_mem(people); printf("\t\t 请输入姓名:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Name); printf("\t\t 请输入性别:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Sex); printf("\t\t 请输入年龄:&gt;"); scanf("%d", &amp;((people)-&gt;Data[(people)-&gt;count]).Age); printf("\t\t 请输入联系方式:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Tel); for (; i&lt;(people)-&gt;count; ++i) &#123; if (strcmp((people)-&gt;Data[i].Tel, (people)-&gt;Data[(people)-&gt;count].Tel) == 0) &#123; printf("\t\t 联系人已存在！\n\t\t "); system("pause"); return; &#125; &#125; printf("\t\t 请输入住址:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Address); printf("\t\t 增加成功！\n"); Sleep(300); (people)-&gt;count++; //printf("count = %d\n", (*people)-&gt;count);&#125;//删除成员 void Del_person(Book* people)&#123; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; int ret = find_person(people); if (ret != -1) &#123; int i = ret; for (; i&lt;people-&gt;count-1; ++i) &#123; people-&gt;Data[i] = people-&gt;Data[i + 1]; &#125; people-&gt;count--; &#125; else &#123; printf("\t\t 没有该成员！\n"); system("pause"); &#125;&#125;//查找成员 void Find_person(Book* people)&#123; int i = 0; char name[20]; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; assert(people); printf("\t\t 输入姓名："); scanf("%s", name); for (; i&lt;people-&gt;count; ++i) &#123; if (strcmp(people-&gt;Data[i].Name, name) == 0) &#123; printf("\t\t Name:%s\n\t\t Sex:%s\n\t\t Age:%d\n\t\t Tel:%s\n\t\t Add:%s\n\t\t ", people-&gt;Data[i].Name, people-&gt;Data[i].Sex, people-&gt;Data[i].Age, people-&gt;Data[i].Tel, people-&gt;Data[i].Address); //printf("编号为 %d\n", i); system("pause"); return; &#125; &#125; printf("\t\t 没有找到该联系人！\n\t\t "); system("pause"); return ;&#125;//修改成员 void Change_person(Book* people)&#123; assert(people); int ret = find_person(people); if (ret != -1) &#123; printf("\t\t Name-&gt;:"); scanf("%s", people-&gt;Data[ret].Name); printf("\t\t Sex-&gt;:"); scanf("%s", people-&gt;Data[ret].Sex); printf("\t\t Age-&gt;:"); scanf("%d", &amp;(people-&gt;Data[ret]).Age); printf("\t\t Tel-&gt;:"); scanf("%s", people-&gt;Data[ret].Tel); printf("\t\t Add-&gt;:"); scanf("%s", people-&gt;Data[ret].Address); &#125; else &#123; printf("\t\t 没有该成员！\n"); system("pause"); return; &#125;&#125;//排序void BubbleSort_person(Book* people)&#123; if (people == NULL) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; int i = 0; for (; i&lt;people-&gt;count - 1; ++i) &#123; int j = 0; for (; j&lt;people-&gt;count - 1 - i; ++j) &#123; if (strcmp(people-&gt;Data[j].Name, people-&gt;Data[j + 1].Name) &gt; 0) &#123; Person tmp = people-&gt;Data[j]; people-&gt;Data[j] = people-&gt;Data[j + 1]; people-&gt;Data[j+1] = tmp; &#125; &#125; &#125; show_person(people);&#125;void color() //自定义函根据参数改变颜色 &#123; //static int x = 9; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), rand()%7+9); //只有一个参数，改变字体颜色 //if (x == 16) // x = 9;&#125;//static void change_color()//&#123;// static int i = 0;// char *str[20];// sprintf((char*)str, "color %x%x",0,15 - i);// system((const char*)str);// i++;// if (15 == i)// i = 0;//&#125;void menu()&#123; system("cls"); printf("\t\t ******************************通讯录管理系统*****************************\n\n"); color(); printf("\t\t **************1.添加联系人**********************2.删除联系人*************\n\n"); color(); printf("\t\t **************3.查找联系人**********************4.修改联系人*************\n\n"); color(); printf("\t\t **************5.显示联系人**********************6.清空联系人*************\n\n"); color(); printf("\t\t **************7.排序联系人**********************0.退出此程序*************\n\n"); color(); printf("\t\t *************************************************************************\n\n");&#125;int main()&#123; srand((size_t)time(NULL)); Book people; Initbook(&amp;people); while (1) &#123; //change_color(); menu(); int n = 0; printf("\t\t 请选择:&gt; "); scanf("%d", &amp;n); switch (n) &#123; case 1: Add_person(&amp;people); break; case 2: Del_person(&amp;people); break; case 3: Find_person(&amp;people); break; case 4: Change_person(&amp;people); break; case 5: show_person(&amp;people); break; case 6: Desbook(&amp;people); Initbook(&amp;people); break; case 7: BubbleSort_person(&amp;people); break; case 0: save(&amp;people); free((&amp;people)-&gt;Data); color(); printf("\t\t 感谢您的使用，再见！"); Sleep(800); exit(0); default: &#123; printf("\t\t input error!\n\t\t "); system("pause"); break; &#125; &#125; &#125; return 0;&#125; 这个通讯录我加入了一点花里胡哨的元素：每次操作完毕都会使背景变色，你可以试试哦~~修订信息：于2018.5.31加入文件保存功能。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于自定义类型]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、结构体类型的创建 1.结构体是一些值的集合，这些值称为成员变量。 2.结构体内的成员可以是不同类型的变量，也可以是标量，数组，指针甚至是其他的结构体。 3.结构体的创建： 例图： 4.结构体内部成员的访问：（1）.结构体变量访问成员(结构变量的成员是通过点操作符(.)访问的.点操作符接受两个操作数.如果s是结构体的具体名称，age是其内部成员，则s.age就可以访问)。（2）结构体访问指向变量的成员（定义一个指向该结构体的结构体类型的指针ps，如果age是该结构体的内部成员，则(*s).age或者ps-&gt;age就可以访问）。 5.结构的自引用：在结构体中可以包含该结构体本身的成员，具体的自引用如下例： 二、结构体的初始化 1. 123456struct Stu &#123; char name[10]; int age; &#125;; struct Stu s=&#123;"lisi",22&#125;;//初始化 2. 1234567struct Node &#123; int data; struct Stu p; struct Node* next; &#125;n=&#123;10,&#123;"wangwu",21&#125;,NULL&#125;;//结构体嵌套初始化 struct Node w=&#123;20,&#123;"liwu",23&#125;,NULL&#125;;//结构体嵌套初始化 三、结构体内存对齐 1.结构体的对齐原则： （1）第一个成员在与结构体变量偏移量为0的地址处。 （2）其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数=编译器默认的一个对齐数与该成员的大小的较小值。VS中默认的值为8， Linux中默认的值为4 （3）结构体总大小为最大对齐数（每个成员变量除了第一个成员都有一个对齐数）的整数倍。 （4）如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍。 总体来说：结构体的内存对齐是拿空间换时间的做法，除此，对于结构体传参的问题，要传结构体的地址（函数传参的时候，参数是需要压栈的，如果传递一个结构体对象时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降）。 四、位段 1.位段的声明和结构是相似的，有两个不同（一、位段的成员必须是int ,unsigned int，char.二，位段的成员名后边有一个冒号和一个数字）如： 12345struct A&#123; int _a:2; int _b:5;&#125;; 2.位段的内存分配 （1）位段的空间上是按照需要以4个字节（int）或者1个字节（char）的方式来开辟的。 （2）位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。 总体来说，跟结构相比，位段可以达到同样的效果，但是可以很好的节约空间，但是有跨平台的问题存在。 五、枚举枚举顾名思义就是一一列举。 1.枚举类型的定义 12345678910enum Day &#123; Mon, Tues, Wed, Thur, Fri, Sat, Sun &#125;; {}中的内容是枚举类型的可能取值，也叫枚举常量。这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值的。如 123456enum color &#123; RED=1, GREEN=2, BLUE=4 &#125;; 六、联合 1.联合类型的定义 联合类型定义的变量包含一系列的成员，特征是这些成员公用同一块空间（联合也称为共用体）。比如： 12345678//联合类型的声明 union Un &#123; char c; int i; &#125;; //联合变量的定义 union Un un; 2.联合的特点联合的成员是共用同一块内存空间的，这样一个联合变量的大小至少是最大成员的大小。 3.联合大小的计算 （1）联合的大小至少是最大成员的大小。 （2）当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>自定义类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next博客进阶攻略]]></title>
    <url>%2F2018%2F05%2F22%2Fhexo-next%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[今天我将在Tim讲解完使用Github+hexo+next初步搭建自己的博客后继续讲解如何美化我们的博客，或者增加实用的（或者花里胡哨的）功能： 什么？你没看Tim的搭建攻略？没事，传送门在此：https://zouchanglin.github.io/2018/05/08/2018050801/ 搭建前先说两句 再看这篇攻略之前确保你搭建好了自己的博客并且能正常使用 最好使用next主题，否则部分功能可能不能正常使用 不要作出改动后忘了保存 不要保存改动之后立即hexo d查看效果，Github服务器离我们远得很，会有延迟，建议使用hexo s在本地预览效果 在进行攻略前最好备份自己的博客，因为代码中少一个符号都可能导致你的博客界面变成空白！！！！ 一定要看上面几句话！！！！ 功能列表 增加用户头像 增加文章字数统计与估计阅读时长和统计站点总字数 实现分享功能 实现博客内点击事件 实现显示访客数量 实现单篇文章统计访问数 实现评论功能 添加Github导航条 实现统计站点运行时间 预览前面所有的效果：http://lrsand52m.top 增加用户头像 在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/img/ 目录下） 比如我的头像图片文件名是：LRS.png 那么我把这个文件放进/img文件夹 然后在博客根目录下_config.yml里加上下面的代码： 12avatar: /img/LRS.png#上面是头像代码，把LRS.png改成你自己的头像文件名即可 最后打开git bash，输入hexo g，然后hexo s在本地服务器查看效果吧~~~ 增加文章字数统计与估计阅读时长和统计站点总字数 我们在实现这个功能前需要安装wordcount插件: 在git bash输入下面的代码即可 1npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： （查看node版本：node -v） 1npm install hexo-wordcount@2 --save NexT 主题默认已经集成了文章【字数统计】、【阅读时长】，【站点总字数】统计功能，如果我们需要使用，只需要在主题配置文件/next目录下的 _config.yml 中打开 wordcount 统计功能即可。如下所示： 你可以开启你自己想要开启的，下面表示全开 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计，如不需要此功能就把前面的true改为false，下同理 min2read: true # 单篇 阅读时长 totalcount: true # 网站 字数统计 separated_meta: true 改动之后我们还要加上说明否则站点的显示只有数字没有单位，所以我们要打开这个文件：/next/layout/_macro/post.swig ,找到下面的代码 123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt; 将它改为 123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 同理，我们修改【阅读时长】，修改后如下： 123&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 总字数统计也同理— — 修改完成后，重新执行启动服务预览就可以了。修改后，效果如下图所示： 感觉如何？ ​ 增加分享功能 关于分享我首先是找到了使用shareSDK的分享功能，最后在实践的过程中发现它添加时步骤比较多，添加完成后效果比较丑（就是一个长条的浅蓝色按钮），而且点击后想要退出分享比较麻烦（它的取消按钮实在太难找了，它在页面最下方的位置，呈现浅灰色，这个设计太反人类了，决定放弃它了）。 在next主题的官方的文档中发现它自身集成了百度分享的功能，所以决定采用百度了。 打开/next目录下的 _config.yml找到下面的代码： 1234567# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare: #type: buttonbaidushare: true 如果没找到也别慌，自己写这么一段就好 把它改成： 12345678910#Sharesharesdk: trueshareSDKappkey: 25ec71ed74ff0# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: type: slide baidushare: true 保存后再hexo g加hexo s在本地看看效果吧~~大概长这样： 实现博客内点击事件 这个功能很花里胡哨，具体看图： 实现之后在你的博客里每点击一次就会生成颜色各异的爱心 要实现点击出现桃心效果，需要在/themes/next/source/js/src里面新建一个love.js文件，在里面粘贴下面的代码：(代码有点乱，但是不影响) 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug），引用love.js ，就是在文档末尾输入一行代码：（就是/body&gt;和/html&gt;的下面） 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 大功告成！保存后再hexo g加hexo s在本地看看效果吧~~ 实现显示访客数量 打开\themes\next\layout_partials\footer.swig文件,在类copyright前加上红箭头指向的这句代码： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 实现单篇文章统计访问数 本段介绍如何实现通过leanCloud统计您网站的文章阅读量，并介绍一些基本实现方法。 值得庆幸的是Next主题默认就支持leanCloud的相关设置，你只需要进行几部操作就可以实现 ： 注册LeanCloud 注册leanCloud,操作过程略 创建应用： 应用名称可随意 点击应用名字进入应用 创建一个叫Counter的class： 操作完成，在左边你会看到Counter的表 获取AppID和AppKey 点击左边的设置 找到应用key选项 获取其中的你的AppID和你的AppKey 设置主题配置文件设置主题配置文件_config.yml相关字段，实现阅读数量的统计添加以下字段 1234leancloud_visitors: enable: true app_id: #此处填你的app_id app_key: #此处填你的的app_key 完成配置并重新编译。到此已经成功设置了阅读量的统计。 注意！！！！！！ 如果完成上述操作你已经正常显示了文章阅读统计那么下面的额外操作就不需要看了，你可以直接跳过。 但是如果你没有实现该功能，那么请仔细阅读下面的额外操作，尽量别把代码抄错了！ 额外操作部分 按照next的代码组成和位置(当然你可以自定你的相关代码位置，本例将以next的位置方式存放对应的代码文件) 要实现leanCloud的相关功能你需要编辑或者新建以下部分代码: _layout.swig -themes\next\layout\_layout.swig:主要是引用leanCloud的代码文件(此文件也是主题全局初始化引用接口) post.swig -themes\next\layout\_macro\post.swig:主要是文章主题的代码文件(包含主题显示阅读数量的代码) lean-analytics.swig -themes\next\layout\_scripts\third-party\lean-analytics.swig:包含leanCloud功能代码文件以上为next的文件解析和位置介绍。你可以不需要按照以上位置设置，但相关文件的代码引用需要您自行修改。如果文件存在请新建。以下贴出相关代码 实现代码 _layout.swig代码 你需要添加以下部分代码：通常如果next集成了leanCloud,你会发现以下代码 代码的作用是引用leanCloud的功能代码。 1&#123;% include &apos;_scripts/third-party/lean-analytics.swig&apos; %&#125; post.swig代码 你需要在合适的位置添加如下代码，同理如果你的NEXT集成了LeanCloud功能，你会发现以下代码 代码主要是在文章显示阅读次数等 1234567891011&#123;# LeanCould PageView #&#125;&#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt; &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; lean-analytic.swig代码 如果你的NEXT集成了leanCloud功能，你会在本文提到的位置看到此文件，若果没有请新建并填入 以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&#123;% if theme.leancloud_visitors.enable %&#125; &#123;# custom analytics part create by xiamo #&#125; &lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt;AV.initialize(&quot;&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;&quot;, &quot;&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;&quot;);&lt;/script&gt; &lt;script&gt; function showTime(Counter) &#123; var query = new AV.Query(Counter); var entries = []; var $visitors = $(&quot;.leancloud_visitors&quot;); $visitors.each(function () &#123; entries.push( $(this).attr(&quot;id&quot;).trim() ); &#125;); query.containedIn(&apos;url&apos;, entries); query.find() .done(function (results) &#123; var COUNT_CONTAINER_REF = &apos;.leancloud-visitors-count&apos;; if (results.length === 0) &#123; $visitors.find(COUNT_CONTAINER_REF).text(0); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var item = results[i]; var url = item.get(&apos;url&apos;); var time = item.get(&apos;time&apos;); var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(time); &#125; &#125;) .fail(function (object, error) &#123; console.log(&quot;Error: &quot; + error.code + &quot; &quot; + error.message); &#125;); &#125; function addCount(Counter) &#123; var $visitors = $(&quot;.leancloud_visitors&quot;); var url = $visitors.attr(&apos;id&apos;).trim(); var title = $visitors.attr(&apos;data-flag-title&apos;).trim(); var query = new AV.Query(Counter); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment(&quot;time&quot;); counter.save(null, &#123; success: function(counter) &#123; var $element = $(document.getElementById(url)); $element.find(&apos;.leancloud-visitors-count&apos;).text(counter.get(&apos;time&apos;)); &#125;, error: function(counter, error) &#123; console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); /* End Set ACL */ newcounter.set(&quot;title&quot;, title); newcounter.set(&quot;url&quot;, url); newcounter.set(&quot;time&quot;, 1); newcounter.save(null, &#123; success: function(newcounter) &#123; var $element = $(document.getElementById(url)); $element.find(&apos;.leancloud-visitors-count&apos;).text(newcounter.get(&apos;time&apos;)); &#125;, error: function(newcounter, error) &#123; console.log(&apos;Failed to create&apos;); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message); &#125; &#125;); &#125; $(function() &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123; addCount(Counter); &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123; showTime(Counter); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125; 修改语言配置文件 主要是添加visitors字段英文网站：修改themes\next\languages\en.yml 12345post: sticky: Sticky posted: Posted on visitors: Views // 增加的字段 ... 中文网站：修改themes\next\languages\zh-Hans.yml 1234post: posted: 发表于 visitors: 阅读次数 ... WEB安全 为了保证应用的统计计数功能仅应用于自己的博客系统，你可以在应用-&gt;设置-&gt;安全中心的Web安全域名 中加入自己的博客域名，以保证数据的调用安全。 设置完成 以上部分设置完成，就可以正常使用leanCloudS实现文章阅读统计。 实现评论功能 评论功能概述 目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。 可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气。） 来必力：https://livere.com （来自韩国，使用邮箱注册。） 畅言： http://changyan.kuaizhan.com （安装需要备案号。不太好用。） Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。） Valine: https://github.com/xCss/Valine (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？） 综上，最终采用了来必力。 注册账号 打开来必力官网注册：https://livere.com （如注册不来请自行科学上网） 安装 点击上方的安装，选择免费的city版本。 并点击现在安装，出现如下界面。 复制其中的uid字段。 打开主题目录下的blog/themes/next/_config.yml配置文件，定位到livere_uid字段，粘贴上刚刚复制的UID。 至此，大功告成。 添加Github导航条 在首页添加github导航条，点击这里选择需要的样式，然后将代码复制到themes/next/layout/_layout.swig 并将href后面的网址改为你的github地址，最终界面如图 ： 实现统计站点运行时间 实时展示你的博客已经运行了多长时间了，我还是蛮喜欢这个功能的，随着时间的增长，和你的博客访问量形成照样，成就感也会增添不少。 在 hexo/themes/[your theme]/layout 文件夹下找到你的 footer 文件，即脚布局文件，在对应的位置添加一下代码。 1234567891011121314151617&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;02/14/2018 12:49:00&quot;);//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 下面是效果图： 结语 功能暂时只添加这么多，后面应该会持续更新些新奇的玩意，想查看所有效果的预览，请直接进：http://lrsand52m.top 感谢你的观看！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主要元素求法及优化]]></title>
    <url>%2F2018%2F05%2F21%2F%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0%E6%B1%82%E6%B3%95%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在一本书中，我看到这样一道题：已知一个数组中有一个元素的出现次数占所有元素个数一半以上，找出这个元素。 我想：真简单！ 是的，两个for循环能解决的问题，的确不能说难。 但是，两个for循环的确有些浪费，效率也奇低，有点儿“拿不出手”，所以我开始思索如何简化算法（日常思索）： 突然我心生一计：既然出现的频率这么高，那我对这个数组排完序，出现在中间的数不就是这个主要元素吗？ 121. 假设数组为：5 4 3 3 3 2 3 1 3 2. 排完序后为：1 2 3 3 3 3 3 4 5 这样这个算法的时间复杂度就完全取决于我排序算法的时间复杂度了 真是令人振奋呢：排序有三种不同时间复杂度的： 排序方法 复杂度 推荐程度 冒泡排序 O(N^2) ** 桶排序 O(N) ** 快速排序 O(NlogN) *** … … … 当然这里只推荐快排，因为我们给出的数值范围不确定，这样桶排序极其容易浪费掉大量内存，也是“拿不出手”的。 但是快排的时间复杂度也不能说是很低，能不能更加简化呢？比如说O(N)或者O(logN)？ 好吧，我们是理智人，O(logN)就有点逆天，毕竟读入数组就不止这个复杂度了。 所以我们重点讨论O(N)的情形： 消除法：因为占的”份额”实在是多，所以主要元素就是与其他元素一一消除，最终剩下的数也绝对是主元素，所以我们可以考虑用这个方法来“消”出这个主要元素。 这样我们就创造一个计数器k，当遇到相同元素+1，不同减一，很容易知道最终结果必为正数。不过中间过程中会遇到为0的情况，这样我们就初始化k的值，并且把他的指向保存到下一位就行了。 在指完整个数组后，最近保存的指向肯定就是主要元素啦！（想想为什么） 代码附上： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main() &#123; int n; int a[100] = &#123;0&#125;; int book = 1;//提供消除依据 int i = 0; int num = 0;//记录当前比较的数 scanf("%d",&amp;n); for(i=0; i&lt;n; i++) &#123; scanf("%d",&amp;a[i]); &#125; i = 1; if(1 == n); else &#123; while(i&lt;n) &#123; if(a[i] == a[num]) &#123; book++;//相等book+1，数组元素向后寻找 i++; &#125; else &#123; book--;//不等-1 if(!book) &#123; i++;//book=0时，标记数也之移动 num = i; &#125; else i++; &#125; &#125; &#125; printf("主元素为：%d\n",a[num]);//主要元素肯定是标记的数，输出就行 return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组运算</tag>
      </tags>
  </entry>
</search>
