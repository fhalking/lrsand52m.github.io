<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何用C语言写一个简易的截屏程序]]></title>
    <url>%2F2018%2F06%2F13%2F%E5%A6%82%E4%BD%95%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%88%AA%E5%B1%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[某天当我写完了鼠标连点器之后，鹏哥问我能不能写个截屏工具出来，当时我那叫一个···(不屑)，不就是一个截屏嘛，多简单！然而事情没这么简单，随后鹏哥向我展示了他声称找了很久的截屏小工具：当时我的表情： &gt; _ &lt; 这..我可不包UI设计啊，还有我只是个刚学会一点C皮毛的纯新手…只好回去百度我需要的相关接口了思路截取屏幕，怎么截，截哪里，怎么存，存哪里，都是问题于是一脸纠结的我理所当然的选择了最好存的图片格式：Bitmap位图，就是.bmp格式的图片，它的特征特别明显：容易存容易读，就是占用空间大。然后就是怎么截，不管怎么截，我产生一个全屏幕窗口设备描述表的兼容位图总是没错的，你要截全屏我就都存到文件，你要截一部分我就在上面划那个一部分给你再存也就完事了至于截哪里的问题，我本来想模仿qq截图来着，但是人家是按下快捷键后已经截取了全屏，然后让你用鼠标操作…（你懂得，我这菜鸟哪懂这样要怎么实现嘛），那我想，那我就退而求其次。利用鼠标的实时位置以及按键触发来确定你的截图起始位置，这样也算是能够以相对简单的方式实现了（我想你应该不会想用直接输入你想从哪个像素开始到哪个像素结束的方式来截一个图吧）。存到哪里这个问题倒是好解决，我在c盘下创建一个专门存放截屏的目录，然后对每个截屏都取一个独一无二的名字这样就解决了存哪里的问题 源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wtypes.h&gt;#include &lt;tchar.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;//#include&lt;afx.h&gt;//默认储存路径char path[260] = "c:/shots/";//设置文件名称char* setname(char* p)&#123; //strcat(p, "-"); //strcat(p, __DATE__); char * ret = p; while (*p) &#123; if (*p == ':' || *p == ' '||*p == '\n')*p = '-'; p++; &#125; *(p - 1) = 0; strcat(ret, ".bmp"); return ret;&#125;//设置打印位置void CaptureScreen(int x1, int y1, int x2, int y2)&#123; time_t lt = time(NULL); char p[100] = &#123;0&#125;; char name[100] = &#123;0&#125;; int t = 0; strcpy(p, ctime(&amp;lt)); setname(p); sprintf(name, "%s%s",path,p); printf("保存至:\n%s",name); //system("pause"); if (x2 &lt; x1) &#123; t = x2; x2 = x1; x1 = t; &#125; if (y2 &lt; y1) &#123; t = y2; y2 = y1; y1 = t; &#125; //获得桌面窗口句柄 HWND hDesktopWnd = GetDesktopWindow(); //获得桌面窗口设备环境 HDC hDesktopDC = GetDC(hDesktopWnd); //产生全屏幕窗口设备描述表的兼容设备环境 HDC hCaptureDC = CreateCompatibleDC(hDesktopDC); //产生全屏幕窗口设备描述表的兼容位图 HBITMAP hCaptureBitmap = CreateCompatibleBitmap(hDesktopDC, x2, y2); printf("\n宽度:%d\n高度:%d\n", x2 - x1, y2 - y1); //system("pause"); //将兼容位图选入兼容设备环境 SelectObject(hCaptureDC, hCaptureBitmap); //将全屏幕窗口位图的象素数据拷贝到兼容设备描述表 BitBlt(hCaptureDC, 0, 0, x2-x1, y2-y1, hDesktopDC, x1, y1, SRCCOPY); BITMAPINFO bi; void *pBits = NULL; ZeroMemory(&amp;bi, sizeof(bi)); bi.bmiHeader.biSize = sizeof(bi.bmiHeader); bi.bmiHeader.biHeight = (y2 - y1); bi.bmiHeader.biWidth = (x2 - x1); bi.bmiHeader.biPlanes = 1; bi.bmiHeader.biBitCount = 24; bi.bmiHeader.biCompression = BI_RGB; bi.bmiHeader.biSizeImage = 3 * (y2 - y1)*(x2 - x1); //产生位图兼容设备描述表 //DECLARE_HANDLE(HDC); HDC hBmpFileDC = CreateCompatibleDC(hDesktopDC); //产生位图兼容位图 HBITMAP hBmpFileBitmap = CreateDIBSection(hDesktopDC, &amp;bi, DIB_RGB_COLORS, &amp;pBits, NULL, 0); //将兼容位图选入兼设备描述表容设备描述表 SelectObject(hBmpFileDC, hBmpFileBitmap); //将捕获的位图的象素拷贝到位图设备环境 BitBlt(hBmpFileDC, 0, 0, x2 - x1, y2 - y1, hCaptureDC, 0, 0, SRCCOPY); //创建文件 typedef void * HANDLE; HANDLE hFile = CreateFile(name, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); //保存位图文件 if (hFile != INVALID_HANDLE_VALUE) &#123; DWORD dwRet = 0; BITMAPFILEHEADER bmfHeader; ZeroMemory(&amp;bmfHeader, sizeof(bmfHeader)); bmfHeader.bfOffBits = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER); bmfHeader.bfSize = bi.bmiHeader.biSizeImage + bmfHeader.bfOffBits; bmfHeader.bfType = 'MB'; //写入位图信息头 WriteFile(hFile, &amp;bmfHeader, sizeof(bmfHeader), &amp;dwRet, NULL); //写入位图尺寸颜色表等信息 WriteFile(hFile, &amp;bi.bmiHeader, sizeof(bi.bmiHeader), &amp;dwRet, NULL); //写入位图数据块 WriteFile(hFile, pBits, bi.bmiHeader.biSizeImage, &amp;dwRet, NULL); //剪切板操作，当前有兼容性问题，故注释，正在解决 ////写入剪切板 //if (OpenClipboard(NULL) &amp;&amp; EmptyClipboard()) //&#123; // SetClipboardData(CF_BITMAP, hFile); //&#125; //CloseClipboard(); CloseHandle(hFile); &#125; DeleteDC(hBmpFileDC); DeleteObject(hBmpFileBitmap); ReleaseDC(hDesktopWnd, hDesktopDC); DeleteDC(hCaptureDC); DeleteObject(hCaptureBitmap);&#125;void Pos(int x, int y)&#123; COORD pos; HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput, pos);&#125;void printpos(int *x, int* y,int z)&#123; long zx = -1; long zy = -1; POINT ptB = &#123; 0, 0 &#125;; //typedef struct tagPOINT //&#123; //LONG x; //LONG y; //&#125; POINT, * PPOINT, NEAR * NPPOINT, FAR * LPPOINT; while (1) &#123; LPPOINT xy = &amp;ptB; //位置变量 GetCursorPos(xy); //获取鼠标当前位置 //如果鼠标移动，（即当前的坐标改变则打印出坐标）打印出做坐标。 if ((zx != xy-&gt;x) || (zy != xy-&gt;y)) &#123; Pos(0, z); printf("x=%4d,y=%4d\n", xy-&gt;x*1920/1536, xy-&gt;y*1080/864); zx = xy-&gt;x; zy = xy-&gt;y; &#125; if (GetAsyncKeyState('Q')&amp;&amp;GetAsyncKeyState( VK_CONTROL)) &#123; ShowWindow(FindWindow(NULL, _T("shot")), SW_MINIMIZE); Sleep(500); CaptureScreen(0, 0, 1920, 1080); break; &#125; if (GetAsyncKeyState(VK_SPACE)) &#123; //若打印出来的坐标超过1920 1080请将下面的乘除操作去掉 *x = xy-&gt;x*1920/1536; *y = xy-&gt;y*1080/864; break; &#125; &#125;&#125;char * change(char*p)&#123; char*ret = p; while (*p) &#123; if (*p == '/') *p = '\\'; p++; &#125; if (*(p - 1) != '\\')strcat(p-1, "\\"); return ret;&#125;int main()&#123; int i = 0; int x1, x2, y1, y2; char c = 0; char cpath[270] = &#123; 0 &#125;; //改变窗口名称，方便进行最小化 system("title shot"); //修改窗口大小 system("mode con cols=40 lines=10"); printf("是否改变储存路径？(y/n)"); scanf("%c", &amp;c); if (c == 'y') &#123; system("cls"); printf("请输入新路径:\n$ "); scanf("%s", path); change(path); &#125; sprintf(cpath, "md %s", path); //创建相应路径，如果已经存在也没事 system(cpath); system("cls"); Pos(0, 9); printf("按下Ctrl+Q截取全屏\n按下Ctrl+W进入截屏"); while (1) &#123; Pos(0, 0); if (GetAsyncKeyState('Q') &amp;&amp; GetAsyncKeyState(VK_CONTROL)) &#123; i = 0; while (i &lt; 8) &#123; Pos(0, i++); printf(" "); &#125; Pos(0, 0); ShowWindow(FindWindow(NULL, _T("shot")), SW_MINIMIZE); Sleep(500); CaptureScreen(0, 0, 1920, 1080); &#125; if (GetAsyncKeyState(VK_CONTROL) &amp;&amp; GetAsyncKeyState('W')) &#123; i = 0; while (i &lt; 8) &#123; Pos(0, i++); printf(" "); &#125; Pos(0, 0); printf("按下空格选取截图起点\n"); printpos(&amp;x1, &amp;y1, 1); Sleep(300); printf("按下空格选取截图终点\n"); printpos(&amp;x2, &amp;y2, 3); CaptureScreen(x1, y1, x2, y2); i = 0; //if (GetAsyncKeyState(VK_ESCAPE)) //break; &#125; &#125; return 0;&#125; 这样我们的截屏工具就做好了，它在前台运行时使用截全屏会自动隐藏，这样不会截到自己（就不会挡住一些东西）当然也可以后台运行，你只要记住快捷键就好了！刚进入程序时不想改变默认路径可以直接回车，想改变的话就按提示操作吧~]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现鼠标连点器]]></title>
    <url>%2F2018%2F06%2F07%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E8%BF%9E%E7%82%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[今天我们实现一个鼠标连点器，点击位置，点击间隔，点击次数，点击左键还是右键，双击还是单击都可以自定义工具：VS2013语言：C 有天看见同学在淘宝上抢购一款智能手表，原价169元才卖1.69元，可惜数量有限，没想到他们等了很久开始抢，一秒钟不到就被抢光了，我在旁边看着都能感受到他们的心碎。回到宿舍，我想：无非就是拼手速，为何我不做一个鼠标快速连点器呢？这样一秒钟点一百下，我就不信抢不到！于是，我回去开始写起了代码： 头文件click.h1234567891011121314151617#pragma once#include &lt;tchar.h&gt;#include&lt;stdio.h&gt;//#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;afxwin.h&gt;#define clt CLK_TCKvoid Pos(int x,int y);int prints(char*, int);int getMapArray(char *mapname, unsigned char *maparray, int* mapwidth, int* mapheight);unsigned int printimg(char* argv);int move(int x, int y);int click(int type, int double_click);int clicks(int type, int double_click, int time, int count, int px, int py);void printpos(int *x,int *y); 源文件mouse.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define _CRT_SECURE_NO_WARNINGS#include "click.h"//const int MOUSEEVENTF_MOVE = 0x0001; //移动鼠标//const int MOUSEEVENTF_LEFTDOWN = 0x0002; //模拟鼠标左键按下//const int MOUSEEVENTF_LEFTUP = 0x0004; //模拟鼠标左键抬起//const int MOUSEEVENTF_RIGHTDOWN = 0x0008; //模拟鼠标右键按下//const int MOUSEEVENTF_RIGHTUP = 0x0010; //模拟鼠标右键抬起//const int MOUSEEVENTF_MIDDLEDOWN = 0x0020;//模拟鼠标中键按下//const int MOUSEEVENTF_MIDDLEUP = 0x0040; //模拟鼠标中键抬起//const int MOUSEEVENTF_ABSOLUTE = 0x8000; //标示是否采用绝对坐标/** mouse move* x -- int, x-coordinate* y -- int, y-coordinate*///打印坐标void printpos(int *x, int* y)&#123; long zx = -1; long zy = -1; POINT ptB = &#123; 0, 0 &#125;; /* typedef struct tagPOINT &#123; LONG x; LONG y; &#125; POINT, * PPOINT, NEAR * NPPOINT, FAR * LPPOINT; */ while (1) &#123; LPPOINT xy = &amp;ptB; //位置变量 GetCursorPos(xy); //获取鼠标当前位置 //如果鼠标移动，（即当前的坐标改变则打印出坐标）打印出做坐标。 if ((zx != xy-&gt;x) || (zy != xy-&gt;y)) &#123; Pos(0, 2); printf("x=%4d,y=%4d\n", xy-&gt;x, xy-&gt;y); zx = xy-&gt;x; zy = xy-&gt;y; &#125; if (GetAsyncKeyState(VK_ESCAPE)) &#123; *x = xy-&gt;x; *y = xy-&gt;y; break; &#125; &#125;&#125;//设置打印位置void Pos(int x, int y)&#123; COORD pos; HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput, pos);&#125;//鼠标移动int move(int x, int y)&#123; typedef BOOL(WINAPI *Fun1)(int x, int y); //#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name //DECLARE_HANDLE(HINSTANCE); HINSTANCE hDll; hDll = LoadLibrary("user32.dll"); if (NULL == hDll) &#123; fprintf(stderr, "load dll 'user32.dll' fail."); return -1; &#125; Fun1 SetCursorPos = (Fun1)GetProcAddress(hDll, "SetCursorPos"); if (NULL == SetCursorPos) &#123; fprintf(stderr, "call function 'SetCursorPos' fail."); FreeLibrary(hDll); return -1; &#125; SetCursorPos(x, y); FreeLibrary(hDll); return 0;&#125;/** mouse click* type -- int, 0:left click;1:right click* double_click -- bool, true:double click; false: single click*///鼠标点击int clicks(int type, int double_click, int time, int count, int px, int py)&#123; int t = 0; while (1) &#123; move(px, py); Sleep(time); click(type, double_click); count--; t++; if (!count)break; if (GetAsyncKeyState(VK_ESCAPE)) break; &#125; return t;&#125;int click(int type, int double_click)&#123; int left_click = MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP; int right_click = MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_RIGHTUP; int clicktype; HINSTANCE hDll; typedef void(WINAPI*Fun2) ( //typedef unsigned long DWORD; DWORD dwFlags, // motion and click options DWORD dx, // horizontal position or change DWORD dy, // vertical position or change DWORD dwData, // wheel movement //typedef unsigned long _win64 *ULONG_PTR ULONG_PTR dwExtraInfo // application-defined information ); hDll = LoadLibrary("user32.dll"); if (NULL == hDll) &#123; fprintf(stderr, "load dll 'user32.dll' fail."); return -1; &#125; Fun2 mouse_event = (Fun2)GetProcAddress(hDll, "mouse_event"); if (NULL == mouse_event) &#123; fprintf(stderr, "call function 'mouse_event' fail."); FreeLibrary(hDll); return -1; &#125; if (type == 0) clicktype = left_click; else clicktype = right_click; mouse_event(clicktype, 0, 0, 0, 0); FreeLibrary(hDll); if (double_click) click(type, 0); return 0;&#125; laindian.cpp123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS#include "click.h"int main()&#123; int x, y, count; int time; int dou = 0; int lef = 0; int sum = 0; char mess[250]; printf("欢迎使用鼠标连点器！\n按下ESC确认坐标："); printpos(&amp;x,&amp;y); printf("请输入延时(毫秒)和点击次数(0表示无限,随时可以按下ESC来中断点击):"); scanf("%d %d", &amp;time, &amp;count); printf("十秒后开始点击！"); Sleep(10000); sum = clicks(lef, dou, time, count, x, y); wsprintf(mess, _T("%s\n%s%d%s"), _T("点击完毕"), _T("共点击:"), sum, _T("次")); MessageBox(0, mess, _T("点击结束"), MB_OK); return 0; &#125; 这样写完代码之后，记得把项目-属性-配置属性-常规-项目默认值-MFC的使用改为在共享 DLL 中使用 MFC就完全搞定了！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言小项目之注释转换C->Cpp]]></title>
    <url>%2F2018%2F06%2F04%2FC%E8%AF%AD%E8%A8%80%E5%B0%8F%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%B3%A8%E9%87%8A%E8%BD%AC%E6%8D%A2C-Cpp%2F</url>
    <content type="text"><![CDATA[今天我们来实现一下C语言经典小项目：注释转换，并且利用命令行参数，对某个文件夹及所有子文件夹里的对应文件进行注释转换，无关文件进行复制操作，形成一个经过处理的新文件夹。 注释转换基本思路 转换方法先分析如下图：（字符串状态因为处理简单没有画出）由图可以看出，将注释转换过程分为四种状态，NULL_STATE(无注释状态)、C_STATE(C语言注释状态)、CPP_STATE(C++注释状态)、END_STATE(文件结束状态)，通过四种状态的相互切换实现注释的转换，具体实现过程为：用文件的方式中函数fopen打开源文件input.c,并进行读操作，打开output.c文件，进行注释转换后的写操作，转换过程中调用函数CommentConvert(pfIn,pfOut)转换，先在NULL_STATE状态下用函数fgetc函数读取第一个字符，若为’/‘,再读取第二个字符，若为’ * ‘则切换到C_STATE状态实现，若第二个字符为’/‘,则切换到CPP_STATE状态实现，如此一直相互切换，并在各自状态具体代码实现下用fputc函数输出转换为C++注释和各个原字符，直至遇到EOF,状态切换为end_state.而在C语言注释下遇到的注释情况如下: 12345678910111213141516171819202122232425262728293031323334// 1.一般情况int num = 0;/* int i = 0; */// 2.换行问题/* int i = 0; */int j = 0;/* int i = 0; */int j = 0;// 3.匹配问题/*int i = 0;/*xxxxx*/// 4.多行注释问题/*int i=0;int j = 0;int k = 0;*/int k = 0;// 5.连续注释问题/**//**/// 6.连续的**/问题/***/// 7.C++注释问题// /*xxxxxxxxxxxx*/// 8.字符串注释问题char* p = "/*/////////////////adfasdfas";/* char* q = "/////"*/// char* x = "/**////**///"// 根据状态机和我们可能遇到的状况，我们开始写代码： 头文件ctocpp.h1234567891011121314151617181920212223#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define INPUTFILENAME "in.c"#define OUTPUTFILENAME "out.c"typedef enum CONVERT_START//枚举表示操作选项&#123; NULL_START, C_START, CPP_START, END_START, STR_START&#125;StateType;void CommentConvert();void ConvertWork(FILE* read, FILE* write);//注释转换操作选项函数void DoCState(FILE* read, FILE* write);//C 转换为 cpp函数void DoNullState(FILE* read, FILE* write);//普通语句空转换函数void DoCppState(FILE* read, FILE* write);//cpp 转换函数void DOStrState(FILE* read, FILE* write);//字符串状态 源文件test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#define _CRT_SECURE_NO_WARNINGS#include"ctocpp.h"#include &lt;windows.h&gt; #include &lt;stdio.h&gt; char newd[1000];char path[1000];char newout[1000];void enum_path(char *cpath)&#123; //typedef struct _WIN32_FIND_DATAA &#123; //DWORD dwFileAttributes; /*typedef unsigned long DWORD;*/ //FILETIME ftCreationTime; //FILETIME ftLastAccessTime; //FILETIME ftLastWriteTime; /*typedef struct _FILETIME &#123; DWORD dwLowDateTime; DWORD dwHighDateTime; &#125; FILETIME*/ //DWORD nFileSizeHigh; //DWORD nFileSizeLow; //DWORD dwReserved0; //DWORD dwReserved1; // CHAR cFileName[MAX_PATH]; // CHAR cAlternateFileName[14]; //&#125; WIN32_FIND_DATAA //typedef WIN32_FIND_DATAA WIN32_FIND_DATA //上面是WIN32_FIND_DATA的定义，其实就是类似于 FILE 型，是一种文件流类型 WIN32_FIND_DATA wfd; //HANDLE 实际上就是void * HANDLE hfd; char cdir[MAX_PATH]; char subdir[MAX_PATH]; int r; //接收当前目录字符串的缓冲区指针。cdir字符串指定当前目录的绝对路径。 GetCurrentDirectory(MAX_PATH, cdir); SetCurrentDirectory(cpath);//更改当前进程的当前目录。 //*是通配符，此函数在当前目录下寻找形如xxxx.xxxx的文件 //（就是查找所有文件了....并且如果有文件(夹)的话必定找到第一个） hfd = FindFirstFile("*.*", &amp;wfd); //#define INVALID_HANDLE_VALUE ((HANDLE)(long)-1)这个是查找文件失败的返回值 if (hfd != INVALID_HANDLE_VALUE) &#123; //上面的if语句的意思就是只要找到任何文件(夹)就进行如下循环 do &#123; if (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)//#define FILE_ATTRIBUTE_DIRECTORY 0x00000010 &#123; //上面的if语句用来判断此次查找到的到底是文件还是文件夹 if (wfd.cFileName[0] != '.') //找到的文件名的第一个字符不是“.”的话表示这是一个文件夹，否则就是一个返回上层的接口 &#123; int len = strlen(newd); // 合成完整路径名 //找到的文件(夹)名会存放在结构体的cFileName里 sprintf(subdir, "%s\\%s", cpath, wfd.cFileName); //printf("read...%s\n", subdir); //创建相应的输出文件夹 sprintf(newd, "%s\\%s", newd, wfd.cFileName); //printf("\t\t%s....\n", newd); system(newd); // 递归枚举子目录 enum_path(subdir); //递归完毕后处理新建路径 newd[len] = '\0'; &#125; &#125; else &#123; //新文件路径 sprintf(newout, "%s\\%s", newd+3, wfd.cFileName); //printf("%s\n", newout); //待处理文件路径 sprintf(path,"%s\\%s", cpath, wfd.cFileName); //printf("%s\n", path); //是需要注释转换的文件就进行注释转换 if (strcmp(".c", path + strlen(path) - 2) == 0) CommentConvert(); else if (strcmp(".h", path + strlen(path) - 2) == 0) CommentConvert(); else if (strcmp(".cpp", path + strlen(path) - 4) == 0) CommentConvert(); else//不需要注释转换就直接复制 &#123; printf("copy %s to %s\n", path, newout);//显示复制信息 file_copy(); &#125; &#125; &#125; while (r = FindNextFile(hfd, &amp;wfd), r != 0); //和FindFirstFile类似，向下继续找所有文件(夹)，找不到就返回0 &#125; //处理完毕把工作目录更改回原来的目录以免影响其他功能（与前面的GetCurrentDirectory相呼应） SetCurrentDirectory(cdir);&#125;int main(int argc,char *argv[])&#123; printf("%d\n", argc); if (argc != 3) printf("参数有误！"); else &#123; sprintf(newd, "md %s", argv[2]); //system("md 文件夹名");创建一个文件夹，成功返回1，失败返回0并且在命令窗口可以看见 system(newd); enum_path(argv[1]); &#125; system("pause"); return 0;&#125; ctocpp.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#define _CRT_SECURE_NO_WARNINGS 1 #include"ctocpp.h" StateType state;extern char newd[1000];extern char path[1000];extern char newout[1000];void DOStrState(FILE *read, FILE *write)&#123; int first = fgetc(read); if (first == '"') state = NULL_START; else if(first == '\\')//转义字符直接输出进文件 &#123; int second = fgetc(read); fputc(first, write); fputc(second, write); return; &#125; fputc(first, write);&#125;void DoNullState(FILE *read, FILE *write)//无转换操作函数&#123; int first = fgetc(read); int second; switch (first) &#123; case '/': second = fgetc(read); if (second == '*') &#123; fputc('/', write); fputc('/', write); state = C_START;//状态改为C状态 &#125; else if (second == '/') &#123; fputc(first, write); fputc(second, write); state = CPP_START; //状态改为Cpp状态 &#125; else //普通语句就直接写入 &#123; fputc(first, write); fputc(second, write); &#125; break; case '"': fputc(first, write); state = STR_START; break; case EOF: //fputc(first, write); state = END_START;//注释结束，状态调整 break; default://普通内容直接写入 fputc(first, write); break; &#125;&#125;void DoCState(FILE *read, FILE *write)//C转换为Cpp&#123; int first = fgetc(read); int second = 0; switch (first) &#123; case '*': second = fgetc(read); if (second == '/')//舍弃 */ &#123; int third = fgetc(read); state = NULL_START; if (third != '\n') &#123; fputc('\n', write); ungetc(third, read); &#125; if (third == '\n') &#123; fputc(third, write); &#125; &#125; else &#123; fputc(first, write); ungetc(second, read);//将*之后的内容还回缓冲区 &#125; break; case '\n'://如果是换行将下一行开头加入Cpp注释 fputc(first, write); fputc('/', write); fputc('/', write); break; case EOF: //fputc(first, write); state = END_START; break; default: fputc(first, write); break; &#125;&#125;void DoCppState(FILE *read, FILE *write)//Cpp转换为无状态； &#123; int first = 0; first = fgetc(read); switch (first) &#123; case'\n'://Cpp注释的结束； fputc(first, write); state = NULL_START; break; case EOF: //fputc(first, write); state = END_START; break; default: fputc(first, write); break; &#125;&#125;void ConvertWork(FILE *read, FILE *write)//函数操作选项； &#123; state = NULL_START;//一开始无状态 while (state != END_START) &#123; switch (state) &#123; case NULL_START: DoNullState(read, write); break; case C_START: DoCState(read, write); break; case CPP_START: DoCppState(read, write); break; case STR_START: DOStrState(read, write); break; default: break; &#125; &#125;&#125;//注释转换void CommentConvert()//读写文件函数； &#123; FILE *pWrite = NULL; FILE *pRead = fopen(path, "r"); if (pRead == NULL) &#123; perror(path); //exit(EXIT_FAILURE); &#125; pWrite = fopen(newout,"w"); if (pWrite == NULL) &#123; fclose(pRead); pRead = NULL; perror(newout); //exit(EXIT_FAILURE); &#125; ConvertWork(pRead, pWrite); printf("%s转换成功\n",path); fclose(pRead); pRead = NULL; fclose(pWrite); pWrite = NULL;&#125;//文件复制void file_copy()&#123; int count = 0; char tmp[2]; FILE* write; FILE* read = fopen(path, "rb"); if (read == NULL) &#123; perror("open file for copy"); exit(1); &#125; write = fopen(newout, "wb"); if (write == NULL) &#123; perror("open file for copy source"); fclose(read); exit(1); &#125; do &#123; int judge = fread(tmp, 1, 1, read); if (!judge) &#123; break; &#125; count += fwrite(tmp,1, 1, write); &#125; while (1); printf("copy complete:total byte:%d\n",count); fclose(read); fclose(write); read = NULL; write = NULL;&#125; 这样写完之后，我们在预处理这里写上命令行参数：运行程序，就会在我后面参数的位置生成一个文件夹，里面包括原来文件夹的所有文件（包括隐藏文件），并且所有的.c，.h，.cpp文件都是经过注释转换的了上面的查找文件夹使用了鹏哥推荐的win32 api有兴趣的朋友可以查一查相关资料，绝对会使你受益匪浅。]]></content>
      <categories>
        <category>C语言</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next之给博客加上萌妹子或者萌宠]]></title>
    <url>%2F2018%2F06%2F04%2Fhexo-next%E4%B9%8B%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%8A%E8%90%8C%E5%A6%B9%E5%AD%90%E6%88%96%E8%80%85%E8%90%8C%E5%AE%A0%2F</url>
    <content type="text"><![CDATA[今天我将详细说明如何在自己的博客里加入萌宠或者萌妹子工具:1.hexo+git pages搭建的博客2.live2d资源包 获取在博客站点路径git bash here然后输入以下代码让你获得相关的支持1npm install --save hexo-helper-live2d 然后就是看下面的图片选择你喜欢的注：角色图片不全，因为作者是不断更新的，建议直接访问作者的git仓库找更多角色地址：https://github.com/xiazeyu/live2d-widget-models然后记住你的角色名 输入下面的代码1npm install live2d-widget-model-你选的角色名 就获取完毕了 配置在站点的 _ config.yml 下配置1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-你选的角色名 display: position: right width: 150 height: 300 mobile: show: false 上面的mobile选项决定是否在手机上展示动漫形象我的建议是不要开启，会挡住屏幕当然你如果一定要开，把show改为true即可]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现三子棋(井字棋)游戏]]></title>
    <url>%2F2018%2F06%2F04%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%89%E5%AD%90%E6%A3%8B-%E4%BA%95%E5%AD%97%E6%A3%8B-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[今天我们实现一个C语言做的井字棋游戏，并且给这个游戏加上些难度，让你不是那么好赢（甚至赢不了）语言：C语言工具：VS2013 头文件game.h123456789101112131415161718192021#ifndef __GAME_H__#define __GAME_H__#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;windows.h&gt; #include&lt;time.h&gt; #include&lt;string.h&gt; #define ROW 3 #define LIN 3 void game();void menu(); void initboard(char arr[ROW][LIN], int row, int lin); void checkboard(char arr[ROW][LIN], int row, int lin); void player_go(char arr[ROW][LIN], int row, int lin); void pc_go(char arr[ROW][LIN], int row, int lin, int nan); int is_full(char arr[ROW][LIN], int row, int lin); char is_win(char arr[ROW][LIN], int row, int lin);#endif //game.h 源文件test.c12345678910111213141516171819#include "game.h" int main() &#123; int input=0; do&#123; menu(); printf("请选择： \n"); scanf_s("%d", &amp;input); switch (input) &#123; case 1: game(); break; case 0: exit(0); break; default: printf("请重新输入\n"); break; &#125; &#125; while (1); &#125; game.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350#include "game.h" void game() &#123; int input; char ret; char arr[ROW][LIN] ; while(1) &#123; system("cls"); initboard(arr, ROW, LIN); printf("**************************************\n"); printf("* *\n"); printf("*请选择难度：1.简单 2.困难 3.大师*\n"); printf("* *\n"); printf("**************************************\n"); scanf("%d",&amp;input); if (input&gt;3 || input&lt;1) &#123; printf("输入错误！重新输入！"); Sleep(500); &#125; else break; &#125; system("cls"); printf("\n"); checkboard(arr, ROW, LIN); srand((unsigned int)time(NULL)); do &#123; player_go(arr, ROW, LIN); //system("cls"); checkboard(arr, ROW, LIN); ret = is_win(arr, ROW, LIN); if (ret != ' ') &#123; break; &#125; Sleep(1000); system("cls"); pc_go(arr, ROW, LIN, input); checkboard(arr, ROW, LIN); ret = is_win(arr, ROW, LIN); if (ret != ' ') &#123; break; &#125; &#125; while (1); if (ret == 'X') &#123; printf("你赢了！\n"); system("pause"); system("cls"); &#125; else if (ret == 'O') &#123; printf("你输了！\n"); system("pause"); system("cls"); &#125; else if (ret == 'f') &#123; printf("平局！\n"); system("pause"); system("cls"); &#125; &#125;void menu() &#123; printf("\n 三子棋 \n\n"); printf("***********************\n"); printf("***** 1.开始游戏 *****\n"); printf("***** 0.退出游戏 *****\n"); printf("***********************\n");&#125; void initboard(char arr[][LIN], int row,int lin)//初始化棋盘&#123; memset(arr, ' ', sizeof(arr[0][0])* lin*row);&#125;void checkboard(char arr[][LIN], int row, int lin)//打印棋盘&#123; int i = 0; int j = 0; for (i=0; i&lt;row; i++) &#123; for(j=0; j&lt;lin; j++) &#123; printf(" %c ", arr[i][j]); if(j &lt; lin-1) printf("|"); else printf("\n"); &#125; if (i &lt; row-1) &#123; for(j=0; j&lt;lin; j++) &#123; printf("---"); if(j &lt; lin-1) printf("|"); else printf("\n"); &#125; &#125; &#125; printf("\n");&#125; void player_go(char arr[][LIN], int row, int lin)//玩家走&#123; int i, j, input; while(1) &#123; printf("请你落子(1-9): \n"); //scanf_s("%d %d", &amp;i, &amp;j); scanf("%d",&amp;input); i = (input+2)/3; j = (input%3 == 0)? 3:input%3; if (i &gt;=1 &amp;&amp; i &lt;= row&amp;&amp;j &gt;=1 &amp;&amp; j &lt;= lin) &#123; if (arr[i - 1][j - 1] ==' ') &#123; arr[i - 1][j - 1] = 'X'; break; &#125; else &#123; printf("已经有子了！\n"); &#125; &#125; else &#123; printf("错误落子，请重新落子\n"); &#125; &#125; //system("cls");&#125; void pc_go(char arr[][LIN], int row, int lin, int nan)//电脑走 &#123; int i, j, count; int sig = 0; int i2 = 6, j2 = 6; int m = 0; int n = 0; count = 0; printf("电脑思考中"); Sleep(200); printf("."); Sleep(200); printf("."); Sleep(200); printf(".\n电脑落子：\n"); switch(nan) &#123; //难度1 case 1: do &#123; i = rand() % row; j = rand() % lin; if (arr[i][j] == ' ') &#123; arr[i][j] = 'O'; break; &#125; &#125; while (1); break; //难度二 case 2: count = 1; if(arr[1][1] == ' ') &#123; arr[1][1] = 'O'; goto done2; &#125;nan2: for(i=0; i&lt;row; i++) &#123; n = 0; m = 0; for(j=0; j&lt;lin; j++) &#123; m += arr[i][j];//行 n += arr[j][i];//列 &#125; if(m == 'O'*2 + ' ') &#123; for(j=0; j&lt;lin; j++) &#123; if(arr[i][j] == ' ') &#123; arr[i][j] = 'O'; goto done2; &#125; &#125; &#125; if(m == 'X'*2 + ' ') &#123; sig++; i2 = i; &#125; if(n == 'O'*2 + ' ') &#123; for(j=0; j&lt;row; j++) &#123; if(arr[j][i] == ' ') &#123; arr[j][i] = 'O'; goto done2; &#125; &#125; &#125; if(n == 'X'*2 + ' ') &#123; sig++; j2 = i; &#125; &#125;//这里确定电脑不能一步下赢，开始阻拦玩家 if(sig) &#123; if(i2 &lt; row) &#123; for(j=0; j&lt;lin; j++) &#123; if(arr[i2][j] == ' ') &#123; arr[i2][j] = 'O'; goto done2; &#125; &#125; &#125; else &#123; for(j=0; j&lt;row; j++) &#123; if(arr[j][j2] == ' ') &#123; arr[j][j2] = 'O'; goto done2; &#125; &#125; &#125; &#125;//行列判定over if(arr[0][0]+arr[1][1]+arr[2][2] == 'O'*2 + ' '||arr[0][0]+arr[1][1]+arr[2][2] == 'X'*2 + ' ') &#123; for(i=0; i&lt;lin; i++) &#123; if(arr[i][i] == ' ') &#123; arr[i][i] = 'O'; goto done2; &#125; &#125; &#125; if(arr[2][0]+arr[1][1]+arr[0][2] == 'O'*2 + ' '||arr[2][0]+arr[1][1]+arr[0][2] == 'X'*2 + ' ') &#123; for(j=0; j&lt;row; j++) &#123; if(arr[row-j-1][j] == ' ') &#123; arr[row-j-1][j] = 'O'; goto done2; &#125; &#125; &#125;//斜 do &#123; i = rand() % row; j = rand() % lin; if (arr[i][j] == ' ') &#123; arr[i][j] = 'O'; goto done2; &#125; &#125; while (1);done2: break; //难度三 case 3: if(arr[1][1] == ' ') &#123; arr[1][1] = 'O'; &#125; else &#123; for(i=0; i&lt;row; i++) &#123; for(j=0; j&lt;lin; j++) &#123; count += arr[i][j]; &#125; &#125; if((count == 'X'+ 8*' ') &amp;&amp; arr[1][1] == 'X') &#123; arr[0][0] = 'O'; &#125; else if((count == 'X'*2 + 'O'*1 + ' '*6) &amp;&amp; arr[1][1] == 'X' &amp;&amp; arr[2][2] == 'X') &#123; arr[0][2] = 'O'; &#125; else if((count == 'X'*2 + 'O'*1 + ' '*6) &amp;&amp; arr[1][1] == 'O' &amp;&amp; (arr[0][0] == 'X' &amp;&amp; arr[2][2] == 'X')||(arr[2][0] == 'X' &amp;&amp; arr[0][2] == 'X')) &#123; arr[0][1] = 'O'; &#125; else goto nan2; &#125; break; &#125; //system("cls");&#125; int is_full(char arr[][LIN], int row, int lin)//判断棋盘是否为满 &#123; int i=0, j=0; for (i=0; i&lt;row; i++) &#123; for (j=0; j&lt;lin; j++) &#123; if (arr[i][j] == ' ') return 0; &#125; &#125; return 1;&#125; char is_win(char arr[][LIN], int row, int lin)//判断输赢 &#123; int i = 0, j = 0; for (i=0; i&lt;row; i++) &#123; if ((arr[i][0] == arr[i][1])&amp;&amp;( arr[i][1] == arr[i][2] )&amp;&amp; arr[i][1] != ' ') //判断行 &#123; return arr[i][1]; &#125; &#125; for (j=0; j&lt;lin; j++) //判断列 &#123; if ((arr[0][j] == arr[1][j] ) &amp;&amp; ( arr[1][j] == arr[2][j]) &amp;&amp; arr[1][j] != ' ') &#123; return arr[1][j]; &#125; &#125; if ((arr[0][0] == arr[1][1] ) &amp;&amp; (arr[1][1] == arr[2][2]) &amp;&amp; arr[1][1] != ' ') //判断斜列 &#123; return arr[1][1]; &#125; else if( (arr[0][2] == arr[1][1]) &amp;&amp; ( arr[1][1] == arr[2][0]) &amp;&amp; arr[1][1] != ' ') &#123; return arr[1][1]; &#125; else if (is_full(arr,row,lin)) &#123; return 'f'; &#125; else return ' '; &#125; 我设定了三个难度，其中那个最高难度，我的设定是赢不了电脑的，不信的同学可以试试，如果你下赢了，请接受我的敬佩哦…..]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现扫雷游戏]]></title>
    <url>%2F2018%2F06%2F02%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[今天我们使用C语言简单实现一下经典游戏：扫雷在开始之前我们先看一下效果：接下来上代码： 头文件game.h12345678910111213141516171819202122232425#ifndef _GAME_H__ #define _GAME_H__ #define COL 10 #define ROW 10 #define COLS COL+2 #define ROWS ROW+2 #define clt CLK_TCK #define MAX_L 45#define MAX_C 30#include&lt;windows.h&gt; #include&lt;time.h&gt; #include&lt;stdio.h&gt;void game();void start_show();void init_mine(int mine[ROWS][COLS], int rows, int cols,int count); void init_show(char show[ROWS][COLS], int rows, int cols); void printmine(int mine[ROWS][COLS], int row, int col); void printshow(char show[ROWS][COLS], int row, int col); void jump_mine(int mine[ROWS][COLS], int x, int y, int row, int col);void clearmine(int mine[ROWS][COLS],char show[ROWS][COLS], int x, int y,int row,int col);int sweep_mine(int mine[ROWS][COLS], char show[ROWS][COLS], int row, int col, int count, int countsao); int is_win(char show[ROWS][COLS], int row, int col,int count);void menu(); int select_mode(); #endif 源文件game.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502#define _CRT_SECURE_NO_WARNINGS#include "Game.h" void game() &#123; unsigned int C1 = clock(); //char p[50]; int x = 0; int y = 0; int countsao = 0; int mine[ROWS][COLS] = &#123;0&#125;; char show[ROWS][COLS] = &#123;0&#125;; int count = 0; int win = 1; int C2; count = select_mode(); init_mine(mine, ROWS, COLS, count); init_show(show, ROWS, COLS); //sprintf((char *)p, "mode con cols=%d lines=%d", MAX_L, MAX_C); //system((const char*)p); while (win) &#123; system("cls"); printshow(show, ROW, COL); //printmine(mine, ROW, COL); countsao++; win = sweep_mine(mine, show, ROW, COL, count, countsao); if (x = is_win(show, ROW, COL, count)) &#123; system("cls"); C2 = clock(); printf("\n恭喜你排完了所有的雷!\t\t用时：%d秒\n",(C2-C1)/clt); break; &#125; &#125; //printshow(show, ROW, COL);//扫雷界面 printmine(mine, ROW, COL);//雷信息 if(!x) &#123; printf("\t\t****** * ******* ****** ******* * * ****** ****** **\n"); printf("\t\t* * * * * * * * * * * * * * **\n"); printf("\t\t* *** ***** * * * ****** * * * * ****** ****** **\n"); printf("\t\t* * * * * * * * * * * * * * * \n"); printf("\t\t****** * * * * ****** ******* * ****** * ** **\n"); &#125;&#125;void start_show()&#123; int i, j; printf("loading."); for(i=0; i&lt;5; i++) &#123; Sleep(200); printf("."); &#125; system("cls"); for(i=0; i&lt;30; i++) &#123; system("cls"); Sleep(1); for(j=0; j&lt;i; j++) &#123; printf("\n"); &#125; printf("************************************************************************************************************************"); &#125; for(; i&gt;0; i--) &#123; system("cls"); Sleep(1); for(j=0; j&lt;i; j++) &#123; printf("\n"); &#125; printf("************************************************************************************************************************"); &#125; system("cls");&#125;void menu() &#123; printf("\t\t\t\t 欢迎来到扫雷世界! \n"); printf("\n\n\t\t\t\t***********************************\n"); printf("\t\t\t\t*********** 1.开始 ************\n"); printf("\t\t\t\t***********************************\n"); printf("\t\t\t\t*********** 0.退出 ************\n"); printf("\t\t\t\t***********************************\n"); &#125; int select_mode() &#123; int num = 0; system("cls"); printf("\n\n\t\t\t\t**************************************\n"); printf("\t\t\t\t*1.简单 2.困难 3.大师*\n"); printf("\t\t\t\t**************************************\n"); while(1) &#123; printf("\t\t\t\t请输入选择&gt;"); scanf_s("%d", &amp;num); switch (num) &#123; case 1:return ROWS; case 2:return ROWS+ROWS/2; case 3:return ROW*3; case 99:return ROW*COL-2; case 100:return 3; default:printf("\t\t\t\t输入错误,请重新输入!\n"); &#125; &#125;&#125;void init_show(char show[ROWS][COLS], int rows, int cols) &#123; int i = 0; int j = 0; for (i = 0; i &lt; rows; i++) &#123; for (j = 0; j &lt; cols; j++) &#123; show[i][j] = '0'; &#125; &#125; &#125;void init_mine(int mine[ROWS][COLS],int rows,int cols,int count)//布雷&#123; int x = 0; int y = 0; int i = count; while (i) &#123; x = rand()%(rows -2)+1; y = rand()%(cols -2)+1; if (9 != mine[x][y]) &#123; mine[x][y] = 9; i--; if (9!=mine[x][y - 1])//周围雷数量 mine[x][y - 1]++; if (9!= mine[x][y + 1]) mine[x][y + 1]++; if (9!= mine[x - 1][y + 1]) mine[x - 1][y + 1]++; if (9 != mine[x - 1][y]) mine[x - 1][y]++; if (9 != mine[x - 1][y - 1]) mine[x - 1][y - 1]++; if (9 != mine[x + 1][y - 1]) mine[x + 1][y - 1]++; if (9 != mine[x + 1][y]) mine[x + 1][y]++; if (9 != mine[x + 1][y + 1]) mine[x + 1][y + 1]++; &#125; &#125;&#125;void printmine(int arr[ROWS][COLS], int row, int col)&#123; int i = 0; int j = 0; int k = 0; for(j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf(" %-2d|",i); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=1; i&lt;=row; i++) &#123; printf("| %-2d|",i); for (j=1; j&lt;=col; j++) &#123; if (9 == arr[i][j]) &#123; printf(" ●|"); &#125; else &#123; printf(" %-2d|", arr[i][j]); &#125; &#125; printf("\n"); for (j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); &#125; &#125; void printshow(char show[ROWS][COLS], int row, int col) &#123; int i = 0; int j = 0; for(j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf(" %-2d|",i); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=1; i&lt;=row; i++) &#123; printf("| %-2d|", i); for (j=1; j&lt;=col; j++) &#123; if ('0'== show[i][j]) &#123; printf(" ▇|"); &#125; else if(1 == show[i][j]) &#123; printf(" ◆|"); &#125; else &#123; printf(" %2c|", show[i][j]); &#125; &#125; printf("\n"); for (j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); &#125;&#125; void clearmine(int mine[ROWS][COLS],char show[ROWS][COLS], int x, int y,int row,int col)//递归判定 &#123; if (0 == mine[x][y]) &#123; show[x][y] = ' '; &#125; if (' ' != show[x - 1][y]) &#123; if (0 == mine[x - 1][y] &amp;&amp; x - 1 &gt;= 1) &#123; clearmine(mine, show, x-1, y, row, col); &#125; else &#123; show[x - 1][y] = '0' + mine[x - 1][y]; &#125; &#125; if (' ' != show[x + 1][y]) &#123; if (0 == mine[x + 1][y] &amp;&amp; x + 1 &lt;= row &amp;&amp; ' ' != show[x + 1][y]) &#123; clearmine(mine, show, x+1, y, row, col); &#125; else &#123; show[x + 1][y] = '0' + mine[x + 1][y]; &#125; &#125; if (' ' != show[x][y-1]) &#123; if (0 == mine[x][y - 1] &amp;&amp; y - 1 &gt;= 1 &amp;&amp; ' ' != show[x][y - 1]) &#123; clearmine(mine, show, x, y-1, row, col); &#125; else &#123; show[x][y - 1] = '0' + mine[x][y - 1]; &#125; &#125; if (' ' != show[x - 1][y-1]) &#123; if (0 == mine[x - 1][y - 1] &amp;&amp; x - 1 &gt;= 1 &amp;&amp; y - 1 &gt;= 1 &amp;&amp; ' ' != show[x - 1][y - 1]) &#123; clearmine(mine, show, x-1, y-1, row, col); &#125; else &#123; show[x - 1][y - 1] = '0' + mine[x - 1][y - 1]; &#125; &#125; if (' ' != show[x + 1][y-1]) &#123; if (0 == mine[x + 1][y - 1] &amp;&amp; x + 1 &lt;= row &amp;&amp; y - 1 &gt;= 1 &amp;&amp; ' ' != show[x + 1][y - 1]) &#123; clearmine(mine, show, x+1, y-1, row, col); &#125; else &#123; show[x + 1][y - 1] = '0' + mine[x + 1][y - 1]; &#125; &#125; if (' ' != show[x + 1][y+1]) &#123; if (0 == mine[x + 1][y + 1] &amp;&amp; x + 1 &lt;= row &amp;&amp; y + 1 &lt;= col &amp;&amp; ' ' != show[x + 1][y + 1]) &#123; clearmine(mine, show, x+1, y+1, row, col); &#125; else &#123; show[x + 1][y + 1] = '0' + mine[x + 1][y + 1]; &#125; &#125; if (' ' != show[x - 1][y +1]) &#123; if (0 == mine[x - 1][y + 1] &amp;&amp; x - 1 &gt;= 1 &amp;&amp; y + 1 &lt;= col &amp;&amp; ' ' != show[x - 1][y + 1]) &#123; clearmine(mine, show, x-1, y+1, row, col); &#125; else &#123; show[x - 1][y + 1] = '0' + mine[x - 1][y + 1]; &#125; &#125; if (' ' != show[x ][y + 1]) &#123; if (0 == mine[x][y + 1] &amp;&amp; y + 1 &lt;= col &amp;&amp; ' ' != show[x][y + 1]) &#123; clearmine(mine, show, x, y+1, row, col); &#125; else &#123; show[x][y + 1] = '0' + mine[x][y + 1]; &#125; &#125; &#125; int is_win(char show[ROWS][COLS],int row,int col,int count) &#123; int x = 0; int y = 0; int countmine = 0; for (x = 1; x &lt;= row; x++) &#123; for (y = 1; y &lt;= col; y++) &#123; if ('0' != show[x][y] ) countmine++; &#125; &#125; return (countmine &gt;= (row*col - count));&#125; void jump_mine(int mine[ROWS][COLS], int x, int y, int row, int col)&#123; int i = 0; int j = 0; while (9 == mine[x][y]) &#123; i = rand() % row + 1; j = rand() % col + 1; if(mine[i][j] - 9 ) &#123; mine[x][y] = 0; mine[i][j] = 9; if (9!=mine[x][y - 1] )//原位置周围雷数量 mine[x][y - 1]--; else mine[x][y]++; if (9!= mine[x][y + 1] ) mine[x][y + 1]--; else mine[x][y]++; if (9!= mine[x - 1][y + 1] ) mine[x - 1][y + 1]--; else mine[x][y]++; if (9 != mine[x - 1][y] ) mine[x - 1][y]--; else mine[x][y]++; if (9 != mine[x - 1][y - 1] ) mine[x - 1][y - 1]--; else mine[x][y]++; if (9 != mine[x + 1][y - 1] ) mine[x + 1][y - 1]--; else mine[x][y]++; if (9 != mine[x + 1][y] ) mine[x + 1][y]--; else mine[x][y]++; if (9 != mine[x + 1][y + 1] ) mine[x + 1][y + 1]--; else mine[x][y]++; if (9!=mine[i][j - 1])//新位置周围雷数量 mine[i][j - 1]++; if (9!= mine[i][j + 1]) mine[i][j + 1]++; if (9!= mine[i - 1][j + 1]) mine[i - 1][j + 1]++; if (9 != mine[i - 1][j]) mine[i - 1][j]++; if (9 != mine[i - 1][j - 1]) mine[i - 1][j - 1]++; if (9 != mine[i + 1][j - 1]) mine[i + 1][j - 1]++; if (9 != mine[i + 1][j]) mine[i + 1][j]++; if (9 != mine[i + 1][j + 1]) mine[i + 1][j + 1]++; &#125; &#125;&#125;int sweep_mine(int mine[ROWS][COLS],char show[ROWS][COLS],int row,int col,int count, int countsao) &#123; int x = 0, y = 0; char c; while (1) &#123; if(countsao &gt; 1) &#123; printf("是否进行标记？（y/n）"); scanf("%c",&amp;c); fflush(stdin); if('y' == c) &#123; printf("请输入标记坐标："); scanf("%d %d",&amp;x,&amp;y); fflush(stdin); show[x][y] = 1; system("cls"); printshow(show, ROW, COL); &#125; while('y' == c) &#123; printf("是否继续标记？（y/n）"); scanf("%c",&amp;c); fflush(stdin); if('y' == c) &#123; printf("请输入标记坐标："); scanf("%d %d",&amp;x,&amp;y); fflush(stdin); show[x][y] = 1; system("cls"); printshow(show, ROW, COL); &#125; &#125; &#125; printf("请输入排雷坐标&gt;"); scanf("%d %d", &amp;x, &amp;y); fflush(stdin); if (x&gt;=1&amp;&amp;x&lt;= row &amp;&amp;y&gt;=1&amp;&amp;y&lt;= col) &#123; if (9 == mine[x][y])//避开第一次就踩雷 &#123; if (1 == countsao) &#123; jump_mine(mine, x, y ,row, col); &#125; else &#123; system("cls"); printf("很遗憾，你挂了！\n"); return 0; &#125; &#125; if (0 == mine[x][y]) &#123; clearmine(mine, show, x, y, row, col); &#125; else &#123; show[x][y] = '0' + mine[x][y]; &#125; break; &#125; else &#123; printf("输入有误，请重新输入\n"); &#125; &#125; return 1; &#125; test.c123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_WARNINGS#include "Game.h" int main() &#123; //char p[50]; int input; srand((unsigned int)time(NULL)); start_show(); //sprintf((char *)p, "mode con cols=%d lines=%d", 100, 25); //system((const char*)p);res: //restart menu(); do &#123; printf("\t\t\t\t请选择&gt;"); scanf_s("%d", &amp;input); switch (input) &#123; case 0: break; case 1: game(); //sprintf((char *)p, "mode con cols=%d lines=%d", 100, 25); //system((const char*)p); system("pause"); system("cls"); goto res;//restart default: printf("\t\t\t\t输入错误！请重新输入：\n"); &#125; &#125; while (input); printf("\t\t\t\t"); return 0; &#125; 这样我们的扫雷就搞定了.]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现变色贪吃蛇]]></title>
    <url>%2F2018%2F05%2F30%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%89%B2%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[今天我们实现一下用C语言编写一个能变色、能调速、能调整地图大小、有成就系统、并且能用文件保存分数和成就的贪吃蛇游戏··工具：VS2013语言：C 我们先看一下效果： 头文件TCS.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#pragma once#ifndef __TCS_H__#define __TCS_H__#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#define Filename "tcs.52m"#define U 1#define D 2#define L 3#define R 4 //蛇的状态，U：上 ；D：下；L:左 R：右typedef struct SNAKE //蛇身的一个节点&#123; int x; int y; struct SNAKE * next;&#125;snake;typedef struct PLAYER&#123; char name[20]; int scores; char len[3]; int steps;&#125;player;typedef struct ACHEVE&#123; int step; int eat; int score;&#125;acheve;//声明全部函数//void Pos();void creatMap();void initsnake();int biteself();void createfood();void cantcrosswall();void snakemove();void pause();void gamecircle();void welcometogame();void gamestart();void endgame();void print();void menu();void inittop();void showtop();void sorttop();void startshow();void selectmap();void mapmenu();int topmenu();void loadtop();void savetop();void color();void showach();void loadach();void saveach();#endif//__TCS_H__ 源文件tcs.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718#define _CRT_SECURE_NO_WARNINGS#include "TCS.h"//全局变量//int level = 0; //关卡数，0表示无尽模式int score = 0, add = 10; //总得分与每次吃食物得分int status, sleeptime = 200; //每次运行的时间间隔snake *head, *food; //蛇头指针，食物指针snake *q; //遍历蛇的时候用到的指针int endgamestatus = 0; //游戏结束的情况，1：撞到墙；2：咬到自己；3：主动退出游戏。int run = 0; //判断游戏是否还能运行player top[61]; //排行榜int MAX_LL = 130; //游戏窗口长度int MAX_CC = 36; //游戏窗口高度int MAX_L = 92; //游戏区域长度int MAX_C = 35; //游戏区域高度int steps = 0; //计数步数int lenth = 4; //计数长度acheve ach; //成就数据//设置字体颜色void color(int x) &#123; if (!x) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), rand()%6+9); //只有一个参数，改变字体颜色 else SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), x);&#125;//设置光标位置void Pos(int x, int y)&#123; COORD pos; HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput, pos);&#125;//创建地图void creatMap()&#123; int i; for (i = 0; i&lt;MAX_L; i += 2)//打印上下边框 &#123; Pos(i, 0); color(0); printf("■"); Pos(i, MAX_C); color(0); printf("■"); Sleep(10); &#125; for (i = 1; i&lt;MAX_C; i++)//打印左右边框 &#123; Pos(0,i); color(0); printf("■"); Pos(MAX_L-2,i); color(0); printf("■"); Sleep(10); &#125;&#125;//初始化蛇身void initsnake()&#123; snake *tail; int i; tail=(snake*)malloc(sizeof(snake));//从蛇尾开始，头插法，以x,y设定开始的位置// tail-&gt;x=24; tail-&gt;y = 15; tail-&gt;next = NULL; for (i = 1; i &lt;= 4; i++) &#123; head = (snake*)malloc(sizeof(snake)); head-&gt;next = tail; head-&gt;x = 24 + 2 * i; head-&gt;y = 15; tail = head; &#125; Pos(tail-&gt;x, tail-&gt;y); printf("●"); tail = tail-&gt;next; while (tail != NULL)//从头到尾，输出蛇身 &#123; Pos(tail-&gt;x, tail-&gt;y); printf("■"); tail = tail-&gt;next; &#125;&#125;//判断是否咬到了自己int biteself()&#123; snake * self; self = head-&gt;next; while (self != NULL) &#123; if (self-&gt;x == head-&gt;x &amp;&amp; self-&gt;y == head-&gt;y) &#123; return 1; &#125; self = self-&gt;next; &#125; return 0;&#125;//随机出现食物void createfood()&#123; snake * food_1;res: food_1 = (snake*)malloc(sizeof(snake)); //保证其为偶数，使得食物能与蛇头对其 food_1-&gt;x = (rand() % (MAX_L-4) + 2)/2*2; food_1-&gt;y = rand() % (MAX_C-1) + 1; q = head; //food_1 = (snake*)malloc(sizeof(snake)); //while ((food_1-&gt;x % 2) != 0) //保证其为偶数，使得食物能与蛇头对其 //&#123; // food_1-&gt;x = rand() % (MAX_L - 4) + 2; //&#125; //food_1-&gt;y = rand() % (MAX_C - 3) + 1; //q = head; while (q != NULL) &#123; if (q-&gt;x == food_1-&gt;x &amp;&amp; q-&gt;y == food_1-&gt;y) //判断蛇身是否与食物重合 &#123; free(food_1); goto res; &#125; q = q-&gt;next; &#125; Pos(food_1-&gt;x, food_1-&gt;y); food = food_1; color(0); printf("★");&#125;//不能穿墙void cantcrosswall()&#123; if (head-&gt;x == 0 || head-&gt;x == MAX_L-2 || head-&gt;y == 0 || head-&gt;y == MAX_C) &#123; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgamestatus = 1; endgame(); &#125;&#125;//蛇前进,上U,下D,左L,右Rvoid snakemove()&#123; snake * nexthead; cantcrosswall(); if (run)return; nexthead = (snake*)malloc(sizeof(snake)); if (status == U) &#123; nexthead-&gt;x = head-&gt;x; nexthead-&gt;y = head-&gt;y - 1; &#125; else if (status == D) &#123; nexthead-&gt;x = head-&gt;x; nexthead-&gt;y = head-&gt;y + 1; &#125; else if (status == L) &#123; nexthead-&gt;x = head-&gt;x - 2; nexthead-&gt;y = head-&gt;y; &#125; else if (status == R) &#123; nexthead-&gt;x = head-&gt;x + 2; nexthead-&gt;y = head-&gt;y; &#125; if (nexthead-&gt;x == food-&gt;x &amp;&amp; nexthead-&gt;y == food-&gt;y)//如果下一个有食物// &#123; nexthead-&gt;next = head; head = nexthead; q = head; Pos(q-&gt;x, q-&gt;y); //color(0); printf("●"); Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); //color(0); printf("■"); while (q-&gt;next != NULL) &#123; q = q-&gt;next; &#125; Pos(q-&gt;x, q-&gt;y); //color(0); printf("■"); score = score + add; lenth++; createfood(); &#125; else //如果没有食物// &#123; nexthead-&gt;next = head; head = nexthead; q = head; Pos(q-&gt;x, q-&gt;y); //color(0); printf("●"); Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); //color(0); printf("■"); while (q-&gt;next-&gt;next != NULL) &#123; q = q-&gt;next; &#125; Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); printf(" "); free(q-&gt;next); q-&gt;next = NULL; &#125; steps++; if (biteself() == 1) //判断是否会咬到自己 &#123; endgamestatus = 2; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgame(); &#125; if (run)return;&#125;//暂停void pause()&#123; while (1) &#123; Sleep(300); if (GetAsyncKeyState(VK_SPACE)) &#123; break; &#125; &#125;&#125;//控制游戏void gamecircle()&#123; Pos(MAX_L+4, 15); color(0); printf("不能穿墙，不能咬到自己\n"); Pos(MAX_L + 4, 16); color(0); printf("用↑.↓.←.→分别控制蛇的移动."); Pos(MAX_L + 4, 17); color(0); printf("F1 为加速，F2 为减速\n"); Pos(MAX_L + 4, 18); color(0); printf("ESC ：退出游戏.Space：暂停游戏."); Pos(MAX_L + 4, 20); color(0); printf("\n"); status = D; while (1) &#123; Pos(MAX_L + 6, 10); printf("得分：%d ", score); Pos(MAX_L + 6, 11); printf("每个食物得分：%d分", add); if (GetAsyncKeyState(VK_UP) &amp;&amp; status != D) &#123; status = U; &#125; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; status != U) &#123; status = D; &#125; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; status != R) &#123; status = L; &#125; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; status != L) &#123; status = R; &#125; else if (GetAsyncKeyState(VK_SPACE)) &#123; pause(); &#125; else if (GetAsyncKeyState(VK_ESCAPE)) &#123; endgamestatus = 3; break; &#125; else if (GetAsyncKeyState(VK_F1)) &#123; if (sleeptime &gt;= 50) &#123; sleeptime = sleeptime - 30; add = add + 2; if (sleeptime == 320) &#123; add = 2;//防止减到1之后再加回来有错 &#125; &#125; &#125; else if (GetAsyncKeyState(VK_F2)) &#123; if (sleeptime&lt;350) &#123; sleeptime = sleeptime + 30; add = add - 2; if (sleeptime == 350) &#123; add = 1; //保证最低分为1 &#125; &#125; &#125; Sleep(sleeptime); snakemove(); if (run)return; &#125;&#125;//简介界面void welcometogame()&#123; system("cls"); //int i = 7; //color(13); //Pos(6, 7); //printf("■■■■ ★"); //for (i = 8; i &lt; 20; i++) //&#123; // Pos(6, i); // printf("■"); // Pos(MAX_L + 6, i); // printf("■"); //&#125; //Pos(6, i); //for (i = 6; i &lt;= MAX_L + 6; i+=2) // printf("■"); print(); Pos(MAX_L/2-12, 7); color(15); printf("用"); color(10); printf("↑ ↓ ← →"); color(15); printf("分别控制蛇的移动"); Pos(MAX_L / 2 - 12, 9); color(12); printf("F1 "); color(15); printf("为加速"); color(12); printf(" F2 "); color(15); printf("为减速\n"); Pos(MAX_L / 2 - 12, 11); color(15); printf("可以多点几下"); color(11); printf(" F1 "); color(15); printf("或者"); color(11); printf(" F2 "); color(15); printf("切换到你认为最适合你的难度\n"); Pos(MAX_L/2-12, 13); printf("加速将能得到"); color(13); printf("更高的分数。"); Pos(MAX_L / 2 - 12, 15); color(14); printf("开始进行愉快的贪吃蛇游戏吧 ^ _ ^\n"); Pos(MAX_L / 2-12, 25); color(15); system("pause"); system("cls");&#125;//结束游戏void endgame()&#123; char c; system("cls"); print(); Pos(MAX_L/2, 12); if (endgamestatus == 1) &#123; color(12); printf("很遗憾，你撞到了墙。游戏结束."); &#125; else if (endgamestatus == 2) &#123; color(12); printf("很遗憾，你咬到了自己。游戏结束."); &#125; else if (endgamestatus == 3) &#123; color(12); printf("你已经结束了游戏。"); &#125; Pos(MAX_L / 2, 13); printf("你的得分是:%d,在本局游戏中你一共走了:%d格", score,steps); if (score &gt;= top[(MAX_LL-70)/30*20-1].scores) &#123; Pos(MAX_L / 2, 14); system("pause"); top[60].scores = score; sprintf(top[60].len, "%d", lenth); top[60].steps = steps; Pos(MAX_L / 2, 14); printf("恭喜你进入排行榜！！！！"); Pos(MAX_L / 2, 15); while ((c = getchar()) != '\n' &amp;&amp; c != EOF); printf("是否留下你的名字？(y/n)"); scanf("%c", &amp;c); if ('y' == c || 'Y' == c) &#123; Pos(MAX_L / 2, 16); printf("请输入你的昵称:&gt;"); scanf("%s", top[60].name); sorttop(); Pos(MAX_L / 2, 17); printf("排行榜已更新..."); &#125; else &#123; strcpy(top[60].name, "noname"); sorttop(); Pos(MAX_L / 2, 17); printf("排行榜已更新..."); &#125; &#125; ach.step += steps; ach.score += score; ach.eat += (lenth - 4); saveach(); run = 1; Pos(MAX_L / 2, 18); system("pause");&#125;//游戏初始化void gamestart()&#123; char p[50]; sleeptime = 200; score = 0; add = 10; steps = 0; lenth = 4; system("cls"); run = 0; sprintf((char * )p, "mode con cols=%d lines=%d", MAX_LL, MAX_CC); system((const char*)p); creatMap(); initsnake(); createfood();&#125;//选择地图界面void mapmenu()&#123; print(); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 5); printf("■■■■■■■■ ★ ■■■■■■■■"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 5); printf("1.地图：小"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 3); printf("2.地图：中"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 1); printf("3.地图：大"); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2+1); printf("选择你的地图大小:&gt;");&#125;//选择地图void selectmap()&#123; int input; do &#123; system("cls"); mapmenu(); fflush(stdin); scanf("%d", &amp;input); switch (input) &#123; case 1: MAX_LL = 100; MAX_CC = 30; MAX_L = 64; MAX_C = 29; return; break; case 2: MAX_LL = 130; MAX_CC = 36; MAX_L = 92; MAX_C = 35; return; break; case 3: MAX_LL = 160; MAX_CC = 45; MAX_L = 120; MAX_C = 44; return; break; default: Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 2); printf("输入有误！"); Sleep(500); break; &#125; &#125; while (1);&#125;//打印边框void print()&#123; int i; for (i = 0; i&lt;MAX_LL; i += 2)//打印上下边框 &#123; Pos(i, 0); color(0); printf("■"); Pos(i, MAX_CC - 1); color(0); printf("■"); &#125; for (i = 1; i&lt;MAX_CC; i++)//打印左右边框 &#123; Pos(0, i); color(0); printf("■"); Pos(MAX_LL - 2, i); color(0); printf("■"); &#125;&#125;//主菜单void menu()&#123; print(); Pos((MAX_LL-78)/2-1, MAX_CC / 5); printf("■■■■■■■■ ★ ■■■■■■■■"); Pos(MAX_LL / 2-6, MAX_CC / 2-7); printf("1.开始游戏"); Pos(MAX_LL / 2-6, MAX_CC / 2-5); printf("2.游戏简介"); Pos(MAX_LL / 2 - 6, MAX_CC / 2-3); printf("3.排行榜"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 1); printf("4.成就"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 + 1); printf("0.退出游戏");&#125;//游戏流程控制void game()&#123; //system("color 3f"); selectmap(); gamestart(); gamecircle(); system("cls");&#125;//开始动画void startshow()&#123; int i = 0; int t; Pos((MAX_LL - 56) / 2-6, (MAX_CC - 10) / 2 + i++); Sleep(5); color(0); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(55); printf("██ █ █ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("██ █ █ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(35); printf("██ ██████████ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(25); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(15); printf("██ ███◣ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(15); printf("██ ██◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(25); printf("██ ██ ◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(35); printf("██ ██ ◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("█████████ ██ ◥█◣ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(55); printf("█████████ ██ ◥█◣ ████████"); Sleep(500); Pos( MAX_LL/ 2+10, (MAX_CC - 10) / 2 + i+3); color(13); printf("★"); Pos(0, (MAX_CC - 10) / 2 +i+3); t = (MAX_CC - 10) / 2 + i + 3; color(14); for (i = 0; i &lt; MAX_LL; i += 2) &#123; Pos(i, t); printf("■"); if (i&gt;=16) &#123; Pos(i-16, t); printf(" "); &#125; if (i &gt;= (MAX_LL / 2 + 8) &amp;&amp; i &lt;= (MAX_LL / 2 + 10)) &#123; color(13); &#125; Sleep(15); &#125; //system("pause");&#125;//测试食物是否会生成在地图外void test()&#123; int x = 0; int y = 0; system("cls"); creatMap(); color(15); Pos(MAX_L + 4, 15); printf("按下Esc结束测试状态"); while(1) //保证其为偶数，使得食物能与蛇头对其 &#123; x = (rand() % (MAX_L - 4) + 2)/2*2; y = rand() % (MAX_C - 1) + 1; Pos(x,y); color(0); printf("█"); if (GetAsyncKeyState(VK_ESCAPE)) &#123; break; &#125; &#125;&#125;//主函数int main()&#123; int input; char p[50]; color(0); srand((unsigned)time(NULL)); inittop(); loadach(); sprintf((char * )p, "mode con cols=%d lines=%d", MAX_LL, MAX_CC); system((const char*)p); startshow(); do&#123; system("cls"); menu(); Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 3); printf("请选择:&gt;"); //printf("%d", sizeof(player)); fflush(stdin); scanf("%d", &amp;input); switch (input) &#123; case 5: test(); break; case 4: showach(); break; case 3: showtop(); break; case 2: welcometogame(); break; case 1: game(); break; case 0: break; default: Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 4); printf("输入有误请重新输入！\n"); Sleep(500); break; &#125; &#125; while (input); Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 4); printf("感谢你的游玩，再见！"); Sleep(800); return 0;&#125; top.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#define _CRT_SECURE_NO_WARNINGS#include "TCS.h"//全局变量//extern int level ; extern int score , add ; extern int status, sleeptime ; extern snake *head, *food; extern snake *q; extern int endgamestatus ; extern int run ; extern player top[61]; extern int MAX_LL ; extern int MAX_CC ; extern int MAX_L ; extern int MAX_C ; //初始化排行void inittop()&#123; int j = 0; for (j = 0; j &lt; 3; j++) &#123; int i = 0; top[20 * j + i].scores = 999; sprintf(top[20 * j + i].len, "%d", 56); top[20 * j + i].steps = 1658; for (i = 1; i &lt; 20; i++) &#123; top[20 * j + i].scores = 480 - 20 * i; sprintf(top[20 * j + i].len ,"%d", 48 - 2 * i); top[20 * j + i].steps = 999 - 20 * i; &#125; for (i = 0; i &lt; 21; i++) &#123; strcpy(top[20 * j + i].name, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"); strcpy(top[20 * j + i].name, "LRS"); &#125; &#125; top[60].scores = 0; loadtop();&#125;//排行菜单int topmenu()&#123; int input; do &#123; system("cls"); mapmenu(); fflush(stdin); scanf("%d", &amp;input); switch (input) &#123; case 1: return 0; break; case 2: return 1; break; case 3: return 2; break; default: Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 2); printf("输入有误！"); Sleep(500); break; &#125; &#125; while (1);&#125;//显示排行void showtop()&#123; int i = 0; int j = topmenu(); system("cls"); print(); Pos(MAX_LL / 5, i + 3); color(15); printf("%-5s\t%-20s%-6s\t%-3s\t%-8s", "名次", "昵称", "分数","体长","路程"); for (i = 0; i &lt; 20; i++) &#123; Pos(MAX_LL / 5, i + 4); if (i &lt; 20)color(15); if (i &lt; 10)color(10); if (i &lt; 5)color(9); if (i &lt; 3)color(13); if (i &lt; 2)color(14); if (i &lt; 1)color(12); printf("%-5d\t%-20s%-6d\t%-3s\t%-8d", i + 1, top[j * 20 + i].name, top[j * 20 + i].scores, top[j * 20 + i].len, top[j * 20 + i].steps); &#125; Pos(MAX_LL / 5, i + 6); system("pause"); system("cls");&#125;//排序排行void sorttop()&#123; int i = 0; int j = 0; int m = (MAX_LL - 100) / 30 * 20; for (i = 0; i &lt; 20; i++) &#123; if (top[60].scores &gt;= top[m + i].scores) &#123; for (j = 19 + m; j &gt;(i + m); j--) &#123; top[j] = top[j - 1]; &#125; top[i + m] = top[60]; break; &#125; &#125; savetop();&#125;//加载void loadtop()&#123; int ret = 0; FILE* c = fopen(Filename,"a+"); FILE* load = fopen(Filename, "rb"); fclose(c); c = NULL; if (load == NULL) &#123; perror("load top"); exit(1); &#125; while(fread(&amp;top[ret++], sizeof(player), 1, load)); //printf("%d", ret); //system("pause"); fclose(load); load = NULL;&#125;//保存void savetop()&#123; int i = 0; FILE* save = fopen(Filename, "w"); if (save == NULL) &#123; perror("save top"); exit(1); &#125; fwrite(&amp;top[0], sizeof(player), 60, save); fclose(save); save = NULL;&#125; ach.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#define _CRT_SECURE_NO_WARNINGS#include "TCS.h"extern acheve ach;extern int MAX_LL;struct achname&#123; char name[20]; int num;&#125;name[9] = &#123; &#123; "旅行蛇",10000 &#125;,&#123; "环游中国",100000 &#125; ,&#123;"遨游太空",1000000 &#125;,&#123;"大胃王", 100&#125;,&#123; "上古腐鲸蛇",10000 &#125;,&#123; "宇宙级大蛇", 100000&#125;,&#123; "得分高手",10000 &#125;,&#123; "得分大师",100000 &#125;,&#123;"得分宗师",1000000 &#125;&#125;;//展示成就void showach()&#123; int i = 0; system("cls"); print(); Pos(MAX_LL / 5, i + 3); color(15); printf("%-20s\t %-12s\t", "成就", "状态"); for (i = 0; i &lt; 9; i++) &#123; color(i % 3 + 10);//判断颜色 Pos(MAX_LL / 5, 2 * (i + 1) + 3); printf("%-20s\t", name[i].name); switch (i / 3)//判断类型 &#123; case 0: if (ach.step &gt;= name[i].num) &#123; printf("%10d/%-9d", name[i].num, name[i].num); &#125; else printf("%10d/%-9d", ach.step, name[i].num); break; case 1: if (ach.eat &gt;= name[i].num) &#123; printf("%10d/%-9d", name[i].num, name[i].num); &#125; else printf("%10d/%-9d", ach.eat, name[i].num); break; case 2: if (ach.score &gt;= name[i].num) &#123; printf("%10d/%-9d", name[i].num, name[i].num); &#125; else printf("%10d/%-9d", ach.score, name[i].num); break; &#125; &#125; Pos(MAX_LL / 5, 2 * (i + 1) + 5); printf("走过的总步数:%d步\t吃过的食物总数:%d个\t得到的总分数:%d分" ,ach.step, ach.eat, ach.score); Pos(MAX_LL / 5, 2 * (i + 1) + 7); system("pause");&#125;//加载void loadach()&#123; FILE* c = fopen("ach.52m","a+");//如果没有就新建 FILE* load = fopen("ach.52m", "rb"); fclose(c); c = NULL; if (load == NULL) &#123; perror("load ach"); exit(1); &#125; ach.eat = 0; ach.score = 0; ach.step = 0; fread(&amp;ach, sizeof(acheve), 1, load); fclose(load); load = NULL;&#125;//保存void saveach()&#123; FILE* save = fopen("ach.52m", "wb"); if (save == NULL) &#123; perror("save ach"); exit(1); &#125; fwrite(&amp;ach, sizeof(acheve), 1, save); fclose(save); save = NULL;&#125; 这样我们的贪吃蛇游戏就做好了… 因为本人比较懒，所以用了很多全局变量 &gt; _ &lt; 怎么样？是不是相当…花里胡哨呢？]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建动态通讯录]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[今天我们用自定义类型和动态内存管理实现一个通讯录程序，能够实现以下要求: 添加联系人信息 删除指定联系人信息 查找指定联系人信息 修改指定联系人信息 显示所有联系人信息 清空所有联系人 以名字排序所有联系人 头文件 Contact.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef __TEST_H__#define __TEST_H__#pragma once //2.实现一个通讯录；//通讯录可以用来存储1000个人的信息，每个人的信息包括://姓名、性别、年龄、电话、住址////提供方法：//1. 添加联系人信息//2. 删除指定联系人信息//3. 查找指定联系人信息//4. 修改指定联系人信息//5. 显示所有联系人信息//6. 清空所有联系人//7. 以名字排序所有联系人#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt;#include &lt;windows.h&gt;#include&lt;time.h&gt;#define Filename "Contact.txt"typedef struct PERSON&#123; char Name[20]; char Sex[5]; int Age; char Tel[20]; char Address[50];&#125;Person;typedef struct BOOK&#123; int max; //当前上限 int count; //当前已存储人数 Person* Data;&#125;Book;void Initbook(Book* people);void Add_person(Book * people);void show_person(Book* people);void Del_person(Book* people);void Find_person(Book* people);void Change_person(Book* people);void BubbleSort_person(Book* people);void Req_mem(Book* people);void Desbook(Book* people);#endif //__TEST_H__ 源文件 Test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357#include "test.h"//仅查找static int find_person(Book* people)&#123; int i = 0; assert(people); char name[20]; printf("\t\t 输入姓名："); scanf("%s", name); for (; i&lt;people-&gt;count; i++) &#123; if (strcmp(people-&gt;Data[i].Name, name) == 0) &#123; return i; &#125; &#125; //printf("没有找到该联系人！\n"); //system("pause"); return -1;&#125;//加载文件void load(Book*people)&#123; FILE* op = fopen(Filename, "a+"); FILE* load = fopen(Filename,"r"); fclose(op); if (load == NULL) &#123; perror("load file,please try again"); exit(1); &#125; while (fread(&amp;(people-&gt;Data[people-&gt;count]), sizeof(Person), 1, load)) &#123; people-&gt;count++; Req_mem(people); &#125; fclose(load); load = NULL;&#125;//保存文件void save(Book*people)&#123; int i = 0; FILE* save = fopen(Filename,"w"); if (save == NULL) &#123; perror("save file"); exit(1); &#125; while (i&lt;people-&gt;count) &#123; fwrite(&amp;(people-&gt;Data[i]), sizeof(Person), 1, save); i++; &#125; //fwrite(people-&gt;Data, sizeof(Person), (size_t)people-&gt;count, save); fclose(save); save = NULL;&#125;//初始化 void Initbook(Book* people)&#123; (people)-&gt;Data = (Person*)malloc(2*sizeof(Person)); (people)-&gt;count = 0; (people)-&gt;max = 2; load(people);&#125;//清空void Desbook(Book* people)&#123; free(people-&gt;Data); people-&gt;Data = NULL; people-&gt;max = 0; people-&gt;count = 0; save(people); printf("\t\t 清空完毕！\n"); Sleep(300);&#125;//打印void show_person(Book* people)&#123; int i = 0; if (people == NULL) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; printf("\t\t |%-15s\t|%-5s\t|%-5s\t|%-15s\t|%-20s\n", "姓名", "性别", "年龄", "电话", "地址"); for (; i&lt;=people-&gt;count-1; ++i) &#123; printf("\t\t |%-15s\t", people-&gt;Data[i].Name); printf("|%-5s\t", people-&gt;Data[i].Sex); printf("|%-5d\t", people-&gt;Data[i].Age); printf("|%-15s\t", people-&gt;Data[i].Tel); printf("|%-20s\n", people-&gt;Data[i].Address); &#125; printf("\n\t\t "); system("pause");&#125;//申请内存void Req_mem(Book *people)&#123; Person* p; if (people-&gt;count &lt; people-&gt;max - 1)return; p = (Person*)realloc((people)-&gt;Data,((people)-&gt;max+=5)*sizeof(Person)); if (p != NULL) &#123; (people)-&gt;Data = p; return; &#125; else &#123; perror("realloc"); exit(EXIT_FAILURE); &#125;&#125;//增加成员 void Add_person(Book *people)&#123; int i = 0; assert(people); if ((people)-&gt;count == 1000) &#123; printf("\t\t 通讯录已满！\n"); return; &#125; Req_mem(people); printf("\t\t 请输入姓名:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Name); printf("\t\t 请输入性别:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Sex); printf("\t\t 请输入年龄:&gt;"); scanf("%d", &amp;((people)-&gt;Data[(people)-&gt;count]).Age); printf("\t\t 请输入联系方式:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Tel); for (; i&lt;(people)-&gt;count; ++i) &#123; if (strcmp((people)-&gt;Data[i].Tel, (people)-&gt;Data[(people)-&gt;count].Tel) == 0) &#123; printf("\t\t 联系人已存在！\n\t\t "); system("pause"); return; &#125; &#125; printf("\t\t 请输入住址:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Address); printf("\t\t 增加成功！\n"); Sleep(300); (people)-&gt;count++; //printf("count = %d\n", (*people)-&gt;count);&#125;//删除成员 void Del_person(Book* people)&#123; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; int ret = find_person(people); if (ret != -1) &#123; int i = ret; for (; i&lt;people-&gt;count-1; ++i) &#123; people-&gt;Data[i] = people-&gt;Data[i + 1]; &#125; people-&gt;count--; &#125; else &#123; printf("\t\t 没有该成员！\n"); system("pause"); &#125;&#125;//查找成员 void Find_person(Book* people)&#123; int i = 0; char name[20]; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; assert(people); printf("\t\t 输入姓名："); scanf("%s", name); for (; i&lt;people-&gt;count; ++i) &#123; if (strcmp(people-&gt;Data[i].Name, name) == 0) &#123; printf("\t\t Name:%s\n\t\t Sex:%s\n\t\t Age:%d\n\t\t Tel:%s\n\t\t Add:%s\n\t\t ", people-&gt;Data[i].Name, people-&gt;Data[i].Sex, people-&gt;Data[i].Age, people-&gt;Data[i].Tel, people-&gt;Data[i].Address); //printf("编号为 %d\n", i); system("pause"); return; &#125; &#125; printf("\t\t 没有找到该联系人！\n\t\t "); system("pause"); return ;&#125;//修改成员 void Change_person(Book* people)&#123; assert(people); int ret = find_person(people); if (ret != -1) &#123; printf("\t\t Name-&gt;:"); scanf("%s", people-&gt;Data[ret].Name); printf("\t\t Sex-&gt;:"); scanf("%s", people-&gt;Data[ret].Sex); printf("\t\t Age-&gt;:"); scanf("%d", &amp;(people-&gt;Data[ret]).Age); printf("\t\t Tel-&gt;:"); scanf("%s", people-&gt;Data[ret].Tel); printf("\t\t Add-&gt;:"); scanf("%s", people-&gt;Data[ret].Address); &#125; else &#123; printf("\t\t 没有该成员！\n"); system("pause"); return; &#125;&#125;//排序void BubbleSort_person(Book* people)&#123; if (people == NULL) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; int i = 0; for (; i&lt;people-&gt;count - 1; ++i) &#123; int j = 0; for (; j&lt;people-&gt;count - 1 - i; ++j) &#123; if (strcmp(people-&gt;Data[j].Name, people-&gt;Data[j + 1].Name) &gt; 0) &#123; Person tmp = people-&gt;Data[j]; people-&gt;Data[j] = people-&gt;Data[j + 1]; people-&gt;Data[j+1] = tmp; &#125; &#125; &#125; show_person(people);&#125;void color() //自定义函根据参数改变颜色 &#123; //static int x = 9; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), rand()%7+9); //只有一个参数，改变字体颜色 //if (x == 16) // x = 9;&#125;//static void change_color()//&#123;// static int i = 0;// char *str[20];// sprintf((char*)str, "color %x%x",0,15 - i);// system((const char*)str);// i++;// if (15 == i)// i = 0;//&#125;void menu()&#123; system("cls"); printf("\t\t ******************************通讯录管理系统*****************************\n\n"); color(); printf("\t\t **************1.添加联系人**********************2.删除联系人*************\n\n"); color(); printf("\t\t **************3.查找联系人**********************4.修改联系人*************\n\n"); color(); printf("\t\t **************5.显示联系人**********************6.清空联系人*************\n\n"); color(); printf("\t\t **************7.排序联系人**********************0.退出此程序*************\n\n"); color(); printf("\t\t *************************************************************************\n\n");&#125;int main()&#123; srand((size_t)time(NULL)); Book people; Initbook(&amp;people); while (1) &#123; //change_color(); menu(); int n = 0; printf("\t\t 请选择:&gt; "); scanf("%d", &amp;n); switch (n) &#123; case 1: Add_person(&amp;people); break; case 2: Del_person(&amp;people); break; case 3: Find_person(&amp;people); break; case 4: Change_person(&amp;people); break; case 5: show_person(&amp;people); break; case 6: Desbook(&amp;people); Initbook(&amp;people); break; case 7: BubbleSort_person(&amp;people); break; case 0: save(&amp;people); free((&amp;people)-&gt;Data); color(); printf("\t\t 感谢您的使用，再见！"); Sleep(800); exit(0); default: &#123; printf("\t\t input error!\n\t\t "); system("pause"); break; &#125; &#125; &#125; return 0;&#125; 这个通讯录我加入了一点花里胡哨的元素：每次操作完毕都会使背景变色，你可以试试哦~~修订信息：于2018.5.31加入文件保存功能。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于自定义类型]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、结构体类型的创建 1.结构体是一些值的集合，这些值称为成员变量。 2.结构体内的成员可以是不同类型的变量，也可以是标量，数组，指针甚至是其他的结构体。 3.结构体的创建： 例图： 4.结构体内部成员的访问：（1）.结构体变量访问成员(结构变量的成员是通过点操作符(.)访问的.点操作符接受两个操作数.如果s是结构体的具体名称，age是其内部成员，则s.age就可以访问)。（2）结构体访问指向变量的成员（定义一个指向该结构体的结构体类型的指针ps，如果age是该结构体的内部成员，则(*s).age或者ps-&gt;age就可以访问）。 5.结构的自引用：在结构体中可以包含该结构体本身的成员，具体的自引用如下例： 二、结构体的初始化 1. 123456struct Stu &#123; char name[10]; int age; &#125;; struct Stu s=&#123;"lisi",22&#125;;//初始化 2. 1234567struct Node &#123; int data; struct Stu p; struct Node* next; &#125;n=&#123;10,&#123;"wangwu",21&#125;,NULL&#125;;//结构体嵌套初始化 struct Node w=&#123;20,&#123;"liwu",23&#125;,NULL&#125;;//结构体嵌套初始化 三、结构体内存对齐 1.结构体的对齐原则： （1）第一个成员在与结构体变量偏移量为0的地址处。 （2）其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数=编译器默认的一个对齐数与该成员的大小的较小值。VS中默认的值为8， Linux中默认的值为4 （3）结构体总大小为最大对齐数（每个成员变量除了第一个成员都有一个对齐数）的整数倍。 （4）如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍。 总体来说：结构体的内存对齐是拿空间换时间的做法，除此，对于结构体传参的问题，要传结构体的地址（函数传参的时候，参数是需要压栈的，如果传递一个结构体对象时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降）。 四、位段 1.位段的声明和结构是相似的，有两个不同（一、位段的成员必须是int ,unsigned int，char.二，位段的成员名后边有一个冒号和一个数字）如： 12345struct A&#123; int _a:2; int _b:5;&#125;; 2.位段的内存分配 （1）位段的空间上是按照需要以4个字节（int）或者1个字节（char）的方式来开辟的。 （2）位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。 总体来说，跟结构相比，位段可以达到同样的效果，但是可以很好的节约空间，但是有跨平台的问题存在。 五、枚举枚举顾名思义就是一一列举。 1.枚举类型的定义 12345678910enum Day &#123; Mon, Tues, Wed, Thur, Fri, Sat, Sun &#125;; {}中的内容是枚举类型的可能取值，也叫枚举常量。这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值的。如 123456enum color &#123; RED=1, GREEN=2, BLUE=4 &#125;; 六、联合 1.联合类型的定义 联合类型定义的变量包含一系列的成员，特征是这些成员公用同一块空间（联合也称为共用体）。比如： 12345678//联合类型的声明 union Un &#123; char c; int i; &#125;; //联合变量的定义 union Un un; 2.联合的特点联合的成员是共用同一块内存空间的，这样一个联合变量的大小至少是最大成员的大小。 3.联合大小的计算 （1）联合的大小至少是最大成员的大小。 （2）当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>自定义类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next博客进阶攻略]]></title>
    <url>%2F2018%2F05%2F22%2Fhexo-next%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[今天我将在Tim讲解完使用Github+hexo+next初步搭建自己的博客后继续讲解如何美化我们的博客，或者增加实用的（或者花里胡哨的）功能： 什么？你没看Tim的搭建攻略？没事，传送门在此：https://zouchanglin.github.io/2018/05/08/2018050801/ 搭建前先说两句 再看这篇攻略之前确保你搭建好了自己的博客并且能正常使用 最好使用next主题，否则部分功能可能不能正常使用 不要作出改动后忘了保存 不要保存改动之后立即hexo d查看效果，Github服务器离我们远得很，会有延迟，建议使用hexo s在本地预览效果 在进行攻略前最好备份自己的博客，因为代码中少一个符号都可能导致你的博客界面变成空白！！！！ 一定要看上面几句话！！！！ 功能列表 增加用户头像 增加文章字数统计与估计阅读时长和统计站点总字数 实现分享功能 实现博客内点击事件 实现显示访客数量 实现单篇文章统计访问数 实现评论功能 添加Github导航条 实现统计站点运行时间 预览前面所有的效果：http://lrsand52m.top 增加用户头像 在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/img/ 目录下） 比如我的头像图片文件名是：LRS.png 那么我把这个文件放进/img文件夹 然后在博客根目录下_config.yml里加上下面的代码： 12avatar: /img/LRS.png#上面是头像代码，把LRS.png改成你自己的头像文件名即可 最后打开git bash，输入hexo g，然后hexo s在本地服务器查看效果吧~~~ 增加文章字数统计与估计阅读时长和统计站点总字数 我们在实现这个功能前需要安装wordcount插件: 在git bash输入下面的代码即可 1npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： （查看node版本：node -v） 1npm install hexo-wordcount@2 --save NexT 主题默认已经集成了文章【字数统计】、【阅读时长】，【站点总字数】统计功能，如果我们需要使用，只需要在主题配置文件/next目录下的 _config.yml 中打开 wordcount 统计功能即可。如下所示： 你可以开启你自己想要开启的，下面表示全开 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计，如不需要此功能就把前面的true改为false，下同理 min2read: true # 单篇 阅读时长 totalcount: true # 网站 字数统计 separated_meta: true 改动之后我们还要加上说明否则站点的显示只有数字没有单位，所以我们要打开这个文件：/next/layout/_macro/post.swig ,找到下面的代码 123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt; 将它改为 123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 同理，我们修改【阅读时长】，修改后如下： 123&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 总字数统计也同理— — 修改完成后，重新执行启动服务预览就可以了。修改后，效果如下图所示： 感觉如何？ ​ 增加分享功能 关于分享我首先是找到了使用shareSDK的分享功能，最后在实践的过程中发现它添加时步骤比较多，添加完成后效果比较丑（就是一个长条的浅蓝色按钮），而且点击后想要退出分享比较麻烦（它的取消按钮实在太难找了，它在页面最下方的位置，呈现浅灰色，这个设计太反人类了，决定放弃它了）。 在next主题的官方的文档中发现它自身集成了百度分享的功能，所以决定采用百度了。 打开/next目录下的 _config.yml找到下面的代码： 1234567# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare: #type: buttonbaidushare: true 如果没找到也别慌，自己写这么一段就好 把它改成： 12345678910#Sharesharesdk: trueshareSDKappkey: 25ec71ed74ff0# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: type: slide baidushare: true 保存后再hexo g加hexo s在本地看看效果吧~~大概长这样： 实现博客内点击事件 这个功能很花里胡哨，具体看图： 实现之后在你的博客里每点击一次就会生成颜色各异的爱心 要实现点击出现桃心效果，需要在/themes/next/source/js/src里面新建一个love.js文件，在里面粘贴下面的代码：(代码有点乱，但是不影响) 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug），引用love.js ，就是在文档末尾输入一行代码：（就是/body&gt;和/html&gt;的下面） 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 大功告成！保存后再hexo g加hexo s在本地看看效果吧~~ 实现显示访客数量 打开\themes\next\layout_partials\footer.swig文件,在类copyright前加上红箭头指向的这句代码： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 实现单篇文章统计访问数 本段介绍如何实现通过leanCloud统计您网站的文章阅读量，并介绍一些基本实现方法。 值得庆幸的是Next主题默认就支持leanCloud的相关设置，你只需要进行几部操作就可以实现 ： 注册LeanCloud 注册leanCloud,操作过程略 创建应用： 应用名称可随意 点击应用名字进入应用 创建一个叫Counter的class： 操作完成，在左边你会看到Counter的表 获取AppID和AppKey 点击左边的设置 找到应用key选项 获取其中的你的AppID和你的AppKey 设置主题配置文件设置主题配置文件_config.yml相关字段，实现阅读数量的统计添加以下字段 1234leancloud_visitors: enable: true app_id: #此处填你的app_id app_key: #此处填你的的app_key 完成配置并重新编译。到此已经成功设置了阅读量的统计。 注意！！！！！！ 如果完成上述操作你已经正常显示了文章阅读统计那么下面的额外操作就不需要看了，你可以直接跳过。 但是如果你没有实现该功能，那么请仔细阅读下面的额外操作，尽量别把代码抄错了！ 额外操作部分 按照next的代码组成和位置(当然你可以自定你的相关代码位置，本例将以next的位置方式存放对应的代码文件) 要实现leanCloud的相关功能你需要编辑或者新建以下部分代码: _layout.swig -themes\next\layout\_layout.swig:主要是引用leanCloud的代码文件(此文件也是主题全局初始化引用接口) post.swig -themes\next\layout\_macro\post.swig:主要是文章主题的代码文件(包含主题显示阅读数量的代码) lean-analytics.swig -themes\next\layout\_scripts\third-party\lean-analytics.swig:包含leanCloud功能代码文件以上为next的文件解析和位置介绍。你可以不需要按照以上位置设置，但相关文件的代码引用需要您自行修改。如果文件存在请新建。以下贴出相关代码 实现代码 _layout.swig代码 你需要添加以下部分代码：通常如果next集成了leanCloud,你会发现以下代码 代码的作用是引用leanCloud的功能代码。 1&#123;% include &apos;_scripts/third-party/lean-analytics.swig&apos; %&#125; post.swig代码 你需要在合适的位置添加如下代码，同理如果你的NEXT集成了LeanCloud功能，你会发现以下代码 代码主要是在文章显示阅读次数等 1234567891011&#123;# LeanCould PageView #&#125;&#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt; &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; lean-analytic.swig代码 如果你的NEXT集成了leanCloud功能，你会在本文提到的位置看到此文件，若果没有请新建并填入 以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&#123;% if theme.leancloud_visitors.enable %&#125; &#123;# custom analytics part create by xiamo #&#125; &lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt;AV.initialize(&quot;&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;&quot;, &quot;&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;&quot;);&lt;/script&gt; &lt;script&gt; function showTime(Counter) &#123; var query = new AV.Query(Counter); var entries = []; var $visitors = $(&quot;.leancloud_visitors&quot;); $visitors.each(function () &#123; entries.push( $(this).attr(&quot;id&quot;).trim() ); &#125;); query.containedIn(&apos;url&apos;, entries); query.find() .done(function (results) &#123; var COUNT_CONTAINER_REF = &apos;.leancloud-visitors-count&apos;; if (results.length === 0) &#123; $visitors.find(COUNT_CONTAINER_REF).text(0); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var item = results[i]; var url = item.get(&apos;url&apos;); var time = item.get(&apos;time&apos;); var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(time); &#125; &#125;) .fail(function (object, error) &#123; console.log(&quot;Error: &quot; + error.code + &quot; &quot; + error.message); &#125;); &#125; function addCount(Counter) &#123; var $visitors = $(&quot;.leancloud_visitors&quot;); var url = $visitors.attr(&apos;id&apos;).trim(); var title = $visitors.attr(&apos;data-flag-title&apos;).trim(); var query = new AV.Query(Counter); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment(&quot;time&quot;); counter.save(null, &#123; success: function(counter) &#123; var $element = $(document.getElementById(url)); $element.find(&apos;.leancloud-visitors-count&apos;).text(counter.get(&apos;time&apos;)); &#125;, error: function(counter, error) &#123; console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); /* End Set ACL */ newcounter.set(&quot;title&quot;, title); newcounter.set(&quot;url&quot;, url); newcounter.set(&quot;time&quot;, 1); newcounter.save(null, &#123; success: function(newcounter) &#123; var $element = $(document.getElementById(url)); $element.find(&apos;.leancloud-visitors-count&apos;).text(newcounter.get(&apos;time&apos;)); &#125;, error: function(newcounter, error) &#123; console.log(&apos;Failed to create&apos;); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message); &#125; &#125;); &#125; $(function() &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123; addCount(Counter); &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123; showTime(Counter); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125; 修改语言配置文件 主要是添加visitors字段英文网站：修改themes\next\languages\en.yml 12345post: sticky: Sticky posted: Posted on visitors: Views // 增加的字段 ... 中文网站：修改themes\next\languages\zh-Hans.yml 1234post: posted: 发表于 visitors: 阅读次数 ... WEB安全 为了保证应用的统计计数功能仅应用于自己的博客系统，你可以在应用-&gt;设置-&gt;安全中心的Web安全域名 中加入自己的博客域名，以保证数据的调用安全。 设置完成 以上部分设置完成，就可以正常使用leanCloudS实现文章阅读统计。 实现评论功能 评论功能概述 目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。 可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气。） 来必力：https://livere.com （来自韩国，使用邮箱注册。） 畅言： http://changyan.kuaizhan.com （安装需要备案号。不太好用。） Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。） Valine: https://github.com/xCss/Valine (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？） 综上，最终采用了来必力。 注册账号 打开来必力官网注册：https://livere.com （如注册不来请自行科学上网） 安装 点击上方的安装，选择免费的city版本。 并点击现在安装，出现如下界面。 复制其中的uid字段。 打开主题目录下的blog/themes/next/_config.yml配置文件，定位到livere_uid字段，粘贴上刚刚复制的UID。 至此，大功告成。 添加Github导航条 在首页添加github导航条，点击这里选择需要的样式，然后将代码复制到themes/next/layout/_layout.swig 并将href后面的网址改为你的github地址，最终界面如图 ： 实现统计站点运行时间 实时展示你的博客已经运行了多长时间了，我还是蛮喜欢这个功能的，随着时间的增长，和你的博客访问量形成照样，成就感也会增添不少。 在 hexo/themes/[your theme]/layout 文件夹下找到你的 footer 文件，即脚布局文件，在对应的位置添加一下代码。 1234567891011121314151617&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;02/14/2018 12:49:00&quot;);//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 下面是效果图： 结语 功能暂时只添加这么多，后面应该会持续更新些新奇的玩意，想查看所有效果的预览，请直接进：http://lrsand52m.top 感谢你的观看！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主要元素求法及优化]]></title>
    <url>%2F2018%2F05%2F21%2F%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0%E6%B1%82%E6%B3%95%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在一本书中，我看到这样一道题：已知一个数组中有一个元素的出现次数占所有元素个数一半以上，找出这个元素。 我想：真简单！ 是的，两个for循环能解决的问题，的确不能说难。 但是，两个for循环的确有些浪费，效率也奇低，有点儿“拿不出手”，所以我开始思索如何简化算法（日常思索）： 突然我心生一计：既然出现的频率这么高，那我对这个数组排完序，出现在中间的数不就是这个主要元素吗？ 121. 假设数组为：5 4 3 3 3 2 3 1 3 2. 排完序后为：1 2 3 3 3 3 3 4 5 这样这个算法的时间复杂度就完全取决于我排序算法的时间复杂度了 真是令人振奋呢：排序有三种不同时间复杂度的： 排序方法 复杂度 推荐程度 冒泡排序 O(N^2) ** 桶排序 O(N) ** 快速排序 O(NlogN) *** … … … 当然这里只推荐快排，因为我们给出的数值范围不确定，这样桶排序极其容易浪费掉大量内存，也是“拿不出手”的。 但是快排的时间复杂度也不能说是很低，能不能更加简化呢？比如说O(N)或者O(logN)？ 好吧，我们是理智人，O(logN)就有点逆天，毕竟读入数组就不止这个复杂度了。 所以我们重点讨论O(N)的情形： 消除法：因为占的”份额”实在是多，所以主要元素就是与其他元素一一消除，最终剩下的数也绝对是主元素，所以我们可以考虑用这个方法来“消”出这个主要元素。 这样我们就创造一个计数器k，当遇到相同元素+1，不同减一，很容易知道最终结果必为正数。不过中间过程中会遇到为0的情况，这样我们就初始化k的值，并且把他的指向保存到下一位就行了。 在指完整个数组后，最近保存的指向肯定就是主要元素啦！（想想为什么） 代码附上： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main() &#123; int n; int a[100] = &#123;0&#125;; int book = 1;//提供消除依据 int i = 0; int num = 0;//记录当前比较的数 scanf("%d",&amp;n); for(i=0; i&lt;n; i++) &#123; scanf("%d",&amp;a[i]); &#125; i = 1; if(1 == n); else &#123; while(i&lt;n) &#123; if(a[i] == a[num]) &#123; book++;//相等book+1，数组元素向后寻找 i++; &#125; else &#123; book--;//不等-1 if(!book) &#123; i++;//book=0时，标记数也之移动 num = i; &#125; else i++; &#125; &#125; &#125; printf("主元素为：%d\n",a[num]);//主要元素肯定是标记的数，输出就行 return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组运算</tag>
      </tags>
  </entry>
</search>
