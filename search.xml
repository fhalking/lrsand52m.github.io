<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[这个指针有自己的想法——智能指针]]></title>
    <url>%2F2019%2F01%2F23%2F</url>
    <content type="text"><![CDATA[编辑中。。。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2019%2F01%2F22%2F</url>
    <content type="text"><![CDATA[编辑中。。。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一探多态]]></title>
    <url>%2F2019%2F01%2F14%2F</url>
    <content type="text"><![CDATA[讲完了之前的继承，我们现在再来看一看便(偷)捷(懒)的新花样：多态 多态之前]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++继承]]></title>
    <url>%2F2019%2F01%2F10%2F</url>
    <content type="text"><![CDATA[今天我们探讨一下C++特性之一: 继承 说到继承，我原以为这是一个高大上的东西，到我了解完之后，我发现懒人创造世界这个理论是一点都没错：这只是一种类层次的代码复用的手段。并且为了广大程序猿能够好好偷懒，在这个本就是为了方便的继承机制上添加了一些防止大家用的不愉快的优化措施。 继承的方法继承很简单，定义一个类时在后面加上冒号和你要继承的类就好了~继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。等等！！这是不是太简单了些？简单？（naive） 继承方法/成员 public继承 protected继承 private继承 基类的public 子类的public成员 子类的protected成员 子类的private成员 基类的protected 子类的protected 子类的protected成员 子类的private成员 基类的private 不可见 不可见 不可见 哦 那是不是在要继承的类前面加上继承方式就可以轻松搞定呢？答案是肯定的，但是要注意的一点就是基类的private成员无论怎么继承在子类里面都不可见（但是却消耗内存），多么难受！而实际情况就是：人们一般都是只使用public继承，极少用到protected和private继承。 继承之后…父子转换既然有了继承这个概念之后，那么这个偷懒的产物也肯定给了基类和子类一个关系：基类与子类的复制转换 派生类对象可以赋值给基类的对象/基类的指针/基类的引用。这里有个形象的说法叫切片或者切割。寓意把派生类中父类那部分切来赋值过去。 基类对象不能赋值给派生类对象，这个容易理解：只有把蛋糕切少的，还没有把蛋糕越切越多的。。。 基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的dynamic_cast来进行识别后进行安全转换。 基类的指针可以通过强制类型转换赋值给派生类的指针,但是之后你得注意不要越界了~ 子类成家立业（子类独立）虽然是继承而来，但是基类和子类终究是两个类。子类也会有他自己的想法~ 在继承体系中基类和派生类都有独立的作用域。毕竟不在一个大括号了。 去找父亲办事，但是只有儿子的电话怎么办？简单！让儿子告诉你他父亲的电话。子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（在子类成员函数中，可以使用基类::基类成员显示访问） 需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。也就是说就算参数不一致也算隐藏哦。 注意在实际中在继承体系里面最好不要定义同名的成员。没人会想弄出来一个用起来很别扭的类吧。。。 爸爸教会的技能既然存在父子的转换，那就说明子类不仅继承了父类的成员和函数还有一些其他的东西。。 派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。 派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。 派生类的operator=必须要调用基类的operator=完成基类的复制。 派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。 派生类对象初始化先调用基类构造再调派生类构造。 派生类对象析构清理先调用派生类析构再调基类的析构。明白了以上几点之后，我们知道了一个子类是怎么创造并且销毁的了：基类构造-&gt;派生类构造-&gt;。。。-&gt;派生类析构-&gt;基类析构利用这点我们可以利用构造函数的私有化使这个类无法被继承！当然了，喜欢偷懒的你一定会发现定义类时用final修饰之后这个类就无法被继承了。 爸爸的朋友不是我的朋友友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员,这个其实很容易理解：毕竟父子是独立的嘛！ 爸爸的传家宝：static成员说到成员会被继承就不得不说这个特殊的成员：静态成员值得注意的是：基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例。嗯。。。这样就可以轻松算出这个家族有过多少对象了呢~ 近亲婚姻的烦恼。。。说起这个，真是让人绝望：一个可以使人偷懒的设定，却因为一些缺陷使人更加头疼：C++多继承机制。让我们想象一下这个场景：A有两个孩子子B和C，D又是B和C的儿子…缺陷很明显了：A里的数据D有两份。。还好聪明的A想出了一个法子：领养的孩子总不算近亲了吧~只要在B和C继承A时加上关键字virtual就能轻松解决。不得不说设计者还真是煞费苦心：为了大家能够愉快的编程（偷懒），想出了这个点子。。在内存里面是这样的：B和C中应该存A数据的部分没有存A的数据而是存了一个虚基表指针，这个表里存着A数据相对与当前位置的偏移量（鼓掌声）。。精彩绝伦！！！很可惜。。现实中我们都不鼓励使用这个继承。。甚至在可以使用组合的情况下我们不鼓励使用继承。。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux信号]]></title>
    <url>%2F2018%2F12%2F05%2F</url>
    <content type="text"><![CDATA[今天我们说一说Linux下信号的概念和产生~ 信号的概念在计算机科学中，信号是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。简而言之,信号用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类： 第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。 第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。 第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信 号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。 在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个。 那么信号在什么条件下产生呢？ 信号的产生 与进程终止相关的信号。当进程退出，或者子进程终止时，发出这类信号。 与进程例外事件相关的信号。如进程越界，或企图写一个只读的内存区域（如程序正文区），或执行一个特权指令及其他各种硬件错误，比如除以0。 与在系统调用期间遇到不可恢复条件相关的信号。如执行系统调用exec时，原有资源已经释放，而目前系统资源又已经耗尽。 与执行系统调用时遇到非预测错误条件相关的信号。如执行一个并不存在的系统调用。 在用户态下的进程发出的信号。如进程调用系统调用kill向其他进程发送信号。当然在终端也可以用kill指令，这种方法存在限制：我们必须是信号接收进程的所有者，或者我们必须是超级用户（root）。 与终端交互相关的信号。如用户关闭一个终端，或按下ctrl+c键等情况。 跟踪进程执行的信号。 我们可以用kill -l指令查看信号列表超过34的信号是实时信号，我们暂时不讨论下面是Linux下的信号表（内容来自百度） 信号 值 处理动作 发出信号的原因 SIGHUP 1 A 终端挂起或者控制进程终止 SIGINT 2 A 键盘中断（如break键被按下） SIGQUIT 3 C 键盘的退出键被按下 SIGILL 4 C 非法指令 SIGABRT 6 C 由abort(3)发出的退出指令 SIGFPE 8 C 浮点异常 SIGKILL 9 AEF Kill信号 SIGSEGV 11 C 无效的内存引用 SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道 SIGALRM 14 A 由alarm(2)发出的信号 SIGTERM 15 A 终止信号 SIGUSR1 30,10,16 A 用户自定义信号1 SIGUSR2 31,12,17 A 用户自定义信号2 SIGCHLD 20,17,18 B 子进程结束信号 SIGCONT 19,18,25 / 进程继续（曾被停止的进程） SIGSTOP 17,19,23 DEF 终止进程 SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键 SIGTTIN 21,21,26 D 后台进程企图从控制终端读 SIGTTOU 22,22,27 D 后台进程企图从控制终端写 下面的信号没在POSIX.1中列出，而在SUSv2列出 信号 值 处理动作 发出信号的原因 SIGBUS 10,7,10 C 总线错误(错误的内存访问) SIGPOLL / A Sys V定义的Pollable事件，与SIGIO同义 SIGPROF 27,27,29 A Profiling定时器到 SIGSYS 12,-,12 C 无效的系统调用 (SV/ID) SIGTRAP 5 C 跟踪/断点捕获 SIGURG 16,23,21 B Socket出现紧急条件(4.2 BSD) SIGVTALRM 26,26,28 A 实际时间报警时钟信号(4.2 BSD) SIGXCPU 24,24,30 C 超出设定的CPU时间限制(4.2 BSD) SIGXFSZ 25,25,31 C 超出设定的文件大小限制(4.2 BSD) (对于SIGSYS，SIGXCPU，SIGXFSZ，以及某些机器体系结构下的SIGBUS，Linux缺省的动作是A (terminate)，SUSv2 是C (terminate and dump core)) 下面是其它的一些信号 信号 值 处理动作 发出信号的原因 SIGIOT 6 C IO捕获指令，与SIGABRT同义 SIGEM 7,-,7 / / SIGSTKFLT -,16,- A 协处理器堆栈错误 SIGIO 23,29,22 A 某I/O操作现在可以进行了(4.2 BSD) SIGCLD -,-,18 A 与SIGCHLD同义 SIGPWR 29,30,19 A 电源故障(System V) SIGINFO 29,-,- A 与SIGPWR同义 SIGLOST -,-,- A 文件锁丢失 SIGWINCH 28,28,20 B 窗口大小改变(4.3 BSD, Sun) SIGUNUSED -,31,- A 未使用的信号(will be SIGSYS) （在这里，- 表示信号没有实现；有三个值给出的含义为，第一个值通常在Alpha和Sparc上有效，中间的值对应i386和ppc以及sh，最后一个值对应mips。信号29在Alpha上为SIGINFO / SIGPWR ，在Sparc上为SIGLOST。） 处理动作一项中的字母含义如下 字母 对应动作 A 缺省的动作是终止进程 B 缺省的动作是忽略此信号 C 缺省的动作是终止进程并进行内核映像转储（core dump） D 缺省的动作是停止进程 E 信号不能被捕获 F 信号不能被忽略 注意: 信号SIGKILL和SIGSTOP既不能被捕捉，也不能被忽略。 信号SIGIOT与SIGABRT是一个信号。可以看出，同一个信号在不同的系统中值可能不一样，所以建议最好使用为信号定义的名字，而不要直接使用信号的值。 信号的处理对于进程来说，不能判别是否出现一个信号，而是必须要告诉内核信号出现的时候，执行下列操作。信号的处理方式有三种： 忽略此信号 执行信号的默认处理动作(就是上面表里的动作)。 提供自定义行为，要求处理该信号的时候切换到用户态执行这个处理函数，也叫做捕捉一信号(如上，有些信号无法捕捉)。 信号递达递达之前。。通过系统调用产生信号 我们可以通过系统调用来产生信号。这里我们先来看一下kill函数，1int kill(pid_t pid, int sig); kill函数可以给指定的进程发送信号。这个函数当中，第一个参数是进程的pid，第二个参数是我们需要发送给pid进程的一个信号的序号，比如我们传sig为9，那我们就发送信号SIGKILL。 接下来需要介绍的一个函数叫做raise函数 ：1int raise(int sig); 这个函数是用来给当前进程发送信号的。 abort函数使得当前进程接收到信号而异常中止。1void abort(void); 这个函数会产生SIGABRT信号，这个信号是夭折信号。 软件信号软件产生信号这里我们首先来说一个函数alarm函数:1unsigned int alarm(unsigned int seconds); 里面的变量seconds所给的是一个时间，单位是秒。这个函数的意思就是类似闹钟的形式，alarm（1）的意思让操作系统在1秒钟以后结束这个进程alarm的默认行为动作就是终止这个进程。alarm函数的信号SIGALRM信号，这个信号的默认动作就是终止这个进程，当使用alarm(0)的意思就是取消以前设定的闹钟，返回值就是所剩余的时间。调用alarm函数会产生SIGALRM信号。 信号阻塞阻塞概念阻塞信号我们首先提出一些概念，信号递达：正在执行信号处理的动作，信号产生与信号递达之间叫做信号未决，也叫做pending。当信号阻塞的时候不会递达，接触阻塞，信号才能递达。关于信号，我们首先需要从内核的角度来看看信号。在内核当中，当一个进程接收到信号，会对应的在进程的PCB当中有三个相关的结构， 因为我们现在有31个普通信号，所以这个时候我们可以想下我们前期所说的位图，我们也就可以利用一个整形就够了，每一个信号对应一个比特位。 另外因为是bit位，所以这里注意，即使你产生了多个信号，这里的信号位也只是从0变为1，不记录信号产生了多少次。 pending表标识信号未决表，表示信号是否产生，block阻塞表，表示当前进程与信号屏蔽相关内容。我们也把阻塞信号集叫做当前进程的信号屏蔽字。 注意阻塞和忽略是两回事，阻塞只是屏蔽了信号(block阻塞表对应位置置1)，而忽略是对信号的一种处理方式(可以通过空handler函数实现)。信号集在linux下信号我们定义成为sigset_t类型的，sigset_t我们叫做信号集，这种类型经过我的测试大小是128个字节。信号集下面有一些函数。12345int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signo);int sigdelset(sigset_t *set, int signo);int sigismember(const sigset_t *set, int signo); 这里的函数都放在signal.h当中，sigemptyset函数用来初始化set所指向的信号集，使得信号集所有信号的对应的bit位清空。sigfillset函数标识对set所指向的信号集的所有位进行置位操作。注意，使用信号集之前一定得先试用sigemptyset或者是sigfillset进行初始化信号集。sigaddset是对set所指向的信号集进行进行添加一个信号signo。sigdelset函数是对信号集进行删除有效的信号。sigismember函数是用来判断是否在set所指向的信号集当中包含signo信号。 说完看这些函数我们再说一个和信号屏蔽字相关的函数，sigprocmask函数，1int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); 这个函数是用来进行读取或者修改进程的信号屏蔽字这里的how说的是如何进行更改，set指向你要修改的当前信号屏蔽字，oldset指向修改前你的信号屏蔽字。how参数： 参数 含义 SIG_BLOCK 将set中信号加入信号屏蔽字 SIG_UNBLOCK 将set中信号移出信号屏蔽字 SIG_SETMASK 设置信号屏蔽字为set 注意：如果调用了sigprocmask解除了对当前若干个未决信号的阻塞，则在sigprocmask返回前，至少会将其中的一个信号递达。 接下来说另外的一个函数叫做sigpending，它用来输出pending表中的内容。testpending.c1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;void printfspending(sigset_t *set)&#123; int i=0; for(i=0;i&lt;32;i++) &#123; if(sigismember(set,i)) &#123; printf("1"); &#125; else &#123; printf("0"); &#125; &#125; printf("\n");&#125;int main()&#123; sigset_t set,oset; sigemptyset(&amp;set); printfspending(&amp;set); sigaddset(&amp;set,SIGINT); sigprocmask(SIG_BLOCK,&amp;set,NULL); while(1) &#123; sigpending(&amp;oset); printfspending(&amp;oset); sleep(1); &#125; return 0;&#125; 我们可以从图片当中看到当我们按下Ctrl+c产生SIGINT信号的时候，这个时候就会在未决表改了对应的比特位。SIGINT信号是2号信号，修改了下标为2的位置的比特位。 信号捕捉先来提出一个函数就叫做sigaction函数，这个函数可以修改和信号相关联的动作，实现信号的捕捉。1int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact); struct sigaction的定义：12345678struct sigaction&#123; void (* sa_handler)(int); void (* sa_sigaction)(int, siginfo_t * , void * ); sigset_t sa_mask; int sa_flags; void (* sa_restorer)(void);&#125;; 参数 含义 sa_handler 早期的捕捉函数 sa_sigaction 新添加的捕捉函数，由sa_flags决定是哪个函数 sa_mask 在执行捕捉函数时，设置阻塞其他信号，退出时还原 sa_flags SA_SIGINFO或者0 sa_restorer 保留，应经过时 我们也可以使用signal函数可以实现这个功能。12typedef void (* sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); 它的第一个参数是信号的编号，第二个参数是指向自定义函数的指针，就是当你捕捉到这个信号，不让它去做它的默认操作，而是去做你想要让它做函数，这个参数是一个返回值为void，参数为int的一个函数指针。 signal是C标准库提供的信号处理函数， 接下来说一说信号捕捉的时候的状态转换： 从上面这张图就可以看出整个状态的转换， 首先当你遇到中断、异常或者系统调用的时候进入内核态。 然后产生信号，这样由内核态切换用户态，这个过程当中需要去PCB检查那三张表，然后发现有递达的信号，然后这个时候就去处理信号对应的操作。也就是信号处理函数。 处理信号处理函数的时候，这个时候为了安全的问题，这个时候为用户态。 信号处理函数结束后，然后从用户态切换到内核态。 然后由内核态切换到中断异常执行处的用户态。 所以总共有4次状态的切换。 信号、可重入函数与线程安全有了信号以后，会去调用喜好处理函数，这个时候你的程序就是异步执行，这个时候就引入了一个问题就是可重入函数的问题，对于一个函数，当多个执行流进入函数，运行期间会出现问题的就叫做不可重入函数，不会出现的问题就是可重入函数。信号捕捉函数内部禁止调入不可重入函数。另外可重入函数还会和线程安全有联系： 线程安全不一定是可重入的，可重入的一定是线程安全的。 对全局变量或者公共资源进行多线程的进行访问的时候，则这个就既不是线程安全的也不是可重入。 如果将对临界资源的访问加上锁，则这个函数是线程安全的，但如果这个重入函数若锁还未释放则会产生死锁，因此是不可重入的。 四类不可重入函数： 不保护共享变量的函数 保持跨越多个调用的状态函数 返回指向静态变量指针的函数。 调用线程不安全的函数。 可重入函数是线程安全函数的一种，特点在于它们被多个线程调用的时候，不会引用任何共享数据。对于不可重入函数的处理,我们通常采用的方法就是重写函数。另外就是有些以_r结尾的函数就是那个函数的可重入版本。 信号与竞态条件我们先来介绍一个pause函数。1int pause(void); 关于pause函数，是用来使得调用进程挂起直到有信号递达。如果信号的处理动作是终止进程，则进程终止，pause函数不返回，如果处理动作是忽略，pause函数也不返回。如果处理动作是信号捕捉，则调用捕捉函数，然后返回-1。然后这里我们使用alarm和pause模拟实现一个sleep函数。12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;void sig_alarm(int signo)&#123;&#125;void mysleep(int seconds)&#123; struct sigaction set,oset; set.sa_handler=sig_alarm; sigemptyset(&amp;set.sa_mask); set.sa_flags=0; sigaction(SIGALRM,&amp;set,&amp;oset); //设置闹钟 alarm(seconds); //这里闹钟到时间发送信号SIGALRM，然后执行信号处理函数，然后pause返回错误码-1， pause(); unsigned int unslept=alarm(0); sigaction(SIGALRM,&amp;oset,NULL);&#125;int main()&#123; while(1) &#123; mysleep(2); printf("2 seconds success\n"); &#125; return 0;&#125; 我们这个函数mysleep模拟了sleep函数。但是，我们需要思考一个问题就是在这里存在一个时序竟态的问题，当我们执行完alarm之后，别的进程会竞争夺走了CPU，夺走n秒后，SIGALRM递达了，然后n秒过后，这个时候就去执行pause，这样没有了信号，这样最终就是一直挂起。所以我们要让alarm和pause的操作是原子的才行。linux在这里给出了一个函数sigsuspend函数。1int sigsuspend(const sigset_t *mask); 1.通过mask来临时解除对某个信号的屏蔽2.挂起等待3.然后当sigsuspend返回的时候，这个时候恢复为原来的值 所以我们应该对这一段代码这样操作才行1234//首先屏蔽SIGALRM信号，不让它递达alarm(seconds);//解除屏蔽字，SIGALRM递达，pause(); 所以我们先阻塞信号，保存当前信屏蔽字，然后直到最后进程回到我当前进程，然后我解除SIGALRM信号的屏蔽，这样信号就会递达这样就确保了alarm和pause之间的操作都是原子的。而对于sigsuspend函数来说：sigsuspend用于在接收到某个信号之前，临时用mask替换进程的信号掩码，并暂停进程执行，直到收到信号为止。]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容易爆炸的volatile]]></title>
    <url>%2F2018%2F12%2F04%2F</url>
    <content type="text"><![CDATA[前几天测试空循环速度时发生了一些匪夷所思的事情，经过调查，我锁定了凶手：关键字volatile编译器：VS2013语言：C/C++ 关于这个关键字，简单来说就是通过保证内存的可见性来防止编译器的过度优化。这么专业的一句话说出来，我却更加的迷惑了：什么是内存的可见性？为什么要防止编译器的过度优化？说起来，这其实是同一个问题： 编译器太“聪明”了12345678void test()&#123; int i = 0; i = 1; i = 2; i = 3; i = 4;&#125; 这样一个函数，有五句代码，但是编译器会“觉得”i = 4;所以前面的语句其实并没有转换成为机器码（仅release），这其实在一般的情形下并没有什么区别，还提高了效率。但是并不符合我们编写时的想法，所以加上volatile后编译器就老老实实生成多条指令了。 内存可见性： 线程内，当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后再取变量值时，就直接从寄存器中取值； 当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致 当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致 当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致 几个例子也就是说，我们不加上这个关键字，可能会出现一些让我们费解的现象 空循环速度123456789void test_loop()&#123; clock_t c1 = clock(); for (int i = 0; i &lt; 1000000000; i++); clock_t c2 = clock(); for (volatile int i = 0; i &lt; 1000000000; i++); clock_t c3 = clock(); cout &lt;&lt; c2 - c1 &lt;&lt; endl &lt;&lt; c3 - c2&lt;&lt;endl;&#125; 在debug模式下，我们看一看输出：换成release再试一次：很明显在release下第一个循环被优化掉了，速度快到飞起~ 变量值被意外改变（其实是故意~）123456789101112void test_ebp()&#123; int i = 10; int a = i; printf("i=%d\n", a); __asm &#123; mov dword ptr[ebp - 8], 10h//“偷偷改变i的值” &#125;//VS2013下i的地址是ebp - 8，其他编译器可能不一致，如VC++6.0下应该是ebp - 4 int b = i; printf("i=%d\n", b);&#125; 我们看看debug下的输出：再看看release：很明显读取i值是直接从寄存器里读取了，所以结果居然一致给i加上volatile果然结果就都一致了： 多线程下volatile带来的不可思议的结果我们先看下面的函数：1234int square(volatile int* &amp;p)&#123; return (*p)*(*p);&#125; 看起来是求一个变量平方的函数，但是偏偏是经过volatile修饰的，从而在编译器眼里这个函数是这样的：123456int square(volatile int* &amp;p)&#123; int a = *p; int b = *p; return a*b;&#125; 如果不在多线程环境里，无非是让编译器多忙了几句，但是一旦在多线程下，其他线程可能会在a,b取值之间改变了*p的值，从而得出错误的结果：12345678910111213141516171819202122232425262728293031323334353637int A = 100;volatile int *PA = &amp;A;int square(volatile int* &amp;p)&#123; return (*p)*(*p);&#125;DWORD WINAPI test(LPVOID lpParamter)&#123; int ans = square2(PA); printf("%s %d\n","pthread 1:",ans); for (int i = 0; i &lt; 4200000000; i++) &#123; if (i*i == ans) &#123; cout &lt;&lt; "right" &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; "wrong" &lt;&lt; endl; return 0;&#125;DWORD WINAPI test2(LPVOID lpParamter)&#123; int i = 0; while (1) &#123; *PA = i++; &#125; return 0;&#125;void test_pthread()&#123; HANDLE hThread2 = CreateThread(NULL, 0, test2, NULL, 0, NULL); HANDLE hThread = CreateThread(NULL, 0, test, NULL, 0, NULL); CloseHandle(hThread); CloseHandle(hThread2);&#125; 在test函数里会对函数的出来的结果进行检测，判断是不是一个数的平方（即使溢出也没事）不过我要说的是：即便是在一个线程里不断改变*P的值，出错率还是挺低的~]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度理解函数栈帧]]></title>
    <url>%2F2018%2F11%2F14%2F</url>
    <content type="text"><![CDATA[一直说main函数是程序的入口，然后我就看见在这之前还发生了些不为人知的事… 打开调试时的查看函数调用堆栈你就会发现在调用main函数之前，我们的程序先后先调用了mainCRTStartup和__tmainCRTStartup函数…为求甚解，我继续调查了函数调用的相关知识，发现函数的调用也是有相当多讲究的~ 先认识两个寄存器这么两个寄存器一个是esp，存储栈顶的地址 另一个是ebp，存储栈底的地址之前说了在调用main函数之前我们已经调用过了其它函数，main函数也会拥有自己的栈空间我们随便写一小段代码：1234567891011121314int add(int x,int y)&#123; int z = 0; z = x + y; return z;&#125;int main()&#123; int a = 10; int b = 20; int c = 0; c = add(a,b); return 0;&#125; 进入调试打开反汇编看一下main函数开始后发生了什么：12345678910push ebp 将ebp的值压栈mov ebp, esp 将esp的值赋给ebpsub esp, 4Ch 将esp的值减去0x4Cpush ebx push esipush edi 将ebx,esi,edi压栈lea edi, [ebp-4Ch] 将ebp减去0x4C这个地址赋给edimov ecx, 13h 将0x13赋给ecxmov eax, 0CCCCCCCCh 将0xCCCCCCCC赋给eaxrep stos dword ptr [edi] 从edi地址处每次拷贝eax4个字节的内容重复ecx次（初始化内存空间） 就这样简单的几步，main函数的栈帧就开好啦，同时也对里面的内容进行了初始化（0xCCCCCCCC）这个初始化的值刚好对应汉字“烫烫”所以在一个函数里你要是没有初始化一个变量就将其打印大概率打印出来是个很大的数或者“烫烫烫烫…”再往下看：123456int a = 10; mov dword ptr [ebp-4], 0Ah 在ebp-4这个地址放入0xA，就是10、；以下同理int b = 20; mov dword ptr [ebp-8], 14h int c = 0; mov dword ptr [ebp-oCh], 0 这样我们就将a,b,c三个变量放进了main函数栈的空间里再往下看：12345mov eax, dwoed ptr [ebp-8] 将ebp-8地址放的内容赋给eax，即eax = b = 20；push eax 将eax压栈 下同理mov ecx, dword ptr [ebp-4]push ecx call .... 这里我们可以看出来这是传值调用，形成了一份临时拷贝，并且右边的参数先传参；call这里我们开始调用了add函数，在此之前我们将call指令下条指令的地址已经压栈了(防止函数调用完无法返回)按下F11我们进入add函数123456789101112131415... 和main函数一样的开辟空间int z = 0; mov dword ptr [ebp-4],0z = x+y; mov eax,dword ptr [ebp+8] [ebp+8]正好是参数x的地址 add eax,dword ptr [ebp+0Ch] eax = x+y mov dword ptr [ebp-4],eax [ebp-4]存放的是z 所以z = x+y;return z; mov eax,dword ptr [ebp-4] 把返回值z存到eax寄存器里 pop edi 函数开始时的压栈统统弹掉 pop esi pop ebx mov esp,ebp 把ebp的值给esp pop ebp ebp弹出取栈顶内容(刚好是main函数的栈底！) ret call指令下一条指令地址在这里起到作用(知道具体返回哪里) 最后，返回main函数：123add esp, 8 把栈顶的形参清理(两个四字节数所以加8)mov dword ptr [ebp-0Ch],eax 把存着返回值的eax寄存器的值赋给c ([ebp-0Ch]是c的地址)... 大胆的想法至此我们已经完全观察了main函数创建栈帧、add函数创建栈帧、add函数销毁栈帧的全过程在这个过程中我们也可以发现，两个“距离相当近的函数”在内存角度上也是靠得相当近的这让我产生了一个“大胆的想法”1234567891011121314#include&lt;stdio.h&gt;void func()&#123; int t = 10; int * p = (int* )(* (&amp;t + 1); * (p-1) = 20;&#125;int main()&#123; int a = 0; func(); printf("%d\n",a); return 0;&#125; 在VC6.0环境下，我们发现func函数看似没有对a进行操作，但是打印出来却发现a已经变成了20！！我们深入内存的角度，在func的栈帧里，t的地址的上一片四字节空间里放的正是main函数的ebp，解引用之后强转成为整型指针在减1，就到了存放main函数里a的地址，我们在func函数里操作了main函数栈帧里的地址，这样一般来说是不被允许的，所以我使用了并不严格的VC6.0(当然了，其他编译器创建栈帧分配内存时会有差异，代码要做相应的修改)，成功改变了a的值]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++模板]]></title>
    <url>%2F2018%2F11%2F06%2F</url>
    <content type="text"><![CDATA[说完了C++的内存管理，今天我们讲讲泛型编程的基础：模板 先说上那么两句首先模板在我看来是懒的产物，我们厌倦了一次只实现一种功能，像是卖票的阿姨，不管你是什么身份，票都应该是一样卖才是，而我们的语言在没有实现模板之前，这样的事情是需要我们提前“说好的”：对于学生你怎么卖票，对于老师你怎么卖票。。。等等于是聪明的大佬们想出了一个好办法：模板，我们只告诉你有人买票你就这样卖：这样下来无论是谁来买票你都会自适应地转换成对这种人怎么卖票了。 函数模板说完了上面的一小段，让我们考虑如何实现通用的交换函数：12345678910111213141516171819void Swap(int&amp; left,int&amp; right)&#123; inttemp=left; left=right; right=temp;&#125;void Swap(double&amp; left,double&amp; right)&#123; doubletemp=left; left=right; right=temp;&#125;void Swap(char&amp; left,char&amp; right)&#123; chartemp=left; left=right; right=temp;&#125;...... 诸如此类的函数我们可以一直写下去（自定义类型的数量是无穷的），这对于我们来说绝对是一个难受的事情使用函数重载虽然可以实现，但是有以下几个不好的地方： 重载的函数仅仅只是类型不同，代码的复用率比较低，只要有新类型出现时，就需要增加对应的函数 代码的可维护性比较低，一个出错可能所有的重载均出错那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？于是就出现了函数模板： 函数模板格式template &lt; typename T1, typename T2,……,typename Tn &gt;返回值类型函数名(参数列表){}1234567template &lt;typename T&gt;void Swap(T&amp; left,T&amp; right)&#123; Ttemp=left; left=right; right=temp;&#125; 那么函数模板是怎么办事的呢？ 函数模板的实例化用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化。 隐式实例化：让编译器根据实参推演模板参数的实际类型 123456789101112131415161718192021template&lt;class T&gt;T Add(const T&amp; left,const T&amp; right)&#123; return left+right;&#125;int main()&#123; int a1=10,a2=20; double d1=10.0,d2=20.0; Add(a1,a2); Add(d1,d2); /* 该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型 通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int或者double类型而报错 在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅 Add(a1, d1); */ //* //此时有两种处理方式：1.用户自己来强制转化2.使用显式实例化 Add(a, (int)d); return 0;&#125; 显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型 12345678intmain(void)&#123; int a=10; double b=20.0; //显式实例化 Add&lt;int&gt;(a,b); return 0;&#125;//如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。 模板参数的匹配原则 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数 12345678910111213141516//专门处理int的加法函数int Add(int left,int right)&#123; return left+right;&#125;//通用加法函数template&lt;class T&gt;T Add(T left,T right)&#123; return left+right;&#125;void Test()&#123; Add(1,2); //与非模板函数匹配，编译器不需要特化 Add&lt;int&gt;(1,2); //调用编译器特化的Add版本&#125; 对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数，那么将选择模板 12345678910111213141516//专门处理int的加法函数int Add(int left,int right)&#123; return left+right;&#125;//通用加法函数template&lt;class T1,class T2&gt;T1 Add(T1 left,T2 right)&#123; return left+right;&#125;void Test()&#123; Add(1,2); Add(1,2.0);&#125; 模板函数不允许自动类型转换，但普通函数可以进行自动类型转换 类模板类模板的定义格式12345template&lt;class T1,class T2, ...,class Tn&gt;class 类模板名&#123; //类内成员定义&#125;;//注意：不是具体的类，是编译器根据被实例化的类型生成具体类的模具 类模板的实例化类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。比如实现了一个模板类list list是类的名字 只有加上示例类型如list这才是一个类型，可以用来定义一个变量。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存管理]]></title>
    <url>%2F2018%2F11%2F05%2F</url>
    <content type="text"><![CDATA[总结了一部分内存管理的知识 在c++中内存主要分为5个存储区： 栈（Stack）：局部变量，函数参数等存储在该区，由编译器自动分配和释放.栈属于计算机系统的数据结构，进栈出栈有相应的计算机指令支持，而且分配专门的寄存器存储栈的地址，效率分高，内存空间是连续的，但栈的内存空间有限。堆(Heap)：需要程序员手动分配和释放（new,delete），属于动态分配方式。内存空间几乎没有限制，内存空间不连续，因此会产生内存碎片。操作系统有一个记录空间内存的链表，当收到内存申请时遍历链表，找到第一个空间大于申请空间的堆节点，将该节点分配给程序，并将该节点从链表中删除。一般，系统会在该内存空间的首地址处记录本次分配的内存大小，用于delete释放该内存空间。全局/静态存储区:全局变量，静态变量分配到该区，到程序结束时自动释放，包括DATA段（全局初始化区）与BBS段（全局未初始化段）。其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BBS段。BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0.文字常量区：存放常量，而且不允许修改。程序结束后由系统释放。程序代码区：存放程序的二进制代码使用存储区的三种方式：1）静态存储区（Static Memory）全局变量，静态变量及静态类成员存储在该区，在编译期间就进行分配，生存期到程序结束。存储在该区的对象只初始化一次，且在程序运行期间地址固定不变。2）自动存储区(Autormatic Memory)局部变量，函数参数等存储在该区，由编译器自动分配和释放3）自由存储区（Free Store）由程序员手动分配和释放内存（new,delete） 堆和栈的区别：1）空间大小：栈的内存空间是连续的，空间大小通常是系统预先规定好的，即栈顶地址和最大空间是确定的；而堆得内存空间是不连续的，由一个记录空间空间的链表负责管理，因此内存空间几乎没有限制，在32位系统下，内存空间大小可达到4G2）管理方式：栈由编译器自动分配和释放，而堆需要程序员来手动分配和释放，若忘记delete，容易产生内存泄漏。3）生长方向不同：对于栈，他是向着内存地址减小的方向生长的，这也是为什么栈的内存空间是有限的；而堆是向着内存地址增大的方向生长的4）碎片问题：由于栈的内存空间是连续的，先进后出的方式保证不会产生零碎的空间；而堆分配方式是每次在空闲链表中遍历到第一个大于申请空间的节点，每次分配的空间大小一般不会正好等于申请的内存大小，频繁的new操作势必会产生大量的空间碎片5）分配效率：栈属于机器系统提供的数据结构，计算机会在底层对栈提供支持，出栈进栈由专门的指令执行，因此效率较高。而堆是c/c++函数库提供的，当申请空间时需要按照一定的算法搜索足够大小的内存空间，当没有足够的空间时，还需要额外的处理，因此效率较低。 使用内存时几点注意事项：1）用new和malloc申请内存时，在使用前要检查内存是否分配成功char p=new char[10];if(p==NULL)return；2）使用内存之前要进行初始化3）在对内存进行操作时，防止越界，如数组操作要注意下标范围4）对于动态分配的内存，一定要手动释放，否则程序每运行一次就会丢失一部分内存，造成内存泄漏5）防止内存释放后继续使用它,主要有以下三种情况：a.程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。b.函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。c.使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。野指针：“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。“野指针”的成因主要有三种：(a）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。char p; //此时p为野指针(b)指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针.char p=new char[10]; //指向堆中分配的内存首地址cin&gt;&gt; p;delete []p; //p重新变为野指针(c)指针操作超越了变量的作用范围。char p=new char[10]; //指向堆中分配的内存首地址cin&gt;&gt; p;cout&lt;&lt; (p+10); //可能输出未知数据6）指针的注意点：a.指针指向常量存储区对象char p=”abc”;此时p指向的是一个字符串常量，不能对p的内容进行写操作，如srtcpy(p,s)是错误的，因为p的内容为“abc”字符串常量，该数据存储在常量存储区，但可以对指针p进行操作，让其指向其他的内存空间。b.资源泄漏char p=new char[3]; //分配三个字符空间，p指向该内存空间p=”ab”； //此时p指向常量“ab”,而不再是new char分配的内存空间了，从而造成了资源泄漏delete []p; //释放时报错c.内存越界char * p=new char[3]; //分配三个字符空间，p指向该内存空间strcpy(p,”abcd”); //将abcd存处在分配的内存空间中，由于strlen(“abcd”)=4&gt;3，越界delete []p; //释放时出错malloc calloc realloc 的区别区别: (1)函数malloc不能初始化所分配的内存空间,而函数calloc能.如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题. (2)函数calloc() 会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零. (3)函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void类型.void表示未确定类型的指针.C,C++规定，void* 类型可以强制转换为任何其它类型的指针. (4)realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反，realloc返回的指针很可能指向一个新的地址. (5)realloc是从堆上分配内存的.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动. C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理。 在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc与free不会。 operator new与operator delete函数new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。联系一般来说operator new = malloc+构造函数（若是自定义类型）+失败抛异常operator delete = free+析构函数（若是自定义类型）+失败抛异常注意：operator new和operator delete用户也可以自己实现，用户实现时即可实现成全局函数，也可实现成类的成员函数，但是一般情况下不需要实现，除非有特殊需求。 new与malloc，delete与free的区别内置类型如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL。 自定义类型new的原理1.调用operator new函数申请空间2.在申请的空间上执行构造函数，完成对象的构造delete的原理1 在空间上执行析构函数，完成对象中资源的清理工作2.调用operator delete函数释放对象的空间new T[N]的原理1.调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请2.在申请的空间上执行N次构造函数delete[]的原理1.在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理2.调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间malloc与free正常的申请释放，无明显差别 其他区别malloc/free和new/delete的区别malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是： malloc和free是函数，new和delete是操作符 malloc申请的空间不能初始化，new可以初始化 malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可 malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型 malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常 malloc/free只能申请内置类型的空间，不能申请自定义类型的空间，因为其不会调用构造与析构函数，而new可以，new在申请空间后会调用构造函数完成对象的构造，delete在释放空间前会调用析构函数完成空间中资源的清理 malloc申请的空间一定在堆上，new不一定，因为operator new函数可以重新实现 new/delete比malloc和free的效率稍微低点，因为new/delete的底层封装了malloc/free]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信]]></title>
    <url>%2F2018%2F11%2F04%2F</url>
    <content type="text"><![CDATA[总结了进程间通信的一些相关知识 进程间通信目的数据传输、资源共享、通知事件、进程控制 进程间通信的基本方法：使两个进程“看见”同一个文件 进程间通信的主要分类管道 匿名管道 pipe 命名管道 system IPC 消息队列（数据传输） 共享内存（数据共享） 信号量 （事件通知） POSIX IPC （提供了一套进程间通信的方式） 消息队列 共享内存 互斥量 条件变量 信号量 读写锁 管道最古老的进程间通信的形式把从一个进程连接到另一个进程的一个数据流称为一个“管道”pipe函数功能：创建一无名管道int pipe(int fd[2])；参数：fd:文件描述符数组 fd[0] :读端 fd[1] ：写端返回值：成功返回0，失败返回错误码 代码实现：从键盘读取数据，写入管道，读取管道，写到屏幕12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main(void)&#123; int fds[2]; char buf[100]; int len; if(pipe(fds) == -1)&#123; perror("make pipe"),exit(1); &#125; //键盘读取 while(fgets(buf,100,stdin)) &#123; len = strlen(buf); //write into pipe if(write(fds[1],buf,len) != len) &#123; perror("write to pipe"); break; &#125; memset(buf,0x00,sizeof(buf)); //管道读取 if((len = read(fds[0],buf,100)) == -1) &#123; perror("read from pipe"); break; //向屏幕写入 if(write(1,buf,len) != len) &#123; perror("write to stdout"); break; &#125; &#125; &#125;&#125; mkfifo函数12345//功能：创建管道文件#include&lt;unistd.h&gt;int mkfifo（const char *name , mode_t mode）//参数：fd:文件描述符数组 fd[0] :读端 fd[1] ：写端//返回值：成功返回0.失败返回错误码 打开管道文件的函数123int fd=open(name, O_RDONLY); //读int fd=open(name, O_WDONLY); //写//read/write/ 语义和匿名管道一样 消息队列msgget 函数123456//功能：创建和访问一个消息队列#include&lt;sys/msg.h&gt;#include&lt;sys/ipc.h&gt; int msgget (key_t key, //消息队列名字，相当于文件名 int flags ); // 创建：IPC_CREAT| 0644（权限） 打开：0返回值：成功：消息队列的id, 相当于文件描述符, 失败返回-1 系统中总共能创建多少个消息队列？ msgmnimsgmni 定义了系统范围内的消息队列上限。与信号量一样，消息队列也拥有一个相关的标识符。在系统初始化阶段里，内核创建一个指向消息队列标识符结构的指针数组。该数组的项数由 msgmni确定。对于每个消息队列，Linux 内核为标识符分配44B，为消息队列数据结构分配 96B。为了获得更多的消息队列资源，可以动态增加 msgmni 取值。和信号量一样，消息队列标识符的最大数目也受限于IPCMNI。msgmni的默认上限为 16B，这可能不足以保证一些大型数据库应用平滑地运行。如果在系统上要运行数据库应用的话，推荐默认上限值是 128B。 msgmaxmsgmax 限制进程可以发送的消息长度。该参数由 Msgsnd()函数加以应用。如果待发送消息的长度超过该值，则返回一个错误。该参数可以在运行时调整 msgmnbmsgmnb 确定一个消息队列的容量。该参数的取值存储在消息队列标识符结构的某个域中，用于确定是否存在着对新消息进行排队的空间。msgmnb 值可以动态修改，默认为16384。修改其取值会影响到所有新的消息队列的容量。用户可以通过 Msgctl()系统调用来增加现有消息队列的容量 修改永久修改root用户下修改/etc/sysctl.conf 文件。 更改的方法： 在配置文件/etc/sysctl.conf中加上 kernel.msgmax=value kernel.msgmni=value kernel.msgmnb=value 然后运行sysctl -p 即可进行修改123max queues system wide = // msgmnimax size of message (bytes) = //msgmaxdefault max size of queue (bytes) = //msgmnb 临时修改root用户下sysctl -w kernel.msgmnb= 1048576 相关函数msgsnd函数1234567891011121314//功能：往消息队列中发送消息 #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt; int msgsnd(int id, //msgget的返回值 const void * msgp, //要发送的消息在哪里 size_len, //消息的字节数,不包括channel的大小 int msgflg); //0//返回值：成功：0，失败： -1struct msgbuf &#123; long mtype（channel）; //消息类型（通道号），必须&gt;=1 char mtext[1]; //写上自己的消息的数据类型 &#125;; msgrcv函数12345678910//功能：从消息队列中取数据#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;size_t msgrcv(int id, const void * msgp, //取出来的消息放哪里 size_t len, //装消息的地方的大小，不包括类型 long mtype , //取那个类型消息 int flag); //0 //返回值：成功：实际读取了多少个字节，失败：0 共享内存—— 最快的进程间通信方式共享内存（shared memory）：是linux下的多进程之间的通信方法，这种方法通常用于一个程序的多进程间通信，实际上多个程序间也可以通过共享内存来传递信息。共享内存指在多处理器的计算机系统中，可以被不同中央处理器（CPU）访问的大容量内存。由于多个CPU需要快速访问存储器，这样就要对存储器进行缓存（Cache）。共享内存是存在于内核级别的一种资源，在shell中可以使用ipcs命令来查看当前系统IPC中的状态，在文件系统/proc目录下有对其描述的相应文件。共享内存相比其他几种方式有着更方便的数据控制能力，数据在读写过程中会更透明。shmget函数1234567//功能：创建或打开共享内存 #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; int shmget(key_t key, size_t size, //共享内存段大小 int shmflg); //创建 IPC_CREAT |0644 ,打开 0//返回值：失败：-1 ， 成功：返回一个有效的共享内存标识符 shmat 函数 12345678 #include &lt;sys/types.h&gt; #include &lt;sys/shm.h&gt; void *shmat(int shmid, const char *shmaddr, //想让操作系统挂到这个地址空间 // NULL 让操作系统自己选择 int flag); //0//返回值：实际挂载到的虚拟地址的起始位置 shmdt 函数123456//功能：卸载掉共享内存段 int shmdt(const void *shmaddr);//删除共享内存:shmc int shmctl(int id, int cmd , //IPC_RMID, NULL); shmctl函数共享内存的控制函数12345678int shmctl(int shm_id, int cmd, struct shmid_ds *buf);shmid_ds结构至少包含以下成员:struct shmid_ds &#123; uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125; 参数:12shm_id : 是shmget返回的共享内存标识符。command: 是要采取的动作， 它可以取3个值:1234IPC_STAT 把shmid_ds结构中的数据设置为共享内存的当前关联值IPC_SET 如果进程有足够的权限， 就把共享内存的当前关联值设置为shmid_ds结构中给出的值IPC_RMID 删除共享内存段 buf : 是一个指针，包含共享内存模式和访问权限的结构。 返回值:成功时，返回0，失败时，返回-1.comm.h代码：123456789101112131415#ifndef __COMM_H__#define __COMM_H__#include &lt;stdio.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#define PATHNAME "."#define PROJ_ID 0x6666int createShm(int size);int getShm();int destoryShm(int shmid);#endif comm.c代码：1234567891011121314151617181920212223242526272829303132333435363738394041int CommShm(int size,int flags)&#123; int key=ftok(PATHNAME,PROJ_ID); if(key&lt;0) &#123; perror("ftok"); return -1; &#125; int shmid=shmget(key,size,flags); if(shmid&lt;0) &#123; perror("shmid"); return -2; &#125; return shmid; &#125;int CreateShm(int size)&#123; return CommShm(size, IPC_CREAT|IPC_EXCL|0666);&#125;int GetShm()&#123; return CommShm(0, IPC_CREAT);&#125;int DestoryShm(int shmid)&#123; if(shmctl(shmid,IPC_RMID,NULL)&lt;0) &#123; perror("shmctl"); return -1; &#125; return 0;&#125; server.c代码：1234567891011121314151617181920int main()&#123; int count = 0; int shmid = CreateShm(4096); sleep(5); char * buf = shmat(shmid, NULL, 0); while(count&lt;4096) &#123; buf[count] = 'A'+count%26; sleep(2); count++; buf[count] = '\0'; &#125; shmdt(buf); sleep(5); DestoryShm(shmid); return 0;&#125; client.c 代码：12345678910111213141516#include "comm.h"int main()&#123; int shmid = GetShm(); sleep(5); char* buf = shmat(shmid, NULL, 0); while(1) &#123; printf("%s\n", buf); sleep(2); &#125; shmdt(buf); return 0;&#125; 信号量（集）（本质就是计数器）1.什么是信号量信号量是一种特殊的变量，访问具有原子性。即只允许对它进行两个操作：1)等待信号量当信号量值为0时，程序等待；当信号量值大于0时，信号量减1，程序继续运行。2)发送信号量将信号量值加1。我们使用信号量，来解决进程或线程间共享资源引发的同步问题。 semget函数1234//功能：创建或打开信号量int semget(key_t key , int nsems ,//信号量集中信号量的个数 int flags); //打开0，创建IPC_CREAT|0644 semct函数12345678910//功能：设置信号量初值int semct(semid, int semnum, //信号量集中的第几个信号量 int cmd, // SETVAL su); //信号量初值union semun&#123; int val ; //value for SETVAL&#125;; semct函数12345//功能：查看信号量的值int semct(semid, int semnum, //信号量集中的第几个信号量 int cmd, // GETVAL 0); //信号量初值 P，V操作 key_t键和ftok函数函数ftok把一个已存在的路径名和一个整数标识符转换成一个key_t值，称为IPC键值（也称IPC key键值）。ftok函数原型及说明如下：ftok（把一个已存在的路径名和一个整数标识符转换成IPC键值） 所需头文件 #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; 函数说明 把从pathname导出的信息与id的低序8位组合成一个整数IPC键 函数原型 key_t ftok(const char * pathname, int proj_id) 函数传入值 pathname：指定的文件，此文件必须存在且可存取 proj_id：计划代号（project ID） 函数返回值 成功：返回key_t值（即IPC 键值） 出错：-1，错误原因存于error中 附加说明 key_t一般为32位的int型的重定义ftok的典型实现是调用stat函数，然后组合以下三个值：① pathname所在的文件系统的信息（stat结构的st_dev成员）。② 该文件在本文件系统内的索引节点号(stat结构的st_ino成员)。③ proj_id的低序8位（不能为0）。上述三个值的组合产生一个32位键。 PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。ftok函数，先不去了解它的作用来先说说为什么要用它，共享内存，消息队列，信号量他们三个都是找一个中间介质来进行通信的，这种介质多的是。就是怎么区分开来，就像唯一一个身份证来区分人一样。只要唯一就行，就想起来了文件的设备编号和节点，它是唯一的，但是直接用它来做识别好像不太好，不过可以用它来产生一个号。ftok()就出场了。ftok函数在一般的UNIX中，通常是将文件的索引节点取出，然后在前面加上子序号就得到key_t的值。123456789semop(int semid, struct sembuf sb[], int len);struct sembuf&#123; short sem_num , //信号量的下标 short sem_op , //1 v ,1 p short sem_flg // 0&#125;; 代码：comm.h1234567891011121314151617181920#ifndef _COMM_H_#define _COMM_H_#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/sem.h&gt;#define PATHNAME "."#define PROJ_ID 0x6666union semun&#123; int val; struct semid_ds * buf; unsigned short * array; struct seminfo * _buf;&#125;;int createSemSet(int nums);int initSem(int semid,int nums,int initVal);int P(int semid,int who);int V(int semid,int who);int destroySemSet(int semid);#endif comm.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include "comm.h"static int commSemSet(int nums,int flags)&#123; key_t _key = ftok(PATHNAME,PROJ_ID);//将文件路径设为当前文件 if(_key &lt; 0)&#123; perror("ftok"); return -1; &#125; //创建和访问一个信号量集 int semid = semget(_key,nums,flags);//key：信号集的名字，nums：信号集中信号量的个数，flags：权限标志 if(semid &lt; 0)&#123; perror("semget"); return -2; &#125; return semid;&#125;int createSemSet(int nums)&#123; return commSemSet(nums,IPC_CREAT|IPC_EXCL|0666);&#125;int getSemSet(int nums)&#123; return commSemSet(nums,IPC_CREAT);&#125;int initSem(int semid,int nums,int initVal)&#123; union semun _un; _un.val = initVal; //控制信号量集 if(semctl(semid,nums,SETVAL,_un) &lt; 0)&#123;//semid:由semget返回的信号集标识码，nums：信号量集的序号 //SETVAL:设置信号量集中的信号量的计数器 perror("semctl"); return -1; &#125; return 0;&#125;static int commPV(int semid,int who,int op)&#123; struct sembuf _sf; _sf.sem_num = who;//信号量的编号 _sf.sem_op = op;//信号量一次PV操作时加减的数值 _sf.sem_flg = 0; //创建和访问一个信号量集 if(semop(semid,&amp;_sf,1) &lt; 0)&#123;//semid：信号量标识码，&amp;sf：sembuf结构体 ，1：信号量的个数 perror("semop"); return -1; &#125; return 0;&#125;int P(int semid,int who)&#123; return commPV(semid,who,-1);&#125;int V(int semid,int who)&#123; return commPV(semid,who,1);&#125;int destroySemSet(int semid)&#123; if(semctl(semid ,0,IPC_RMID)&lt;0)&#123; perror("semctl"); return -1; &#125;&#125; test.c12345678910111213141516171819202122232425262728293031323334#include "comm.h"int main()&#123; int semid = createSemSet(1); initSem(semid,0,1); pid_t id = fork(); if(id == 0)&#123; //child int _semid = getSemSet(0); while(1)&#123; P(_semid,0); printf("A"); fflush(stdout); usleep(123456); printf("A "); fflush(stdout); usleep(321456); V(_semid,0); &#125; &#125;else&#123;//father while(1)&#123; P(semid,0); printf("B"); fflush(stdout); usleep(223456); printf("B "); fflush(stdout); usleep(121456); V(semid,0); &#125; wait(NULL); &#125; destroySemSet(semid); return 0;&#125; ipcs小结ipcs -q 列出所有的消息队列 ipcs -m列出所有的共享内存 ipcs -s列出所有的信号量 ipcrm -q 删除指定的消息队列 ipcrm -m删除指定的共享内存 ipcrm -s删除指定的信号量 同步与互斥互斥：由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系为进程的互斥，理解起来就是一个用这份资源的话另一个就不能用，这两者之间就是互斥关系 同步：指的是多个进程协同完成同一项任务 生产者消费者问题：也叫缓存绑定问题，是一个经典的多进程同步问题，分为单生产者单消费者和多生产者多消费者两种情况。 生产者顾名思义，是一个产生数据的进程，而消费者是一个读出数据的进程。 对于单生产者单消费者模式，生产者产生一块数据后，放进缓冲池中，这时消费者看到缓冲池中有数据就可以来拿，如果生产者生产比消费者消费的快，消费者拿完缓冲池中所有数据之后就应该开始等待，等到有数据之后消费者才来消费，如果生产者生产比消费者消费的快，很快就将缓冲池装满了，生产者这时就不再产生数据，等消费者消费一块数据然后生产者再向里面装一块数据。 对于多生产者多消费者问题，就是在生产者之间和消费者之间添加互斥关系，其它和单生产者单消费者相同。或许概念理解起来比较抽象，不过我们可以类比：我们将缓冲池类比成超市，而超市的供货商就是生产者，而我们这些买东西的人就是消费者，单消费者单生产者问题就可以类比为，这家超市只卖一种东西，这里就假设是方便面吧，这家超市小了一点只有一个货架，而且老板脾气比较古怪，只卖一种口味的，而这家超市是方圆百里唯一一家卖东西的，而只有一个人买东西哎，当供货商没有往货架上放方便面的时候即使我们再想吃也没办法，我们只能等，而货架的大小是固定的，供货商如果一次性发货太多了，只能把货架塞满，剩下的只能别人买走一包，然后往货架上再新添一包。多生产者多消费者问题就可以类比为，有多个供货商不过还是这家超市，货架还是那么大，多个供货商都往货架上放方便面，但是货架的空间用一个就少一个意味着一个供销商在这个位置放了，另一个供销商就不能往这个位置放了，只能考虑下一个位置是不是空的，是空的即可以放，不是空的就继续考虑下一个位置，如果放满了就等待，等到有人买走了再次有空位置了才可以放，对于每一个位置，各个供销商之间的关系就是一种互斥关系，而这时买东西的人也不是一个了，有很多个，但对于每个位置，你拿了别人就不能拿了，因为那个位置已经空了，只能看看下个位置有没有你要的方便面，没有的话再向后找，如果找到头也没有就只能等着有某一家供销商放上去了然后你才能拿。对于我们这些消费者针对于每一个位置上的方便面，我们之间存在的也是互斥关系。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和对象]]></title>
    <url>%2F2018%2F10%2F29%2F</url>
    <content type="text"><![CDATA[类和对象学到C++，最基础也是最重要的自然就是类和对象了。 概述 类和结构体为了兼容C语言，我们可以用struct来定义类，但是结构体里面是不能出现函数的，类却可以，我们可以理解为，结构体是一种数据的类型，而类是对象的类型，类能完成结构体的所有功能。 12345678910111213141516171819202122struct Student&#123; void SetStudentInfo(const char* name, const char* gender, int age) &#123; strcpy( _name, name); strcpy( _gender, gender); _age = age; &#125; void PrintStudentInfo() &#123; cout&lt;&lt;_name&lt;&lt;" "&lt;&lt;_gender&lt;&lt;" "&lt;&lt;_age&lt;&lt;endl; &#125; char _name[20]; char _gender[3]; int _age;&#125;;int main()&#123; Student s; s.SetStudentInfo("Peter", "男", 18); return 0;&#125; 类和对象类可以当成是对象的抽象，而对象是类的具体化实现。举个例子，我们可以说人类是一个类，而我们每个人就是一个对象，是人类这个概念的具体化。类不占用内存，但是对象占用。 类的函数类的函数可以在类里直接实现，也可以在类里写声明，在类外定义。如果一个函数代码量少并且经常用到建议直接放在类里实现，因为在类里实现的函数，编译器可能会将其当成内联函数处理，会在一些地方提高运行效率。在类外实现的函数必须带上类域限定符来表示该函数属于哪个类。类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。（静态成员函数除外） 类的访问限定符类有三个访问限定符：public private protected一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。(struct定义的类默认是public)public修饰的成员可以在类外直接访问，另外两个不行。 类与成员变量尽量避免成员函数的参数与成员变量同名，因为成员变量在类中具有全局作用域属性，会造成一些地方可读性差的问题。 类对象的大小基本与结构体计算大小一致，但是成员函数不占用对象大小，并且用空类或者只含函数的类实例化的对象的大小不为零而唯一（为了能够唯一标识该对象）。 类的this指针C++编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指 针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访 问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。 this指针的特性 this指针的类型：类类型* const 只能在“成员函数”的内部使用 时时刻刻指向当前对象，不属于对象的一部分，不会影响sizeof的结果 this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递 类的六个默认成员函数 构造函数 析构函数 拷贝构造函数 赋值操作符重载 取地址操作符重载 const修饰的取地址操作符重载 构造函数 对于一个类，可以通过成员函数等公有的方法给对象设置内容，但是如果每次创建对象都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员 都有一个合适的初始值，并且在对象的生命周期内只调用一次。构造函数是特殊的成员函数，其特征如下： 函数名与类名相同。 无返回值。 对象构造（对象实例化）时编译器自动调用对应的构造函数。 构造函数可以重载 123456789101112131415161718192021222324class Date&#123; public : // 1.无参构造函数 Date () &#123;&#125; // 2.带参构造函数 Date (int year, int month , int day ) &#123; _year = year ; _month = month ; _day = day ; &#125; private : int _year ; int _month ; int _day ; &#125;;void TestDate()&#123; Date d1; // 调用无参构造函数 Date d2 (2015, 1, 1); // 调用带参的构造函数 // 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明 // 以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象 Date d3();&#125; 构造函数可以在类中定义，也可以在类外定义。 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定 义编译器将不再生成 123456789101112131415161718192021222324252627class Date&#123; public: void SetDate(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; /* // 如果用户显式定义了构造函数，编译器将不再生成 Date (int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; */ private: int _year; int _month; int _day; &#125;;void Test()&#123; // 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数 Date d;&#125; 无参的构造函数和全缺省的构造函数都称为缺省构造函数，并且缺省构造函数只能有一个 12345678910111213141516171819202122232425262728// 缺省构造函数class Date&#123; public: Date() &#123; _year = 1900 ; _month = 1 ; _day = 1; &#125; Date (int year = 1900, int month = 1, int day = 1) &#123; _year = year; _month = month; _day = day; &#125;private : int _year ; int _month ; int _day ;&#125;;// 以下测试函数无法通过编译void Test()&#123; Date d1;&#125; 对于含有其他类的类执行默认构造函数时，会对其他类的默认构造函数进行调用。 析构函数析构函数：与构造函数功能相反，在对象被销毁时，由编译器自动调用，完成类的一些资源清理和汕尾工作。(而不是删除对象，析构函数是在对象销毁前自动调用的) 析构函数名是在类名前加上字符 ~。 无参数无返回值。 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。 对象生命周期结束时，C++编译系统系统自动调用析构函数。 拷贝构造函数构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象 创建新对象时由编译器自动调用 拷贝构造函数是构造函数的一个重载形式。 拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用（形参也会调用拷贝构造函数引发无穷递归）。 若未显示定义，系统会默认生成默认的拷贝构造函数。 默认的拷贝构造函数会按照成员的声明顺序依次 拷贝类成员进行初始化 赋值操作符重载类似于拷贝构造函数，为了使代码可读性变强，可以方便的对对象用另一个对象赋值。 深拷贝与浅拷贝对于系统默认的拷贝构造与赋值函数，都只是将变量值一一拷贝的浅拷贝，对于动态开辟的空间，必须使用深拷贝，否则在对象销毁时会使程序崩溃。 取地址与const修饰的取地址操作符重载这两个默认成员函数一般不用重新定义 ，编译器默认会生成。123456789101112131415class Date&#123; public : Date* operator&amp;() &#123; return this ; &#125; const Date* operator&amp;()const &#123; return this ; &#125; private : int _year ; // 年 int _month ; // 月 int _day ; // 日&#125;; 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比 如想让别人获取到指定的内容. 初始化列表构造函数调用之后，对象中已经有了一个初始值，但是我们不能将其称作为类对象成员的初始化，构造函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，而构造函数体内 可以多次赋值。初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个”成员变量”后面跟一个放在括 号中的初始值或表达式。 每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次) 成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关 尽量避免使用成员初始化成员 类中包含以下成员，一定要放在初始化列表位置进行初始化:1.引用成员变量2.const成员变量3.类类型成员(该类有非缺省的构造函数) 构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用。(用关键字explicit可以禁止这样的隐式转换) 友元友元分为：友元函数和友元类 友元函数友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声 明，声明时需要加friend关键字。说明: 友元函数可访问类的私有成员，但不是类的成员函数 友元函数不能用const修饰 友元函数可以在类定义的任何地方声明，不受类访问限定符限制 一个函数可以是多个类的友元函数 友元函数的调用与普通函数的调用和原理相同友元类友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员友元的优缺点优点：提高了程序运行效率缺点：破坏了类的封装性和隐藏性注意：友元关系是单向的，不具有交换性。友元关系不能传递 如果B是A的友元，C是B的友元，则不能说明C时A的友元。特殊友元类：内部类直接定义在其他类里面的类是该类的内部类 内部类是外部类的友元类，反之不然.2 .内部类可以直接访问外部类的静态成员，枚举成员并且不需要外部类的名字。 sizeof(外部类) = 外部类大小，与内部类无关。类的静态成员声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；用static修饰的 成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化 静态成员为所有类对象所共享，不属于某个具体的实例 静态成员变量必须在类外定义，定义时不添加static关键字 类静态成员即可用类名::静态成员或者对象.静态成员来访问 静态成员函数没有隐藏的this指针，不能访问任何非静态成员 静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值， const修饰符等参数]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述Linux开发工具]]></title>
    <url>%2F2018%2F09%2F20%2F</url>
    <content type="text"><![CDATA[linux中vim是一款强大的编辑器，我最近从网上看到了不少如何把它变成一个更加强大的编辑器的文章，所以我也试着配置一下。 Vim的简单配置12345678910111213141516171819202122232425262728293031323334set nocompatible &quot; 关闭 vi 兼容模式syntax on &quot; 自动语法高亮set number &quot; 显示行号set cursorline &quot; 突出显示当前行set ruler &quot; 打开状态栏标尺set shiftwidth=4 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 &quot; 使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot; 设定 tab 长度为 4set nobackup &quot; 覆盖文件时不备份set autochdir &quot; 自动切换当前目录为当前文件所在的目录filetype plugin indent on &quot; 开启插件set backupcopy=yes &quot; 设置备份时的行为为覆盖set ignorecase smartcase &quot; 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan &quot; 禁止在搜索到文件两端时重新搜索set incsearch &quot; 输入搜索内容时就显示搜索结果set hlsearch &quot; 搜索时高亮显示被找到的文本set noerrorbells &quot; 关闭错误信息响铃set novisualbell &quot; 关闭使用可视响铃代替呼叫set t_vb= &quot; 置空错误铃声的终端代码set showmatch &quot; 插入括号时，短暂地跳转到匹配的对应括号set matchtime=2 &quot; 短暂跳转到匹配括号的时间set magic &quot; 设置魔术set hidden &quot; 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏set smartindent &quot; 开启新行时使用智能自动缩进set backspace=indent,eol,start &quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 &quot; 设定命令行的行数为 1set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\ &quot; 设置在状态行显示的信息set foldenable &quot; 开始折叠set foldmethod=syntax &quot; 设置语法折叠set foldcolumn=0 &quot; 设置折叠区域的宽度0setlocal foldlevel=1 &quot; 设置折叠层数为1 上面的配置让我写起C程序舒服了一些，当然还可以有更加强大的功能，不过这些要看你自己想要什么功能，去网上搜索一下就能轻松找到。 除了Vim还有哪些强大的编辑器EmacsEmacs，著名的集成开发环境和文本编辑器。Emacs被公认为是最受专业程序员喜爱的代码编辑器之一，另外一个vim。EMACS，即Editor MACroS（编辑器宏）的缩写，最初由Richard Stallman(理查德·马修·斯托曼)于1975年在MIT协同Guy Steele共同完成。这一创意的灵感来源于TECMAC和TMACS，它们是由Guy Steele、Dave Moon、Richard Greenblatt、Charles Frankston等人编写的宏文本编辑器。自诞生以来，Emacs演化出了众多分支，其中使用最广泛的两种是：1984年由Richard Stallman发起并由他维护至今的GNU Emacs，以及1991年发起的XEmacs。XEmacs是GNU Emacs的分支，至今仍保持着相当的兼容性。Emac使用Emacs Lisp，这种有着极强扩展性的编程语言，从而实现了包括编程、编译乃至网络浏览等等功能的扩展。 EclipseEclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。虽然大多数用户很乐于将 Eclipse 当作 Java 集成开发环境（IDE）来使用，但 Eclipse 的目标却不仅限于此。Eclipse 还包括插件开发环境（Plug-in Development Environment，PDE），这个组件主要针对希望扩展 Eclipse 的软件开发人员，因为它允许他们构建与 Eclipse 环境无缝集成的工具。由于 Eclipse 中的每样东西都是插件，对于给 Eclipse 提供插件，以及给用户提供一致和统一的集成开发环境而言，所有工具开发人员都具有同等的发挥场所。这种平等和一致性并不仅限于 Java 开发工具。尽管 Eclipse 是使用Java语言开发的，但它的用途并不限于 Java 语言；例如，支持诸如C/C++、COBOL、PHP、Android等编程语言的插件已经可用，或预计将会推出。Eclipse 框架还可用来作为与软件开发无关的其他应用程序类型的基础，比如内容管理系统。基于 Eclipse 的应用程序的一个突出例子是 IBM Rational Software Architect，它构成了 IBM Java 开发工具系列的基础。 BracketsBrackets也是一款为Linux开发者设计的开源代码编辑器，使用Brackets写代码，你不会被任何事情所打断。比如在写HTML代码时，即便你没有保存代码也可以及时预览你的Web页面效果。你也可以使用Theseus来检查变量，Brackets默认提供一种主题，当然你也可以在扩展中心获取更多的主题。 LighttableLightTable是一个应用ClojureScript写的可扩展的集成编辑环境（IDE）。由ChrisGranger和RobertAttorri开发。具有实时运行反馈，调试和搜索文档的功能。及时反馈功能提供了一个不同寻常的运行环境来让程序员构建抽象。 开发团队试图创造一个能够让程序员及时获知程序运行状态的软件。该软件一开始只支持Clojure语言，但是现在通过众多扩展，也能够支持Python和JavaScript语言。 Sublime TextSublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。 注*：以上内容来自网络搜索。 除了gcc, 还有哪些常用的编译器EGCS(Experimental/Enhanced GNU Compiler System) 一个编译系统，包括了C/C++/Obj-C/Fortran等编译器eclipse 也同样支持很多语言的开发，最厉害的当然还是对Java的开发。 为什么调试的时候需要编译选项中添加 -g.调试的时候需要编译选项中添加 -g. 加选项-g是为了能够调试。不加可以运行，但不能调试 readelf用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的elf-file(s)就表示那些被检查的文件。可以支持32位，64位的elf格式文件，也支持包含elf文件的文档（这里一般指的是使用ar命令将一些elf文件打包之后生成的例如lib*.a之类的“静态库”文件）。 这个程序和objdump提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件)，所以即使BFD库有什么bug存在的话也不会影响到readelf程序。 运行readelf的时候，除了-v和-H之外，其它的选项必须有一个被指定。 ELF文件类型： a)可重定位文件:用户和其他目标文件一起创建可执行文件或者共享目标文件,例如lib*.a文件。 b)可执行文件：用于生成进程映像，载入内存执行,例如编译好的可执行文件a.out。 c)共享目标文件：用于和其他共享目标文件或者可重定位文件一起生成elf目标文件或者和执行文件一起创建进程映像，例如lib*.so文件。 在Linux下完成一个彩色的进度条.首先我们编写Makefile：12345bar:bar.c gcc bar.c -o bar.PHONY:cleanclean: rm bar 写好之后我们就要开始编写进度条程序bar.c了，但是在开始之前，我们需要了解一下怎么在Linux里打印出彩色字体格式如下： 1234\033[显示方式;前景色;背景色m\033[0m 默认\033[1;32;40m 绿色\033[1;31;40m 红色 显示方式：10（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、5（闪烁）、25（非闪烁）、7（反显）、27（非反显） 前景色:130（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（洋红）、36（青色）、37（白色） 背景色:140（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（洋红）、46（青色）、47（白色） 示例代码：1printf( "\033[1;31;40m 红色 \033[0m" );//后面带上\033[0m恢复默认不然之后的所有字符都会变红色 在了解了怎么弄好颜色之后写出彩色进度条就简单多了：1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; char buf[100] = &#123; 0 &#125;; const char*label = "-\\/|";//模拟转圈 size_t i = 0; for (; i &lt;= 50; ++i) &#123; buf[i] = '*'; if (i &lt;= 20) printf("\e[32m[%lu%%]\e[0m\e[33m[%c]\e[0m\e[34m[%-50s]\e[0m\r", i * 2, label[i % 4], buf); else printf("\e[32m[%lu%%]\e[0m\e[33m[%c]\e[0m\e[35m[%-50s]\e[0m\r", i * 2, label[i % 4], buf); fflush(stdout); usleep(100000); &#125; printf("\n"); return 0;&#125; 但是这个的彩色看起来还是太单调了，我们不禁想到Linux开机时的那个彩色渐变的进度条，这个能不能简单实现呢？答案是可以：bar.c123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;math.h&gt;#define Black 40#define White 47#define Blue 44#define Green 42void printbp(int color,size_t n)&#123; char p[100] = &#123;0&#125;; sprintf(p,"\e[0;30;%dm \e[0m",color); while(n--) printf(p); return;&#125;int main()&#123; char*label = "-\\|/"; size_t i = 1,j = 0,k = 0; for (; i &lt;= 100; ++i) &#123; int G,B,W; G = i*i/100; B = i-G; W = 10*sqrt(i)-B-G; printbp(Green,G); printbp(Blue,B); printbp(White,W); printbp(Black,100-G-B-W); printf("[%d%%][%c]\r",i,label[i%4]); fflush(stdout); usleep(100000); &#125; printf("\n"); return 0;&#125; 但是注意这个彩色的进度条对应的Makefile有些差异，主要是因为sqrt函数的特殊性，所以这个Makefile我们这样写：12345bar:bar.c gcc -o bar bar.c -lm.PHONY:cleanclean: rm bar -lm是为了表示使用了Math库的函数rpm安装和yum安装的区别. rpm安装和yum安装的区别 安装包都是以rpm结尾的。 yum是从网络安装源（例如网易镜像，可以自己配置）上下载rpm，如果存在依赖关系会把依赖的rpm同时下载安装。 rpm是安装本地存在的rpm包，如果存在依赖也需要安装上,如果某个rpm是自己修改编译的，那么只能用rpm安装了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组里的重复数字]]></title>
    <url>%2F2018%2F09%2F01%2F</url>
    <content type="text"><![CDATA[我总结了一下我目前遇到过的数组里有重复数字的各种问题以及对应的求法 求数组中只出现一次的元素 1.一个数组中有一个数字只出现了一次，其余数字都出现了两次，找出这个数字这道题没有学过异或相关知识的话，大概第一反应就是用暴力法(把每个数字都与后面的数字相比较)毫无疑问这个方法非常直观，但是缺点也很明显：时间复杂度：O(N*N) 这不是一个让人满意的复杂度。如果你了解异或的知识的话就不难发现以下两点事实：对任意一个整数N，都有:N^N = 0；N^0 = N。其中^是异或运算符，了解了这么两点,事情就会变得简单：把数组里的所有元素都异或一遍，最后得出的结果刚好就是那个只出现一次的数字。 12345678910int FindTheOne(int *a,int lenth)//a是数组，len为数组长度&#123; int ret = 0; int i = 0; for(i = 0;i&lt;len;i++) &#123; ret^=a[i]; &#125; return ret;&#125; 2.一个数组中只有两个数字出现一次，其他所有数字都出现了两次，找出这两个数字了解了上面的异或知识后，我们知道再像第一题那样操作的话，最得出的结果是这两个只出现一次的数字的异或值。假设这两个数为a和b，最后的结果就是a^b，而且我们知道这个值绝对不为零（为什么？）对于a^b，从低位到高位开始，找到第一个bit位为1的位置设定为第m位，这个第m位的1肯定来自a或者来自b，不可能同时a,b的第m位（从低到高位）都为1。这样，就可以根据这个第m位就可以把数组分为两个部分，一组为第m位为0，一组为第m位为1.这样，就把问题分解成了求两个数组中只出现一次的数字了。 12345678910111213141516171819202122232425262728293031323334353637int GetOnePos(int num) //从低位开始找到第一个位1的bit位&#123; int index=1; int i=0; while(i&lt;32) &#123; if((num&amp;(1&lt;&lt;i))==(1&lt;&lt;i)) break; else &#123; index++; i++; &#125; &#125; return index; &#125; int IsBitOne(int num,int index) //判断给定位置的bit位是否为1&#123; num=(num&gt;&gt;index); return num&amp;1; &#125; void FindTheTwo(int *a,int len,int *num1,int *num2)&#123;//没法返回两个数，所以传地址进来直接赋值 int result=0; assert(a&amp;&amp;num1&amp;&amp;num2); *num1=0; *num2=0; for(int i=0;i&lt;len;i++) result^=a[i]; int index=GetOnePos(result); for(i=0;i&lt;len;i++) if(IsBitOne(a[i],index)) (*num1)^=a[i]; for(i=0;i&lt;len;i++) if(!IsBitOne(a[i],index)) (*num2)^=a[i];&#125; 3.一个数组中只有三个数字出现一次，其他所有数字都出现了两次，找出这三个数字额 看到这个问题我不知该说什么，因为这已经有点刁难人的意味在里面了，但是我们还是按部就班的来，首先还是全部异或一遍，最后得到的结果是a^b^c,我们令x = a^b^c 不难知道x与a,b,c任何一个都不相等（为什么？）证明：x^a,x^b,x^c中只有一个第m-bit位为1.假设他们的第m位都为1，那么x的第m位为0，但是x=a^b^c其第m位肯定为1，所以假设不成立。那么相反，假设x的第m位为1，a,b,c的第m位都为0，也不成立，因为x=a^b^c。所以根据上面的反证法我们知道了x^a,x^b,x^c中只有一个第m位为1。那么这个问题就好办了。根据这个第m位找到第一个只出现一次的数字。然后剩下两个就是问题2所描述的问题。 1234567891011121314151617181920212223242526272829303132333435int GetFirstBit(int num) &#123; return num&amp;~(num-1); &#125; void FindTheThree(int *a,int len,int *num1,int *num2,int *num3) &#123; int result_code=0; assert(a&amp;&amp;num1&amp;&amp;num2&amp;&amp;num3); for(int i=0;i&lt;n;i++) result_code^=a[i]; int flag=0; for(i=0;i&lt;len;i++) flag^=GetFirstBit(result_code^a[i]); flag=GetFirstBit(flag); *num1=0; for(i=0;i&lt;len;i++) &#123; if(GetFirstBit(result_code^a[i])==flag) &#123; (*num1)^=a[i]; &#125; &#125; for(i=0;i&lt;len;i++) &#123; if(a[i]==(*num1)) &#123; int temp=a[i]; a[i]=a[len-1]; a[len-1]=temp; break; &#125; &#125; FindTheTwo(a,len-1,num2,num3); &#125; 求数组主元素什么是主元素呢，就是指数组中出现次数超过数组长度一半的元素，这个问题之前我专门讨论过：传送门：http://lrsand52m.top/2018/05/21/#more 求数组里的重复数字 1.求一个字符数组中的第一个重复的字符最直接方法：暴力…不用多想，妥妥的O(N*N)那么有木有O（N）的解法呢，当然有啦~（没有我就不写这个问题了 哈哈）首先我们知道字符型只占据8个比特位一个字节，最多能表示256种可能，所以我们利用哈希方法，建立一个表，存储对应字符的出现次数（遍历了一遍），再从头开始检索每个字符的次数（又遍历了一遍），第一个次数大于一的就是我们要找的啦（真简单）这个算法使用了常数级别的额外空间让算法实现了O(N)的时间复杂度，可以说相当强大了（有没有感觉这种方法与桶排序有异曲同工之妙？）。 12345678910111213char FindFirstDup(char *a,int len)&#123; int index[256] = &#123;0&#125;; int i = 0; assert(a); for(i = 0;i&lt;len;i++) index[a[i]+128]++; for(i = 0;i&lt;len;i++) if(index[a[i]+128]&gt;1) return a[i]; perror(&quot;Dup not found&quot;); return a[0];&#125; 2.一个长度为N的数组，里面存有0 ~ N-2这些值，很明显，数组里必定存在重复元素，现在可以向你保证只有一个重复的元素，但是我们不保证其只出现两次，它可能出现很多次。例如int a[5] = {1,2,2,2,3};请找出这个重复的数字。最直接方法：暴力…不用多想，妥妥的O(N*N) (嗯 暴力还是能解决相当多的问题的- -！)我觉得大家第一反应应该是想到了上面的哈希方法，建立一个长度N的哈希表，然后再…就解决了，这个方法时间复杂度O(N),空间复杂度O(N)，因为这里我们使用额外空间的长度不再是常数了。那么···有木有空间复杂度O(LogN)或者O(1)的算法呢？答案是有的，但是首先我们要了解一下抽屉原理：有N本书要放进N-1个抽屉里，那么无论你怎么放，你都会发现至少有一个抽屉里装了不只一本书。这个原理非常简单，简单到什么程度呢？额 就是我这么一说你就明白的程度，够简单吧？然而就是这么简单的抽屉原理，这个题目都给我们出了简化版：题目相当于告诉我们只有一个抽屉里放了多本书，而其他抽屉要么只有一本，要么没放书。如果现实中有人扔给了你这样一个问题你会怎么做呢？很简单，你只需要打开每个抽屉，查看里面有几本书就行了。但是在这里书和抽屉并不是对应着放的，我们又该怎么办呢？额 那么把书放进对应的抽屉不就好了吗？ 围观群众说道；是的，就是这么简单！我们对数组中的数字进行遍历并且这样操作：1.数字等于下标值，代表书的位置正确，我们查看下一个；2.数字不等于下标值，代表书的位置不对，我们需要调整：查看对应下标值位置上的数字，如果也对不上，那么交换。如果人家的位置是正确的…那么这个值显然就是你要找的重复值了！ 1234567891011121314151617181920int FindDupNum(int *a,int len)&#123; int i = 0; for(i = 0;i&lt;len;i++) &#123; if(a[i] != i) &#123; if(a[a[i]] == a[i]) return a[i]; else &#123; int t = a[i]; a[i] = a[a[i]]; a[t] = t; i--; &#125; &#125; &#125; perror(&quot;The Dup Not found&quot;);&#125; 这样每一次交换都会使一个抽屉里装的书是对的，那么我们最多遍历一遍就可以找到这个重复的数字了，并且我们实现了空间复杂度O(1),时间复杂度O(N)。由于我打字打的手有点累，这次就先写到这里吧，我说的并不是很系统请见谅~~]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2018%2F08%2F14%2F</url>
    <content type="text"><![CDATA[实现了简单的栈和队列之后，我们可以考虑玩点花样：怎么用两个栈实现一个队列的功能 用两个栈实现队列说起来也不是很困难，我们根据栈的特性：后进先出，也就是先进后出，相当于把数据倒过来了，这样我们用两个栈颠倒了两次，也就是实现了队列的功能：先进先出。对这个用两个栈S1和S2形成的队列进行操作时，我们该怎么样操作呢？数据入队列：数据录入相当简单，直接把数据录入栈S1即可。数据出队列：数据出队相对麻烦，我们把栈S1的数据依次录入栈S2,弹出栈S1，这样S2的内容就符合出队要求了。只需要对S2进行出栈操作就行。思路：入栈进S1，出栈由S2完成，如果S2无数据，把S1的数据压入S2。工具：VS2013语言：C代码如下：头文件QueueByTwoStack.h1234567891011121314151617181920212223242526272829303132333435363738394041#pragma once#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;typedef int DataType;typedef struct Stack&#123; DataType* data; int top; // 栈顶 int capacity; // 容量&#125;Stack;// 两个栈实现一个队列typedef struct QueueByTwoStack&#123; Stack s1; Stack s2;&#125;QueueByTwoStack;void QueueInit(QueueByTwoStack* pq);void QueueDestory(QueueByTwoStack* pq);void QueuePush(QueueByTwoStack* pq, DataType x);void QueuePop(QueueByTwoStack* pq);DataType QueueFront(QueueByTwoStack* pq);int QueueEmpty(QueueByTwoStack* pq);int QueueSize(QueueByTwoStack* pq);void TestQueue();void StackInit(Stack* ps);void StackDestory(Stack* ps);void StackPush(Stack* ps, DataType x);void StackPop(Stack* ps);DataType StackTop(Stack* ps);int StackEmpty(Stack* ps);int StackSize(Stack* ps); 源文件Stack.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;QueueByTwoStack.h&quot;void StackInit(Stack* ps)&#123; assert(ps); ps-&gt;data = (DataType*)malloc(sizeof(Stack)* 3); ps-&gt;capacity = 3; ps-&gt;top = 0;&#125;void StackDestory(Stack* ps)&#123; assert(ps); if (ps-&gt;data) free(ps-&gt;data); ps-&gt;capacity = 0; ps-&gt;top = 0;&#125;void StackPush(Stack* ps, DataType x)&#123; assert(ps); if (ps-&gt;top == ps-&gt;capacity) &#123; ps-&gt;data = (DataType*)realloc(ps-&gt;data, sizeof(Stack)*(ps-&gt;capacity * 2)); if (ps-&gt;data) ps-&gt;capacity *= 2; else perror(&quot;capacity realloc&quot;); &#125; *(ps-&gt;data + ps-&gt;top++) = x;&#125;void StackPop(Stack* ps)&#123; assert(ps&amp;&amp;ps-&gt;data); if (ps-&gt;top) ps-&gt;top--;&#125;DataType StackTop(Stack* ps)&#123; assert(ps&amp;&amp;ps-&gt;data&amp;&amp;ps-&gt;top); return *(ps-&gt;data + ps-&gt;top - 1);&#125;int StackEmpty(Stack* ps)&#123; assert(ps); return ps-&gt;top != 0;&#125;int StackSize(Stack* ps)&#123; assert(ps&amp;&amp;ps-&gt;data); return ps-&gt;top;&#125; QueueByTwoStack.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&quot;QueueByTwoStack.h&quot;void QueueInit(QueueByTwoStack* pq)&#123; assert(pq); StackInit(&amp;pq-&gt;s1); StackInit(&amp;pq-&gt;s2);&#125;void QueueDestory(QueueByTwoStack* pq)&#123; assert(pq); StackDestory(&amp;pq-&gt;s1); StackDestory(&amp;pq-&gt;s2);&#125;void QueuePush(QueueByTwoStack* pq, DataType x)&#123; assert(pq); StackPush(&amp;pq-&gt;s1, x);&#125;void QueuePop(QueueByTwoStack* pq)&#123; assert(pq); if (StackEmpty(&amp;pq-&gt;s2)) StackPop((&amp;pq-&gt;s2)); else if (StackEmpty(&amp;pq-&gt;s1)) &#123; while (StackEmpty(&amp;pq-&gt;s1)) &#123; StackPush(&amp;pq-&gt;s2, StackTop(&amp;pq-&gt;s1)); StackPop(&amp;pq-&gt;s1); &#125; &#125;&#125;DataType QueueFront(QueueByTwoStack* pq)&#123; assert(pq); if (StackEmpty(&amp;pq-&gt;s2) == 0) &#123; while (StackEmpty(&amp;pq-&gt;s1)) &#123; StackPush(&amp;pq-&gt;s2, StackTop(&amp;pq-&gt;s1)); StackPop(&amp;pq-&gt;s1); &#125; &#125; return StackTop(&amp;pq-&gt;s2);&#125;int QueueEmpty(QueueByTwoStack* pq)&#123; assert(pq); return StackEmpty(&amp;pq-&gt;s1) || StackEmpty(&amp;pq-&gt;s1);&#125;int QueueSize(QueueByTwoStack* pq)&#123; assert(pq); return StackSize(&amp;pq-&gt;s1) + StackSize(&amp;pq-&gt;s2);&#125;void TestQueue()&#123; QueueByTwoStack q; int i; QueueInit(&amp;q); QueuePush(&amp;q, 1); QueuePush(&amp;q, 2); QueuePush(&amp;q, 3); QueuePush(&amp;q, 4); QueuePush(&amp;q, 5); QueuePush(&amp;q, 6); printf(&quot;Size:%d\n&quot;, QueueSize(&amp;q)); printf(&quot;empty:%d\n&quot;, QueueEmpty(&amp;q)); for (i = 0; i &lt; 6; i++) &#123; printf(&quot;%d &quot;, QueueFront(&amp;q)); QueuePop(&amp;q); &#125; printf(&quot;\nSize:%d&quot;, QueueSize(&amp;q)); printf(&quot;\nempty:%d&quot;, QueueEmpty(&amp;q)); QueueDestory(&amp;q);&#125; Test.c12345678#include&quot;QueueByTwoStack.h&quot;#include&lt;windows.h&gt;int main()&#123; TestQueue(); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30行代码写出贪吃蛇]]></title>
    <url>%2F2018%2F07%2F03%2F</url>
    <content type="text"><![CDATA[之前写过一个变色贪吃蛇，虽说功能多得很（都已经更新至4.1版本了），但是我后来经过学习意识到这样的一个贪吃蛇实际上并不需要几千行代码，奈何我很懒，懒得在原先的基础上大动刀子。所以我就另起炉灶，用三十行代码写出了一个能玩的，有颜色的贪吃蛇出来。 预览：工具：VS2013(由于有些函数移植性较差，不保证其他编译器能够运行)语言：C源代码：TCS.c123456789101112131415161718192021222324252627282930#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;conio.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;struct S&#123; int x, y; struct S n, *l; &#125;*h, *e;int _v[40][25] = &#123; &#123; 1 &#125; &#125;, d[] = &#123; 0, 1, 0, -1 &#125;, o = 0, g, l = 1, L = 3, x = 1, r; HANDLE u;#define v(_w) (_v[((struct S*)_w)-&gt;x][((struct S*)_w)-&gt;y])#define p(_w,_x,_y,_z) WriteConsoleOutputCharacter(u,_z,2,(COORD)&#123;(_x==-1?((struct S*)_w)-&gt;x:_x)*2,_y==-1?((struct S*)_w)-&gt;y:_y&#125;,(LPDWORD)&amp;r)int f(int i, int j, int k)&#123; for (i = k % 40, j = k % 25, k = 1200; ((i &gt;= 40 ? i = 0, j &gt;= 25 ? j = 0 : j++ : 1), _v[i][j]) &amp;&amp; k; i++, k--); return k ? p(0, i, j, "★"), _v[i][j] = 1 : (o = 1);&#125;int m(int dir)&#123; struct S *k = (struct S*)malloc(sizeof(struct S)); k-&gt;x = h-&gt;x + d[dir], k-&gt;y = h-&gt;y + d[(dir + 3) % 4], k-&gt;n = h, h-&gt;l = k, h = k, v(e) = 0, p(e, -1, -1, " "); if (k-&gt;x&lt;0 || k-&gt;x&gt;39 || k-&gt;y&lt;0 || k-&gt;y&gt;24 || v(h) == 2)return p(e, -1, -1, "□"), o = 2, 0; if ((p(h, -1, -1, "■"), p(h-&gt;n, -1, -1, "□"), v(h) == 1) &amp;&amp; f(0, 0, rand() % 10000) || x)return v(h) = v(e) = 2, p(e, -1, -1, "□"), 1; return v(h) = 2, free((e = e-&gt;l)-&gt;n), (int)(e-&gt;n = 0);&#125;int main()&#123; system("color 3e"), SetConsoleScreenBufferSize(u = GetStdHandle(STD_OUTPUT_HANDLE), (COORD)&#123; 80, 25 &#125;), SetConsoleCursorInfo(u, &amp;(CONSOLE_CURSOR_INFO)&#123;30, 0&#125;); system("mode con cols=80 lines=25"),h = (struct S*)malloc(sizeof(struct S)), h-&gt;x = h-&gt;y = 0, h-&gt;n = 0, e = h, srand((unsigned)time(NULL)), m(1), m(1), f(0, 0, rand() % 10000); for (x = 0; !o; Sleep(100))switch (_kbhit() ? (g = _getch()) == 224 ? _getch() : g : 0)&#123; case 119:case 87:case 72:L += m(l != 2 ? l = 0 : l); break; case 100:case 68:case 77:L += m(l != 3 ? l = 1 : l); break; case 115:case 83:case 80:L += m(l != 0 ? l = 2 : l); break; case 97:case 65:case 75:L += m(l != 1 ? l = 3 : l); break; default:L += m(l); &#125; sprintf((char*)_v, "%s，总长 %d 个单位", o - 1 ? "你输了" : "你赢了", L), MessageBox(NULL, TEXT((char*)_v), "游戏结束", 0x1040);&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用C语言写一个简易的截屏程序]]></title>
    <url>%2F2018%2F06%2F13%2F</url>
    <content type="text"><![CDATA[某天当我写完了鼠标连点器之后，鹏哥问我能不能写个截屏工具出来 然而事情没这么简单，随后鹏哥向我展示了他声称找了很久的截屏小工具：当时我的表情： &gt; _ &lt; 这..我可不包UI设计啊，还有我只是个刚学会一点C皮毛的纯新手…只好回去百度我需要的相关接口了思路截取屏幕，怎么截，截哪里，怎么存，存哪里，都是问题于是一脸纠结的我理所当然的选择了最好存的图片格式：Bitmap位图，就是.bmp格式的图片，它的特征特别明显：容易存容易读，就是占用空间大。然后就是怎么截，不管怎么截，我产生一个全屏幕窗口设备描述表的兼容位图总是没错的，你要截全屏我就都存到文件，你要截一部分我就在上面划那个一部分给你再存也就完事了至于截哪里的问题，我本来想模仿qq截图来着，但是人家是按下快捷键后已经截取了全屏，然后让你用鼠标操作…（你懂得，我这菜鸟哪懂这样要怎么实现嘛），那我想，那我就退而求其次。利用鼠标的实时位置以及按键触发来确定你的截图起始位置，这样也算是能够以相对简单的方式实现了（我想你应该不会想用直接输入你想从哪个像素开始到哪个像素结束的方式来截一个图吧）。存到哪里这个问题倒是好解决，我在c盘下创建一个专门存放截屏的目录，然后对每个截屏都取一个独一无二的名字这样就解决了存哪里的问题 源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wtypes.h&gt;#include &lt;tchar.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;//#include&lt;afx.h&gt;//默认储存路径char path[260] = "c:/shots/";//设置文件名称char* setname(char* p)&#123; //strcat(p, "-"); //strcat(p, __DATE__); char * ret = p; while (*p) &#123; if (*p == ':' || *p == ' '||*p == '\n')*p = '-'; p++; &#125; *(p - 1) = 0; strcat(ret, ".bmp"); return ret;&#125;//设置打印位置void CaptureScreen(int x1, int y1, int x2, int y2)&#123; time_t lt = time(NULL); char p[100] = &#123;0&#125;; char name[100] = &#123;0&#125;; int t = 0; strcpy(p, ctime(&amp;lt)); setname(p); sprintf(name, "%s%s",path,p); printf("保存至:\n%s",name); //system("pause"); if (x2 &lt; x1) &#123; t = x2; x2 = x1; x1 = t; &#125; if (y2 &lt; y1) &#123; t = y2; y2 = y1; y1 = t; &#125; //获得桌面窗口句柄 HWND hDesktopWnd = GetDesktopWindow(); //获得桌面窗口设备环境 HDC hDesktopDC = GetDC(hDesktopWnd); //产生全屏幕窗口设备描述表的兼容设备环境 HDC hCaptureDC = CreateCompatibleDC(hDesktopDC); //产生全屏幕窗口设备描述表的兼容位图 HBITMAP hCaptureBitmap = CreateCompatibleBitmap(hDesktopDC, x2, y2); printf("\n宽度:%d\n高度:%d\n", x2 - x1, y2 - y1); //system("pause"); //将兼容位图选入兼容设备环境 SelectObject(hCaptureDC, hCaptureBitmap); //将全屏幕窗口位图的象素数据拷贝到兼容设备描述表 BitBlt(hCaptureDC, 0, 0, x2-x1, y2-y1, hDesktopDC, x1, y1, SRCCOPY); BITMAPINFO bi; void *pBits = NULL; ZeroMemory(&amp;bi, sizeof(bi)); bi.bmiHeader.biSize = sizeof(bi.bmiHeader); bi.bmiHeader.biHeight = (y2 - y1); bi.bmiHeader.biWidth = (x2 - x1); bi.bmiHeader.biPlanes = 1; bi.bmiHeader.biBitCount = 24; bi.bmiHeader.biCompression = BI_RGB; bi.bmiHeader.biSizeImage = 3 * (y2 - y1)*(x2 - x1); //产生位图兼容设备描述表 //DECLARE_HANDLE(HDC); HDC hBmpFileDC = CreateCompatibleDC(hDesktopDC); //产生位图兼容位图 HBITMAP hBmpFileBitmap = CreateDIBSection(hDesktopDC, &amp;bi, DIB_RGB_COLORS, &amp;pBits, NULL, 0); //将兼容位图选入兼设备描述表容设备描述表 SelectObject(hBmpFileDC, hBmpFileBitmap); //将捕获的位图的象素拷贝到位图设备环境 BitBlt(hBmpFileDC, 0, 0, x2 - x1, y2 - y1, hCaptureDC, 0, 0, SRCCOPY); //创建文件 typedef void * HANDLE; HANDLE hFile = CreateFile(name, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); //保存位图文件 if (hFile != INVALID_HANDLE_VALUE) &#123; DWORD dwRet = 0; BITMAPFILEHEADER bmfHeader; ZeroMemory(&amp;bmfHeader, sizeof(bmfHeader)); bmfHeader.bfOffBits = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER); bmfHeader.bfSize = bi.bmiHeader.biSizeImage + bmfHeader.bfOffBits; bmfHeader.bfType = 'MB'; //写入位图信息头 WriteFile(hFile, &amp;bmfHeader, sizeof(bmfHeader), &amp;dwRet, NULL); //写入位图尺寸颜色表等信息 WriteFile(hFile, &amp;bi.bmiHeader, sizeof(bi.bmiHeader), &amp;dwRet, NULL); //写入位图数据块 WriteFile(hFile, pBits, bi.bmiHeader.biSizeImage, &amp;dwRet, NULL); //剪切板操作，当前有兼容性问题，故注释，正在解决 ////写入剪切板 //if (OpenClipboard(NULL) &amp;&amp; EmptyClipboard()) //&#123; // SetClipboardData(CF_BITMAP, hFile); //&#125; //CloseClipboard(); CloseHandle(hFile); &#125; DeleteDC(hBmpFileDC); DeleteObject(hBmpFileBitmap); ReleaseDC(hDesktopWnd, hDesktopDC); DeleteDC(hCaptureDC); DeleteObject(hCaptureBitmap);&#125;void Pos(int x, int y)&#123; COORD pos; HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput, pos);&#125;void printpos(int *x, int* y,int z)&#123; long zx = -1; long zy = -1; POINT ptB = &#123; 0, 0 &#125;; //typedef struct tagPOINT //&#123; //LONG x; //LONG y; //&#125; POINT, * PPOINT, NEAR * NPPOINT, FAR * LPPOINT; while (1) &#123; LPPOINT xy = &amp;ptB; //位置变量 GetCursorPos(xy); //获取鼠标当前位置 //如果鼠标移动，（即当前的坐标改变则打印出坐标）打印出做坐标。 if ((zx != xy-&gt;x) || (zy != xy-&gt;y)) &#123; Pos(0, z); printf("x=%4d,y=%4d\n", xy-&gt;x*1920/1536, xy-&gt;y*1080/864); zx = xy-&gt;x; zy = xy-&gt;y; &#125; if (GetAsyncKeyState('Q')&amp;&amp;GetAsyncKeyState( VK_CONTROL)) &#123; ShowWindow(FindWindow(NULL, _T("shot")), SW_MINIMIZE); Sleep(500); CaptureScreen(0, 0, 1920, 1080); break; &#125; if (GetAsyncKeyState(VK_SPACE)) &#123; //若打印出来的坐标超过1920 1080请将下面的乘除操作去掉 *x = xy-&gt;x*1920/1536; *y = xy-&gt;y*1080/864; break; &#125; &#125;&#125;char * change(char*p)&#123; char*ret = p; while (*p) &#123; if (*p == '/') *p = '\\'; p++; &#125; if (*(p - 1) != '\\')strcat(p-1, "\\"); return ret;&#125;int main()&#123; int i = 0; int x1, x2, y1, y2; char c = 0; char cpath[270] = &#123; 0 &#125;; //改变窗口名称，方便进行最小化 system("title shot"); //修改窗口大小 system("mode con cols=40 lines=10"); printf("是否改变储存路径？(y/n)"); scanf("%c", &amp;c); if (c == 'y') &#123; system("cls"); printf("请输入新路径:\n$ "); scanf("%s", path); change(path); &#125; sprintf(cpath, "md %s", path); //创建相应路径，如果已经存在也没事 system(cpath); system("cls"); Pos(0, 9); printf("按下Ctrl+Q截取全屏\n按下Ctrl+W进入截屏"); while (1) &#123; Pos(0, 0); if (GetAsyncKeyState('Q') &amp;&amp; GetAsyncKeyState(VK_CONTROL)) &#123; i = 0; while (i &lt; 8) &#123; Pos(0, i++); printf(" "); &#125; Pos(0, 0); ShowWindow(FindWindow(NULL, _T("shot")), SW_MINIMIZE); Sleep(500); CaptureScreen(0, 0, 1920, 1080); &#125; if (GetAsyncKeyState(VK_CONTROL) &amp;&amp; GetAsyncKeyState('W')) &#123; i = 0; while (i &lt; 8) &#123; Pos(0, i++); printf(" "); &#125; Pos(0, 0); printf("按下空格选取截图起点\n"); printpos(&amp;x1, &amp;y1, 1); Sleep(300); printf("按下空格选取截图终点\n"); printpos(&amp;x2, &amp;y2, 3); CaptureScreen(x1, y1, x2, y2); i = 0; //if (GetAsyncKeyState(VK_ESCAPE)) //break; &#125; &#125; return 0;&#125; 这样我们的截屏工具就做好了，它在前台运行时使用截全屏会自动隐藏，这样不会截到自己（就不会挡住一些东西）当然也可以后台运行，你只要记住快捷键就好了！刚进入程序时不想改变默认路径可以直接回车，想改变的话就按提示操作吧~]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next之给博客加上萌妹子或者萌宠]]></title>
    <url>%2F2018%2F06%2F08%2F</url>
    <content type="text"><![CDATA[今天我将详细说明如何在自己的博客里加入萌宠或者萌妹子工具:1.hexo+git pages搭建的博客2.live2d资源包 获取在博客站点路径git bash here然后输入以下代码让你获得相关的支持1npm install --save hexo-helper-live2d 然后就是看下面的图片选择你喜欢的注：角色图片不全，因为作者是不断更新的，建议直接访问作者的git仓库找更多角色地址：https://github.com/xiazeyu/live2d-widget-models然后记住你的角色名 输入下面的代码1npm install live2d-widget-model-你选的角色名 就获取完毕了 配置在站点的 _ config.yml 下配置1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-你选的角色名 display: position: right width: 150 height: 300 mobile: show: false 上面的mobile选项决定是否在手机上展示动漫形象我的建议是不要开启，会挡住屏幕当然你如果一定要开，把show改为true即可]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现鼠标连点器]]></title>
    <url>%2F2018%2F06%2F07%2F</url>
    <content type="text"><![CDATA[今天我们实现一个鼠标连点器，点击位置，点击间隔，点击次数，点击左键还是右键，双击还是单击都可以自定义工具：VS2013语言：C 有天看见同学在淘宝上抢购一款智能手表，原价169元才卖1.69元，可惜数量有限，没想到他们等了很久开始抢，一秒钟不到就被抢光了，我在旁边看着都能感受到他们的心碎。回到宿舍，我想：无非就是拼手速，为何我不做一个鼠标快速连点器呢？这样一秒钟点一百下，我就不信抢不到！于是，我回去开始写起了代码： 头文件click.h1234567891011121314151617#pragma once#include &lt;tchar.h&gt;#include&lt;stdio.h&gt;//#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include &lt;afxwin.h&gt;#define clt CLK_TCKvoid Pos(int x,int y);int prints(char*, int);int getMapArray(char *mapname, unsigned char *maparray, int* mapwidth, int* mapheight);unsigned int printimg(char* argv);int move(int x, int y);int click(int type, int double_click);int clicks(int type, int double_click, int time, int count, int px, int py);void printpos(int *x,int *y); 源文件mouse.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define _CRT_SECURE_NO_WARNINGS#include "click.h"//const int MOUSEEVENTF_MOVE = 0x0001; //移动鼠标//const int MOUSEEVENTF_LEFTDOWN = 0x0002; //模拟鼠标左键按下//const int MOUSEEVENTF_LEFTUP = 0x0004; //模拟鼠标左键抬起//const int MOUSEEVENTF_RIGHTDOWN = 0x0008; //模拟鼠标右键按下//const int MOUSEEVENTF_RIGHTUP = 0x0010; //模拟鼠标右键抬起//const int MOUSEEVENTF_MIDDLEDOWN = 0x0020;//模拟鼠标中键按下//const int MOUSEEVENTF_MIDDLEUP = 0x0040; //模拟鼠标中键抬起//const int MOUSEEVENTF_ABSOLUTE = 0x8000; //标示是否采用绝对坐标/** mouse move* x -- int, x-coordinate* y -- int, y-coordinate*///打印坐标void printpos(int *x, int* y)&#123; long zx = -1; long zy = -1; POINT ptB = &#123; 0, 0 &#125;; /* typedef struct tagPOINT &#123; LONG x; LONG y; &#125; POINT, * PPOINT, NEAR * NPPOINT, FAR * LPPOINT; */ while (1) &#123; LPPOINT xy = &amp;ptB; //位置变量 GetCursorPos(xy); //获取鼠标当前位置 //如果鼠标移动，（即当前的坐标改变则打印出坐标）打印出做坐标。 if ((zx != xy-&gt;x) || (zy != xy-&gt;y)) &#123; Pos(0, 2); printf("x=%4d,y=%4d\n", xy-&gt;x, xy-&gt;y); zx = xy-&gt;x; zy = xy-&gt;y; &#125; if (GetAsyncKeyState(VK_ESCAPE)) &#123; *x = xy-&gt;x; *y = xy-&gt;y; break; &#125; &#125;&#125;//设置打印位置void Pos(int x, int y)&#123; COORD pos; HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput, pos);&#125;//鼠标移动int move(int x, int y)&#123; typedef BOOL(WINAPI *Fun1)(int x, int y); //#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name //DECLARE_HANDLE(HINSTANCE); HINSTANCE hDll; hDll = LoadLibrary("user32.dll"); if (NULL == hDll) &#123; fprintf(stderr, "load dll 'user32.dll' fail."); return -1; &#125; Fun1 SetCursorPos = (Fun1)GetProcAddress(hDll, "SetCursorPos"); if (NULL == SetCursorPos) &#123; fprintf(stderr, "call function 'SetCursorPos' fail."); FreeLibrary(hDll); return -1; &#125; SetCursorPos(x, y); FreeLibrary(hDll); return 0;&#125;/** mouse click* type -- int, 0:left click;1:right click* double_click -- bool, true:double click; false: single click*///鼠标点击int clicks(int type, int double_click, int time, int count, int px, int py)&#123; int t = 0; while (1) &#123; move(px, py); Sleep(time); click(type, double_click); count--; t++; if (!count)break; if (GetAsyncKeyState(VK_ESCAPE)) break; &#125; return t;&#125;int click(int type, int double_click)&#123; int left_click = MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP; int right_click = MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_RIGHTUP; int clicktype; HINSTANCE hDll; typedef void(WINAPI*Fun2) ( //typedef unsigned long DWORD; DWORD dwFlags, // motion and click options DWORD dx, // horizontal position or change DWORD dy, // vertical position or change DWORD dwData, // wheel movement //typedef unsigned long _win64 *ULONG_PTR ULONG_PTR dwExtraInfo // application-defined information ); hDll = LoadLibrary("user32.dll"); if (NULL == hDll) &#123; fprintf(stderr, "load dll 'user32.dll' fail."); return -1; &#125; Fun2 mouse_event = (Fun2)GetProcAddress(hDll, "mouse_event"); if (NULL == mouse_event) &#123; fprintf(stderr, "call function 'mouse_event' fail."); FreeLibrary(hDll); return -1; &#125; if (type == 0) clicktype = left_click; else clicktype = right_click; mouse_event(clicktype, 0, 0, 0, 0); FreeLibrary(hDll); if (double_click) click(type, 0); return 0;&#125; laindian.cpp123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS#include "click.h"int main()&#123; int x, y, count; int time; int dou = 0; int lef = 0; int sum = 0; char mess[250]; printf("欢迎使用鼠标连点器！\n按下ESC确认坐标："); printpos(&amp;x,&amp;y); printf("请输入延时(毫秒)和点击次数(0表示无限,随时可以按下ESC来中断点击):"); scanf("%d %d", &amp;time, &amp;count); printf("十秒后开始点击！"); Sleep(10000); sum = clicks(lef, dou, time, count, x, y); wsprintf(mess, _T("%s\n%s%d%s"), _T("点击完毕"), _T("共点击:"), sum, _T("次")); MessageBox(0, mess, _T("点击结束"), MB_OK); return 0; &#125; 这样写完代码之后，记得把项目-属性-配置属性-常规-项目默认值-MFC的使用改为在共享 DLL 中使用 MFC就完全搞定了！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言小项目之注释转换C->Cpp]]></title>
    <url>%2F2018%2F06%2F06%2F</url>
    <content type="text"><![CDATA[今天我们来实现一下C语言经典小项目：注释转换，并且利用命令行参数，对某个文件夹及所有子文件夹里的对应文件进行注释转换，无关文件进行复制操作，形成一个经过处理的新文件夹。 注释转换基本思路 转换方法先分析如下图：（字符串状态因为处理简单没有画出）由图可以看出，将注释转换过程分为四种状态，NULL_STATE(无注释状态)、C_STATE(C语言注释状态)、CPP_STATE(C++注释状态)、END_STATE(文件结束状态)，通过四种状态的相互切换实现注释的转换，具体实现过程为：用文件的方式中函数fopen打开源文件input.c,并进行读操作，打开output.c文件，进行注释转换后的写操作，转换过程中调用函数CommentConvert(pfIn,pfOut)转换，先在NULL_STATE状态下用函数fgetc函数读取第一个字符，若为’/‘,再读取第二个字符，若为’ * ‘则切换到C_STATE状态实现，若第二个字符为’/‘,则切换到CPP_STATE状态实现，如此一直相互切换，并在各自状态具体代码实现下用fputc函数输出转换为C++注释和各个原字符，直至遇到EOF,状态切换为end_state.而在C语言注释下遇到的注释情况如下: 12345678910111213141516171819202122232425262728293031323334// 1.一般情况int num = 0;/* int i = 0; */// 2.换行问题/* int i = 0; */int j = 0;/* int i = 0; */int j = 0;// 3.匹配问题/*int i = 0;/*xxxxx*/// 4.多行注释问题/*int i=0;int j = 0;int k = 0;*/int k = 0;// 5.连续注释问题/**//**/// 6.连续的**/问题/***/// 7.C++注释问题// /*xxxxxxxxxxxx*/// 8.字符串注释问题char* p = "/*/////////////////adfasdfas";/* char* q = "/////"*/// char* x = "/**////**///"// 根据状态机和我们可能遇到的状况，我们开始写代码： 头文件ctocpp.h1234567891011121314151617181920212223#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define INPUTFILENAME "in.c"#define OUTPUTFILENAME "out.c"typedef enum CONVERT_START//枚举表示操作选项&#123; NULL_START, C_START, CPP_START, END_START, STR_START&#125;StateType;void CommentConvert();void ConvertWork(FILE* read, FILE* write);//注释转换操作选项函数void DoCState(FILE* read, FILE* write);//C 转换为 cpp函数void DoNullState(FILE* read, FILE* write);//普通语句空转换函数void DoCppState(FILE* read, FILE* write);//cpp 转换函数void DOStrState(FILE* read, FILE* write);//字符串状态 源文件test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#define _CRT_SECURE_NO_WARNINGS#include"ctocpp.h"#include &lt;windows.h&gt; #include &lt;stdio.h&gt; char newd[1000];char path[1000];char newout[1000];void enum_path(char *cpath)&#123; //typedef struct _WIN32_FIND_DATAA &#123; //DWORD dwFileAttributes; /*typedef unsigned long DWORD;*/ //FILETIME ftCreationTime; //FILETIME ftLastAccessTime; //FILETIME ftLastWriteTime; /*typedef struct _FILETIME &#123; DWORD dwLowDateTime; DWORD dwHighDateTime; &#125; FILETIME*/ //DWORD nFileSizeHigh; //DWORD nFileSizeLow; //DWORD dwReserved0; //DWORD dwReserved1; // CHAR cFileName[MAX_PATH]; // CHAR cAlternateFileName[14]; //&#125; WIN32_FIND_DATAA //typedef WIN32_FIND_DATAA WIN32_FIND_DATA //上面是WIN32_FIND_DATA的定义，其实就是类似于 FILE 型，是一种文件流类型 WIN32_FIND_DATA wfd; //HANDLE 实际上就是void * HANDLE hfd; char cdir[MAX_PATH]; char subdir[MAX_PATH]; int r; //接收当前目录字符串的缓冲区指针。cdir字符串指定当前目录的绝对路径。 GetCurrentDirectory(MAX_PATH, cdir); SetCurrentDirectory(cpath);//更改当前进程的当前目录。 //*是通配符，此函数在当前目录下寻找形如xxxx.xxxx的文件 //（就是查找所有文件了....并且如果有文件(夹)的话必定找到第一个） hfd = FindFirstFile("*.*", &amp;wfd); //#define INVALID_HANDLE_VALUE ((HANDLE)(long)-1)这个是查找文件失败的返回值 if (hfd != INVALID_HANDLE_VALUE) &#123; //上面的if语句的意思就是只要找到任何文件(夹)就进行如下循环 do &#123; if (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)//#define FILE_ATTRIBUTE_DIRECTORY 0x00000010 &#123; //上面的if语句用来判断此次查找到的到底是文件还是文件夹 if (wfd.cFileName[0] != '.') //找到的文件名的第一个字符不是“.”的话表示这是一个文件夹，否则就是一个返回上层的接口 &#123; int len = strlen(newd); // 合成完整路径名 //找到的文件(夹)名会存放在结构体的cFileName里 sprintf(subdir, "%s\\%s", cpath, wfd.cFileName); //printf("read...%s\n", subdir); //创建相应的输出文件夹 sprintf(newd, "%s\\%s", newd, wfd.cFileName); //printf("\t\t%s....\n", newd); system(newd); // 递归枚举子目录 enum_path(subdir); //递归完毕后处理新建路径 newd[len] = '\0'; &#125; &#125; else &#123; //新文件路径 sprintf(newout, "%s\\%s", newd+3, wfd.cFileName); //printf("%s\n", newout); //待处理文件路径 sprintf(path,"%s\\%s", cpath, wfd.cFileName); //printf("%s\n", path); //是需要注释转换的文件就进行注释转换 if (strcmp(".c", path + strlen(path) - 2) == 0) CommentConvert(); else if (strcmp(".h", path + strlen(path) - 2) == 0) CommentConvert(); else if (strcmp(".cpp", path + strlen(path) - 4) == 0) CommentConvert(); else//不需要注释转换就直接复制 &#123; printf("copy %s to %s\n", path, newout);//显示复制信息 file_copy(); &#125; &#125; &#125; while (r = FindNextFile(hfd, &amp;wfd), r != 0); //和FindFirstFile类似，向下继续找所有文件(夹)，找不到就返回0 &#125; //处理完毕把工作目录更改回原来的目录以免影响其他功能（与前面的GetCurrentDirectory相呼应） SetCurrentDirectory(cdir);&#125;int main(int argc,char *argv[])&#123; printf("%d\n", argc); if (argc != 3) printf("参数有误！"); else &#123; sprintf(newd, "md %s", argv[2]); //system("md 文件夹名");创建一个文件夹，成功返回1，失败返回0并且在命令窗口可以看见 system(newd); enum_path(argv[1]); &#125; system("pause"); return 0;&#125; ctocpp.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#define _CRT_SECURE_NO_WARNINGS 1 #include"ctocpp.h" StateType state;extern char newd[1000];extern char path[1000];extern char newout[1000];void DOStrState(FILE *read, FILE *write)&#123; int first = fgetc(read); if (first == '"') state = NULL_START; else if(first == '\\')//转义字符直接输出进文件 &#123; int second = fgetc(read); fputc(first, write); fputc(second, write); return; &#125; fputc(first, write);&#125;void DoNullState(FILE *read, FILE *write)//无转换操作函数&#123; int first = fgetc(read); int second; switch (first) &#123; case '/': second = fgetc(read); if (second == '*') &#123; fputc('/', write); fputc('/', write); state = C_START;//状态改为C状态 &#125; else if (second == '/') &#123; fputc(first, write); fputc(second, write); state = CPP_START; //状态改为Cpp状态 &#125; else //普通语句就直接写入 &#123; fputc(first, write); fputc(second, write); &#125; break; case '"': fputc(first, write); state = STR_START; break; case EOF: //fputc(first, write); state = END_START;//注释结束，状态调整 break; default://普通内容直接写入 fputc(first, write); break; &#125;&#125;void DoCState(FILE *read, FILE *write)//C转换为Cpp&#123; int first = fgetc(read); int second = 0; switch (first) &#123; case '*': second = fgetc(read); if (second == '/')//舍弃 */ &#123; int third = fgetc(read); state = NULL_START; if (third != '\n') &#123; fputc('\n', write); ungetc(third, read); &#125; if (third == '\n') &#123; fputc(third, write); &#125; &#125; else &#123; fputc(first, write); ungetc(second, read);//将*之后的内容还回缓冲区 &#125; break; case '\n'://如果是换行将下一行开头加入Cpp注释 fputc(first, write); fputc('/', write); fputc('/', write); break; case EOF: //fputc(first, write); state = END_START; break; default: fputc(first, write); break; &#125;&#125;void DoCppState(FILE *read, FILE *write)//Cpp转换为无状态； &#123; int first = 0; first = fgetc(read); switch (first) &#123; case'\n'://Cpp注释的结束； fputc(first, write); state = NULL_START; break; case EOF: //fputc(first, write); state = END_START; break; default: fputc(first, write); break; &#125;&#125;void ConvertWork(FILE *read, FILE *write)//函数操作选项； &#123; state = NULL_START;//一开始无状态 while (state != END_START) &#123; switch (state) &#123; case NULL_START: DoNullState(read, write); break; case C_START: DoCState(read, write); break; case CPP_START: DoCppState(read, write); break; case STR_START: DOStrState(read, write); break; default: break; &#125; &#125;&#125;//注释转换void CommentConvert()//读写文件函数； &#123; FILE *pWrite = NULL; FILE *pRead = fopen(path, "r"); if (pRead == NULL) &#123; perror(path); //exit(EXIT_FAILURE); &#125; pWrite = fopen(newout,"w"); if (pWrite == NULL) &#123; fclose(pRead); pRead = NULL; perror(newout); //exit(EXIT_FAILURE); &#125; ConvertWork(pRead, pWrite); printf("%s转换成功\n",path); fclose(pRead); pRead = NULL; fclose(pWrite); pWrite = NULL;&#125;//文件复制void file_copy()&#123; int count = 0; char tmp[2]; FILE* write; FILE* read = fopen(path, "rb"); if (read == NULL) &#123; perror("open file for copy"); exit(1); &#125; write = fopen(newout, "wb"); if (write == NULL) &#123; perror("open file for copy source"); fclose(read); exit(1); &#125; do &#123; int judge = fread(tmp, 1, 1, read); if (!judge) &#123; break; &#125; count += fwrite(tmp,1, 1, write); &#125; while (1); printf("copy complete:total byte:%d\n",count); fclose(read); fclose(write); read = NULL; write = NULL;&#125; 这样写完之后，我们在预处理这里写上命令行参数：运行程序，就会在我后面参数的位置生成一个文件夹，里面包括原来文件夹的所有文件（包括隐藏文件），并且所有的.c，.h，.cpp文件都是经过注释转换的了上面的查找文件夹使用了鹏哥推荐的win32 api有兴趣的朋友可以查一查相关资料，绝对会使你受益匪浅。]]></content>
      <categories>
        <category>C语言</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现三子棋(井字棋)游戏]]></title>
    <url>%2F2018%2F06%2F04%2F</url>
    <content type="text"><![CDATA[今天我们实现一个C语言做的井字棋游戏，并且给这个游戏加上些难度，让你不是那么好赢（甚至赢不了）语言：C语言工具：VS2013 头文件game.h123456789101112131415161718192021#ifndef __GAME_H__#define __GAME_H__#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;windows.h&gt; #include&lt;time.h&gt; #include&lt;string.h&gt; #define ROW 3 #define LIN 3 void game();void menu(); void initboard(char arr[ROW][LIN], int row, int lin); void checkboard(char arr[ROW][LIN], int row, int lin); void player_go(char arr[ROW][LIN], int row, int lin); void pc_go(char arr[ROW][LIN], int row, int lin, int nan); int is_full(char arr[ROW][LIN], int row, int lin); char is_win(char arr[ROW][LIN], int row, int lin);#endif //game.h 源文件test.c12345678910111213141516171819#include "game.h" int main() &#123; int input=0; do&#123; menu(); printf("请选择： \n"); scanf_s("%d", &amp;input); switch (input) &#123; case 1: game(); break; case 0: exit(0); break; default: printf("请重新输入\n"); break; &#125; &#125; while (1); &#125; game.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350#include "game.h" void game() &#123; int input; char ret; char arr[ROW][LIN] ; while(1) &#123; system("cls"); initboard(arr, ROW, LIN); printf("**************************************\n"); printf("* *\n"); printf("*请选择难度：1.简单 2.困难 3.大师*\n"); printf("* *\n"); printf("**************************************\n"); scanf("%d",&amp;input); if (input&gt;3 || input&lt;1) &#123; printf("输入错误！重新输入！"); Sleep(500); &#125; else break; &#125; system("cls"); printf("\n"); checkboard(arr, ROW, LIN); srand((unsigned int)time(NULL)); do &#123; player_go(arr, ROW, LIN); //system("cls"); checkboard(arr, ROW, LIN); ret = is_win(arr, ROW, LIN); if (ret != ' ') &#123; break; &#125; Sleep(1000); system("cls"); pc_go(arr, ROW, LIN, input); checkboard(arr, ROW, LIN); ret = is_win(arr, ROW, LIN); if (ret != ' ') &#123; break; &#125; &#125; while (1); if (ret == 'X') &#123; printf("你赢了！\n"); system("pause"); system("cls"); &#125; else if (ret == 'O') &#123; printf("你输了！\n"); system("pause"); system("cls"); &#125; else if (ret == 'f') &#123; printf("平局！\n"); system("pause"); system("cls"); &#125; &#125;void menu() &#123; printf("\n 三子棋 \n\n"); printf("***********************\n"); printf("***** 1.开始游戏 *****\n"); printf("***** 0.退出游戏 *****\n"); printf("***********************\n");&#125; void initboard(char arr[][LIN], int row,int lin)//初始化棋盘&#123; memset(arr, ' ', sizeof(arr[0][0])* lin*row);&#125;void checkboard(char arr[][LIN], int row, int lin)//打印棋盘&#123; int i = 0; int j = 0; for (i=0; i&lt;row; i++) &#123; for(j=0; j&lt;lin; j++) &#123; printf(" %c ", arr[i][j]); if(j &lt; lin-1) printf("|"); else printf("\n"); &#125; if (i &lt; row-1) &#123; for(j=0; j&lt;lin; j++) &#123; printf("---"); if(j &lt; lin-1) printf("|"); else printf("\n"); &#125; &#125; &#125; printf("\n");&#125; void player_go(char arr[][LIN], int row, int lin)//玩家走&#123; int i, j, input; while(1) &#123; printf("请你落子(1-9): \n"); //scanf_s("%d %d", &amp;i, &amp;j); scanf("%d",&amp;input); i = (input+2)/3; j = (input%3 == 0)? 3:input%3; if (i &gt;=1 &amp;&amp; i &lt;= row&amp;&amp;j &gt;=1 &amp;&amp; j &lt;= lin) &#123; if (arr[i - 1][j - 1] ==' ') &#123; arr[i - 1][j - 1] = 'X'; break; &#125; else &#123; printf("已经有子了！\n"); &#125; &#125; else &#123; printf("错误落子，请重新落子\n"); &#125; &#125; //system("cls");&#125; void pc_go(char arr[][LIN], int row, int lin, int nan)//电脑走 &#123; int i, j, count; int sig = 0; int i2 = 6, j2 = 6; int m = 0; int n = 0; count = 0; printf("电脑思考中"); Sleep(200); printf("."); Sleep(200); printf("."); Sleep(200); printf(".\n电脑落子：\n"); switch(nan) &#123; //难度1 case 1: do &#123; i = rand() % row; j = rand() % lin; if (arr[i][j] == ' ') &#123; arr[i][j] = 'O'; break; &#125; &#125; while (1); break; //难度二 case 2: count = 1; if(arr[1][1] == ' ') &#123; arr[1][1] = 'O'; goto done2; &#125;nan2: for(i=0; i&lt;row; i++) &#123; n = 0; m = 0; for(j=0; j&lt;lin; j++) &#123; m += arr[i][j];//行 n += arr[j][i];//列 &#125; if(m == 'O'*2 + ' ') &#123; for(j=0; j&lt;lin; j++) &#123; if(arr[i][j] == ' ') &#123; arr[i][j] = 'O'; goto done2; &#125; &#125; &#125; if(m == 'X'*2 + ' ') &#123; sig++; i2 = i; &#125; if(n == 'O'*2 + ' ') &#123; for(j=0; j&lt;row; j++) &#123; if(arr[j][i] == ' ') &#123; arr[j][i] = 'O'; goto done2; &#125; &#125; &#125; if(n == 'X'*2 + ' ') &#123; sig++; j2 = i; &#125; &#125;//这里确定电脑不能一步下赢，开始阻拦玩家 if(sig) &#123; if(i2 &lt; row) &#123; for(j=0; j&lt;lin; j++) &#123; if(arr[i2][j] == ' ') &#123; arr[i2][j] = 'O'; goto done2; &#125; &#125; &#125; else &#123; for(j=0; j&lt;row; j++) &#123; if(arr[j][j2] == ' ') &#123; arr[j][j2] = 'O'; goto done2; &#125; &#125; &#125; &#125;//行列判定over if(arr[0][0]+arr[1][1]+arr[2][2] == 'O'*2 + ' '||arr[0][0]+arr[1][1]+arr[2][2] == 'X'*2 + ' ') &#123; for(i=0; i&lt;lin; i++) &#123; if(arr[i][i] == ' ') &#123; arr[i][i] = 'O'; goto done2; &#125; &#125; &#125; if(arr[2][0]+arr[1][1]+arr[0][2] == 'O'*2 + ' '||arr[2][0]+arr[1][1]+arr[0][2] == 'X'*2 + ' ') &#123; for(j=0; j&lt;row; j++) &#123; if(arr[row-j-1][j] == ' ') &#123; arr[row-j-1][j] = 'O'; goto done2; &#125; &#125; &#125;//斜 do &#123; i = rand() % row; j = rand() % lin; if (arr[i][j] == ' ') &#123; arr[i][j] = 'O'; goto done2; &#125; &#125; while (1);done2: break; //难度三 case 3: if(arr[1][1] == ' ') &#123; arr[1][1] = 'O'; &#125; else &#123; for(i=0; i&lt;row; i++) &#123; for(j=0; j&lt;lin; j++) &#123; count += arr[i][j]; &#125; &#125; if((count == 'X'+ 8*' ') &amp;&amp; arr[1][1] == 'X') &#123; arr[0][0] = 'O'; &#125; else if((count == 'X'*2 + 'O'*1 + ' '*6) &amp;&amp; arr[1][1] == 'X' &amp;&amp; arr[2][2] == 'X') &#123; arr[0][2] = 'O'; &#125; else if((count == 'X'*2 + 'O'*1 + ' '*6) &amp;&amp; arr[1][1] == 'O' &amp;&amp; (arr[0][0] == 'X' &amp;&amp; arr[2][2] == 'X')||(arr[2][0] == 'X' &amp;&amp; arr[0][2] == 'X')) &#123; arr[0][1] = 'O'; &#125; else goto nan2; &#125; break; &#125; //system("cls");&#125; int is_full(char arr[][LIN], int row, int lin)//判断棋盘是否为满 &#123; int i=0, j=0; for (i=0; i&lt;row; i++) &#123; for (j=0; j&lt;lin; j++) &#123; if (arr[i][j] == ' ') return 0; &#125; &#125; return 1;&#125; char is_win(char arr[][LIN], int row, int lin)//判断输赢 &#123; int i = 0, j = 0; for (i=0; i&lt;row; i++) &#123; if ((arr[i][0] == arr[i][1])&amp;&amp;( arr[i][1] == arr[i][2] )&amp;&amp; arr[i][1] != ' ') //判断行 &#123; return arr[i][1]; &#125; &#125; for (j=0; j&lt;lin; j++) //判断列 &#123; if ((arr[0][j] == arr[1][j] ) &amp;&amp; ( arr[1][j] == arr[2][j]) &amp;&amp; arr[1][j] != ' ') &#123; return arr[1][j]; &#125; &#125; if ((arr[0][0] == arr[1][1] ) &amp;&amp; (arr[1][1] == arr[2][2]) &amp;&amp; arr[1][1] != ' ') //判断斜列 &#123; return arr[1][1]; &#125; else if( (arr[0][2] == arr[1][1]) &amp;&amp; ( arr[1][1] == arr[2][0]) &amp;&amp; arr[1][1] != ' ') &#123; return arr[1][1]; &#125; else if (is_full(arr,row,lin)) &#123; return 'f'; &#125; else return ' '; &#125; 我设定了三个难度，其中那个最高难度，我的设定是赢不了电脑的，不信的同学可以试试，如果你下赢了，请接受我的敬佩哦…..]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现扫雷游戏]]></title>
    <url>%2F2018%2F06%2F02%2F</url>
    <content type="text"><![CDATA[今天我们使用C语言简单实现一下经典游戏：扫雷在开始之前我们先看一下效果：接下来上代码： 头文件game.h12345678910111213141516171819202122232425#ifndef _GAME_H__ #define _GAME_H__ #define COL 10 #define ROW 10 #define COLS COL+2 #define ROWS ROW+2 #define clt CLK_TCK #define MAX_L 45#define MAX_C 30#include&lt;windows.h&gt; #include&lt;time.h&gt; #include&lt;stdio.h&gt;void game();void start_show();void init_mine(int mine[ROWS][COLS], int rows, int cols,int count); void init_show(char show[ROWS][COLS], int rows, int cols); void printmine(int mine[ROWS][COLS], int row, int col); void printshow(char show[ROWS][COLS], int row, int col); void jump_mine(int mine[ROWS][COLS], int x, int y, int row, int col);void clearmine(int mine[ROWS][COLS],char show[ROWS][COLS], int x, int y,int row,int col);int sweep_mine(int mine[ROWS][COLS], char show[ROWS][COLS], int row, int col, int count, int countsao); int is_win(char show[ROWS][COLS], int row, int col,int count);void menu(); int select_mode(); #endif 源文件game.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502#define _CRT_SECURE_NO_WARNINGS#include "Game.h" void game() &#123; unsigned int C1 = clock(); //char p[50]; int x = 0; int y = 0; int countsao = 0; int mine[ROWS][COLS] = &#123;0&#125;; char show[ROWS][COLS] = &#123;0&#125;; int count = 0; int win = 1; int C2; count = select_mode(); init_mine(mine, ROWS, COLS, count); init_show(show, ROWS, COLS); //sprintf((char *)p, "mode con cols=%d lines=%d", MAX_L, MAX_C); //system((const char*)p); while (win) &#123; system("cls"); printshow(show, ROW, COL); //printmine(mine, ROW, COL); countsao++; win = sweep_mine(mine, show, ROW, COL, count, countsao); if (x = is_win(show, ROW, COL, count)) &#123; system("cls"); C2 = clock(); printf("\n恭喜你排完了所有的雷!\t\t用时：%d秒\n",(C2-C1)/clt); break; &#125; &#125; //printshow(show, ROW, COL);//扫雷界面 printmine(mine, ROW, COL);//雷信息 if(!x) &#123; printf("\t\t****** * ******* ****** ******* * * ****** ****** **\n"); printf("\t\t* * * * * * * * * * * * * * **\n"); printf("\t\t* *** ***** * * * ****** * * * * ****** ****** **\n"); printf("\t\t* * * * * * * * * * * * * * * \n"); printf("\t\t****** * * * * ****** ******* * ****** * ** **\n"); &#125;&#125;void start_show()&#123; int i, j; printf("loading."); for(i=0; i&lt;5; i++) &#123; Sleep(200); printf("."); &#125; system("cls"); for(i=0; i&lt;30; i++) &#123; system("cls"); Sleep(1); for(j=0; j&lt;i; j++) &#123; printf("\n"); &#125; printf("************************************************************************************************************************"); &#125; for(; i&gt;0; i--) &#123; system("cls"); Sleep(1); for(j=0; j&lt;i; j++) &#123; printf("\n"); &#125; printf("************************************************************************************************************************"); &#125; system("cls");&#125;void menu() &#123; printf("\t\t\t\t 欢迎来到扫雷世界! \n"); printf("\n\n\t\t\t\t***********************************\n"); printf("\t\t\t\t*********** 1.开始 ************\n"); printf("\t\t\t\t***********************************\n"); printf("\t\t\t\t*********** 0.退出 ************\n"); printf("\t\t\t\t***********************************\n"); &#125; int select_mode() &#123; int num = 0; system("cls"); printf("\n\n\t\t\t\t**************************************\n"); printf("\t\t\t\t*1.简单 2.困难 3.大师*\n"); printf("\t\t\t\t**************************************\n"); while(1) &#123; printf("\t\t\t\t请输入选择&gt;"); scanf_s("%d", &amp;num); switch (num) &#123; case 1:return ROWS; case 2:return ROWS+ROWS/2; case 3:return ROW*3; case 99:return ROW*COL-2; case 100:return 3; default:printf("\t\t\t\t输入错误,请重新输入!\n"); &#125; &#125;&#125;void init_show(char show[ROWS][COLS], int rows, int cols) &#123; int i = 0; int j = 0; for (i = 0; i &lt; rows; i++) &#123; for (j = 0; j &lt; cols; j++) &#123; show[i][j] = '0'; &#125; &#125; &#125;void init_mine(int mine[ROWS][COLS],int rows,int cols,int count)//布雷&#123; int x = 0; int y = 0; int i = count; while (i) &#123; x = rand()%(rows -2)+1; y = rand()%(cols -2)+1; if (9 != mine[x][y]) &#123; mine[x][y] = 9; i--; if (9!=mine[x][y - 1])//周围雷数量 mine[x][y - 1]++; if (9!= mine[x][y + 1]) mine[x][y + 1]++; if (9!= mine[x - 1][y + 1]) mine[x - 1][y + 1]++; if (9 != mine[x - 1][y]) mine[x - 1][y]++; if (9 != mine[x - 1][y - 1]) mine[x - 1][y - 1]++; if (9 != mine[x + 1][y - 1]) mine[x + 1][y - 1]++; if (9 != mine[x + 1][y]) mine[x + 1][y]++; if (9 != mine[x + 1][y + 1]) mine[x + 1][y + 1]++; &#125; &#125;&#125;void printmine(int arr[ROWS][COLS], int row, int col)&#123; int i = 0; int j = 0; int k = 0; for(j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf(" %-2d|",i); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=1; i&lt;=row; i++) &#123; printf("| %-2d|",i); for (j=1; j&lt;=col; j++) &#123; if (9 == arr[i][j]) &#123; printf(" ●|"); &#125; else &#123; printf(" %-2d|", arr[i][j]); &#125; &#125; printf("\n"); for (j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); &#125; &#125; void printshow(char show[ROWS][COLS], int row, int col) &#123; int i = 0; int j = 0; for(j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf(" %-2d|",i); &#125; printf("\n"); for (i=0; i&lt;=row; i++) &#123; if(i == 0) printf("|"); printf("---+"); &#125; printf("\n"); for (i=1; i&lt;=row; i++) &#123; printf("| %-2d|", i); for (j=1; j&lt;=col; j++) &#123; if ('0'== show[i][j]) &#123; printf(" ▇|"); &#125; else if(1 == show[i][j]) &#123; printf(" ◆|"); &#125; else &#123; printf(" %2c|", show[i][j]); &#125; &#125; printf("\n"); for (j=0; j&lt;=col; j++) &#123; if(j == 0) printf("|"); printf("---+"); &#125; printf("\n"); &#125;&#125; void clearmine(int mine[ROWS][COLS],char show[ROWS][COLS], int x, int y,int row,int col)//递归判定 &#123; if (0 == mine[x][y]) &#123; show[x][y] = ' '; &#125; if (' ' != show[x - 1][y]) &#123; if (0 == mine[x - 1][y] &amp;&amp; x - 1 &gt;= 1) &#123; clearmine(mine, show, x-1, y, row, col); &#125; else &#123; show[x - 1][y] = '0' + mine[x - 1][y]; &#125; &#125; if (' ' != show[x + 1][y]) &#123; if (0 == mine[x + 1][y] &amp;&amp; x + 1 &lt;= row &amp;&amp; ' ' != show[x + 1][y]) &#123; clearmine(mine, show, x+1, y, row, col); &#125; else &#123; show[x + 1][y] = '0' + mine[x + 1][y]; &#125; &#125; if (' ' != show[x][y-1]) &#123; if (0 == mine[x][y - 1] &amp;&amp; y - 1 &gt;= 1 &amp;&amp; ' ' != show[x][y - 1]) &#123; clearmine(mine, show, x, y-1, row, col); &#125; else &#123; show[x][y - 1] = '0' + mine[x][y - 1]; &#125; &#125; if (' ' != show[x - 1][y-1]) &#123; if (0 == mine[x - 1][y - 1] &amp;&amp; x - 1 &gt;= 1 &amp;&amp; y - 1 &gt;= 1 &amp;&amp; ' ' != show[x - 1][y - 1]) &#123; clearmine(mine, show, x-1, y-1, row, col); &#125; else &#123; show[x - 1][y - 1] = '0' + mine[x - 1][y - 1]; &#125; &#125; if (' ' != show[x + 1][y-1]) &#123; if (0 == mine[x + 1][y - 1] &amp;&amp; x + 1 &lt;= row &amp;&amp; y - 1 &gt;= 1 &amp;&amp; ' ' != show[x + 1][y - 1]) &#123; clearmine(mine, show, x+1, y-1, row, col); &#125; else &#123; show[x + 1][y - 1] = '0' + mine[x + 1][y - 1]; &#125; &#125; if (' ' != show[x + 1][y+1]) &#123; if (0 == mine[x + 1][y + 1] &amp;&amp; x + 1 &lt;= row &amp;&amp; y + 1 &lt;= col &amp;&amp; ' ' != show[x + 1][y + 1]) &#123; clearmine(mine, show, x+1, y+1, row, col); &#125; else &#123; show[x + 1][y + 1] = '0' + mine[x + 1][y + 1]; &#125; &#125; if (' ' != show[x - 1][y +1]) &#123; if (0 == mine[x - 1][y + 1] &amp;&amp; x - 1 &gt;= 1 &amp;&amp; y + 1 &lt;= col &amp;&amp; ' ' != show[x - 1][y + 1]) &#123; clearmine(mine, show, x-1, y+1, row, col); &#125; else &#123; show[x - 1][y + 1] = '0' + mine[x - 1][y + 1]; &#125; &#125; if (' ' != show[x ][y + 1]) &#123; if (0 == mine[x][y + 1] &amp;&amp; y + 1 &lt;= col &amp;&amp; ' ' != show[x][y + 1]) &#123; clearmine(mine, show, x, y+1, row, col); &#125; else &#123; show[x][y + 1] = '0' + mine[x][y + 1]; &#125; &#125; &#125; int is_win(char show[ROWS][COLS],int row,int col,int count) &#123; int x = 0; int y = 0; int countmine = 0; for (x = 1; x &lt;= row; x++) &#123; for (y = 1; y &lt;= col; y++) &#123; if ('0' != show[x][y] ) countmine++; &#125; &#125; return (countmine &gt;= (row*col - count));&#125; void jump_mine(int mine[ROWS][COLS], int x, int y, int row, int col)&#123; int i = 0; int j = 0; while (9 == mine[x][y]) &#123; i = rand() % row + 1; j = rand() % col + 1; if(mine[i][j] - 9 ) &#123; mine[x][y] = 0; mine[i][j] = 9; if (9!=mine[x][y - 1] )//原位置周围雷数量 mine[x][y - 1]--; else mine[x][y]++; if (9!= mine[x][y + 1] ) mine[x][y + 1]--; else mine[x][y]++; if (9!= mine[x - 1][y + 1] ) mine[x - 1][y + 1]--; else mine[x][y]++; if (9 != mine[x - 1][y] ) mine[x - 1][y]--; else mine[x][y]++; if (9 != mine[x - 1][y - 1] ) mine[x - 1][y - 1]--; else mine[x][y]++; if (9 != mine[x + 1][y - 1] ) mine[x + 1][y - 1]--; else mine[x][y]++; if (9 != mine[x + 1][y] ) mine[x + 1][y]--; else mine[x][y]++; if (9 != mine[x + 1][y + 1] ) mine[x + 1][y + 1]--; else mine[x][y]++; if (9!=mine[i][j - 1])//新位置周围雷数量 mine[i][j - 1]++; if (9!= mine[i][j + 1]) mine[i][j + 1]++; if (9!= mine[i - 1][j + 1]) mine[i - 1][j + 1]++; if (9 != mine[i - 1][j]) mine[i - 1][j]++; if (9 != mine[i - 1][j - 1]) mine[i - 1][j - 1]++; if (9 != mine[i + 1][j - 1]) mine[i + 1][j - 1]++; if (9 != mine[i + 1][j]) mine[i + 1][j]++; if (9 != mine[i + 1][j + 1]) mine[i + 1][j + 1]++; &#125; &#125;&#125;int sweep_mine(int mine[ROWS][COLS],char show[ROWS][COLS],int row,int col,int count, int countsao) &#123; int x = 0, y = 0; char c; while (1) &#123; if(countsao &gt; 1) &#123; printf("是否进行标记？（y/n）"); scanf("%c",&amp;c); fflush(stdin); if('y' == c) &#123; printf("请输入标记坐标："); scanf("%d %d",&amp;x,&amp;y); fflush(stdin); show[x][y] = 1; system("cls"); printshow(show, ROW, COL); &#125; while('y' == c) &#123; printf("是否继续标记？（y/n）"); scanf("%c",&amp;c); fflush(stdin); if('y' == c) &#123; printf("请输入标记坐标："); scanf("%d %d",&amp;x,&amp;y); fflush(stdin); show[x][y] = 1; system("cls"); printshow(show, ROW, COL); &#125; &#125; &#125; printf("请输入排雷坐标&gt;"); scanf("%d %d", &amp;x, &amp;y); fflush(stdin); if (x&gt;=1&amp;&amp;x&lt;= row &amp;&amp;y&gt;=1&amp;&amp;y&lt;= col) &#123; if (9 == mine[x][y])//避开第一次就踩雷 &#123; if (1 == countsao) &#123; jump_mine(mine, x, y ,row, col); &#125; else &#123; system("cls"); printf("很遗憾，你挂了！\n"); return 0; &#125; &#125; if (0 == mine[x][y]) &#123; clearmine(mine, show, x, y, row, col); &#125; else &#123; show[x][y] = '0' + mine[x][y]; &#125; break; &#125; else &#123; printf("输入有误，请重新输入\n"); &#125; &#125; return 1; &#125; test.c123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_WARNINGS#include "Game.h" int main() &#123; //char p[50]; int input; srand((unsigned int)time(NULL)); start_show(); //sprintf((char *)p, "mode con cols=%d lines=%d", 100, 25); //system((const char*)p);res: //restart menu(); do &#123; printf("\t\t\t\t请选择&gt;"); scanf_s("%d", &amp;input); switch (input) &#123; case 0: break; case 1: game(); //sprintf((char *)p, "mode con cols=%d lines=%d", 100, 25); //system((const char*)p); system("pause"); system("cls"); goto res;//restart default: printf("\t\t\t\t输入错误！请重新输入：\n"); &#125; &#125; while (input); printf("\t\t\t\t"); return 0; &#125; 这样我们的扫雷就搞定了.]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现变色贪吃蛇]]></title>
    <url>%2F2018%2F05%2F30%2F</url>
    <content type="text"><![CDATA[今天我们实现一下用C语言编写一个能变色、能调速、能调整地图大小、有成就系统、并且能用文件保存分数和成就的贪吃蛇游戏··工具：VS2013语言：C 我们先看一下效果： 头文件TCS.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#pragma once#ifndef __TCS_H__#define __TCS_H__#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include "mmsystem.h"#pragma comment(lib, "WINMM.LIB")#define Filename "tcs.52m"#define U 1#define D 2#define L 3#define R 4 //蛇的状态，U：上 ；D：下；L:左 R：右typedef struct SNAKE //蛇身的一个节点&#123; int x; int y; struct SNAKE *next;&#125;snake;typedef struct PLAYER&#123; char name[20]; int scores; char len[3]; int steps;&#125;player;typedef struct ACHEVE&#123; int step; int eat; int score;&#125;acheve;typedef struct POS&#123; int x; int y;&#125;pos,*ppos;typedef struct LEL&#123; ppos pos; int sz; int capacity;&#125;lel,plel;typedef struct list&#123; char * name[5]; int sz;&#125;List;//声明全部函数//void Pos();void creatMap();void initsnake();int biteself();void createfood(int x);void cantcrosswall();void snakemove();void pause();void gamecircle();void welcometogame();void gamestart();void endgame();void print();void menu();void inittop();void showtop();void sorttop();void startshow();void selectmap();void mapmenu();int topmenu();void loadtop();void savetop();void color();void showach();void loadach();void saveach();void tfree(snake* p);void initlevel();void printlevel();void push(int l,int x,int y);void selectmode();void uplevel();void modemenu();int Select(List mmenu);void printmenu(List menu, int t);#endif//__TCS_H__ 源文件tcs.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183#define _CRT_SECURE_NO_WARNINGS#define TEST#include "TCS.h"//全局变量//int level = 0; //关卡数，0表示无尽模式int score = 0, add = 10; //总得分与每次吃食物得分int status, sleeptime = 200; //每次运行的时间间隔snake *head, *food; //蛇头指针，食物指针snake *q; //遍历蛇的时候用到的指针int endgamestatus = 0; //游戏结束的情况，1：撞到墙；2：咬到自己；3：主动退出游戏。int run = 0; //判断游戏是否还能运行player top[61]; //排行榜int MAX_LL = 130; //游戏窗口长度int MAX_CC = 36; //游戏窗口高度int MAX_L = 92; //游戏区域长度int MAX_C = 35; //游戏区域高度int steps = 0; //计数步数int lenth = 4; //计数长度acheve ach; //成就数据int mode = 0; //游戏模式 0 正常 1 躲避int istest = 0; //是否为测试模式lel map[6];int weisuoyuwei = 0; //为所欲为模式int Color = 0;List mainmenu = &#123; &#123; "开始游戏","游戏说明","排行总榜","成就系统","退出游戏" &#125;,5 &#125;;List Modemenu = &#123; &#123; "自由无限模式", "障碍无限模式", "自由闯关模式", "障碍闯关模式" &#125;, 4 &#125;;List Mapmenu = &#123; &#123; "小型地图", "中号地图", "大型地图" &#125;, 3 &#125;;List Maptopmenu = &#123; &#123; "小型地图排行", "中号地图排行", "大型地图排行" &#125;, 3 &#125;;void printmenu(List menu, int t)&#123; int i; for (i = 0; i &lt;= menu.sz; i++) &#123; Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 7+i*2); if (i == t) &#123; color(15*16); &#125; else &#123; color(0); &#125; if (i &lt;= menu.sz-1) printf(" %s \n\n", menu.name[i]); &#125;&#125;int Select(List menu)&#123; int t = 0; int recordt = 1; system("cls"); print(); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 5); printf(" ■■■■■■■■ ★ ■■■■■■■■"); while (1) &#123; if (recordt != t ) &#123; printmenu(menu, t); &#125; Pos(158, 43); recordt = t; if (GetAsyncKeyState(VK_DOWN) &amp;&amp; t&lt;menu.sz-1) &#123; t++; Sleep(200); &#125; if (GetAsyncKeyState(VK_UP) &amp;&amp; t&gt;0) &#123; t--; Sleep(200); &#125; if (GetAsyncKeyState(VK_RETURN)) &#123; Sleep(200); return t; &#125; &#125;&#125;//设置关卡void push(int l,int x, int y)&#123; if (map[l].sz == map[l].capacity) &#123; ppos tmp = realloc(map[l].pos, (map[l].capacity + 10)*sizeof(pos)); if (tmp == NULL) &#123; perror("realloc"); exit(1); &#125; map[l].pos = tmp; map[l].capacity += 10; &#125; map[l].pos[map[l].sz].x = x; map[l].pos[map[l].sz].y = y; map[l].sz++;&#125;//初始化关卡void initlevel()&#123; //MAX_LL = 160; //MAX_CC = 45; //MAX_L = 120; //MAX_C = 44; int i = 0; for (i = 0; i &lt; 6; i++) &#123; map[i].pos = (ppos)malloc(3 * sizeof(pos)); map[i].capacity = 3; map[i].sz = 0; &#125; for (i = 20; i &lt;= 100; i += 4) &#123; push(1, i, 22); push(2, i, 22); push(5, i, 22); &#125; for (i = 8; i &lt; 38; i+=2) &#123; push(2, 60, i); push(3, 60, i); push(5, 60, i); &#125; for (i = 28; i &lt;= 92; i+=4) &#123; push(3, i, 14); push(3, i, 28); &#125; for (i = 20; i &lt;= 100; i += 2) &#123; if (i == 50)i = 72; push(4, i, 8); push(4, i, 36); push(5, i, 8); push(5, i, 36); &#125; for (i = 9; i &lt;= 36; i++) &#123; if (i == 18)i = 28; push(4, 20, i); push(4, 100, i); push(5, 20, i); push(5, 100, i); &#125;&#125;//打印关卡障碍void printlevel()&#123; int i = 0; for (i = 0; i &lt; map[level].sz; i++) &#123; Pos(map[level].pos[i].x, map[level].pos[i].y); printf("█"); &#125;&#125;void tfree(snake *p)&#123; if (p-&gt;next) tfree(p-&gt;next); free(p);&#125;//设置字体颜色void color(int x) &#123; static int tmp = 0; if (x &lt; 0) &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), tmp); return; &#125; if (!x) &#123; do &#123; x = rand() % 6 + 9; &#125; while (tmp == x); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), x); //只有一个参数，改变字体颜色 Color = tmp; tmp = x; &#125; else SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), x);&#125;//设置光标位置void Pos(int x, int y)&#123; COORD pos; HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOutput, pos);&#125;//创建地图void creatMap()&#123; int i; PlaySound(NULL, NULL, NULL); for (i = 0; i&lt;MAX_L; i += 2)//打印上下边框 &#123; Pos(i, 0); color(0); printf("■"); Pos(i, MAX_C); color(0); printf("■"); Sleep(10); &#125; for (i = 1; i&lt;MAX_C; i++)//打印左右边框 &#123; Pos(0,i); color(0); printf("■"); Pos(MAX_L-2,i); color(0); printf("■"); Sleep(10); &#125;&#125;//初始化蛇身void initsnake()&#123; snake *tail; int i; tail=(snake*)malloc(sizeof(snake));//从蛇尾开始，头插法，以x,y设定开始的位置// tail-&gt;x=24; tail-&gt;y = 15; tail-&gt;next = NULL; for (i = 1; i &lt;= 4; i++) &#123; head = (snake*)malloc(sizeof(snake)); head-&gt;next = tail; head-&gt;x = 24 + 2 * i; head-&gt;y = 15; tail = head; &#125; Pos(tail-&gt;x, tail-&gt;y); printf("●"); tail = tail-&gt;next; while (tail != NULL)//从头到尾，输出蛇身 &#123; Pos(tail-&gt;x, tail-&gt;y); printf("■"); tail = tail-&gt;next; &#125;&#125;//判断是否咬到了自己int biteself()&#123; snake *self; self = head-&gt;next; while (self != NULL) &#123; if (self-&gt;x == head-&gt;x &amp;&amp; self-&gt;y == head-&gt;y) &#123; return 1; &#125; self = self-&gt;next; &#125; return 0;&#125;//随机出现食物/障碍void createfood(int x)&#123; snake *food_1;res: food_1 = (snake*)malloc(sizeof(snake)); food_1-&gt;x = (rand() % (MAX_L - 4) + 2) / 2 * 2;//保证其为偶数，使得食物能与蛇头对其 food_1-&gt;y = rand() % (MAX_C - 1) + 1; q = head; while (q != NULL) &#123; if (q-&gt;x == food_1-&gt;x &amp;&amp; q-&gt;y == food_1-&gt;y) //判断蛇身是否与食物重合 &#123; free(food_1); goto res; &#125; q = q-&gt;next; &#125; if (level) &#123; int i = 0; for (i = 0; i &lt; map[level].sz; i++) &#123; if (food_1-&gt;x == map[level].pos[i].x &amp;&amp; food_1-&gt;y == map[level].pos[i].y) &#123; free(food_1); goto res; &#125; &#125; &#125; if (mode) &#123; int i = 0; for (i = 0; i &lt; map[0].sz; i++) &#123; if (food_1-&gt;x == map[0].pos[i].x &amp;&amp; food_1-&gt;y == map[0].pos[i].y) &#123; free(food_1); goto res; &#125; &#125; &#125; Pos(food_1-&gt;x, food_1-&gt;y); food = food_1; color(0); printf("★"); if (mode&amp;&amp;x) &#123; snake *food_1; res2: food_1 = (snake*)malloc(sizeof(snake)); food_1-&gt;x = (rand() % (MAX_L - 4) + 2) / 2 * 2;//保证其为偶数，使得食物能与蛇头对其 food_1-&gt;y = rand() % (MAX_C - 1) + 1; q = head; while (q != NULL) &#123; if (q-&gt;x == food_1-&gt;x &amp;&amp; q-&gt;y == food_1-&gt;y) //判断蛇身是否与食物重合 &#123; free(food_1); goto res2; &#125; q = q-&gt;next; &#125; if (level) &#123; int i = 0; for (i = 0; i &lt; map[level].sz; i++) &#123; if (food_1-&gt;x == map[level].pos[i].x &amp;&amp; food_1-&gt;y == map[level].pos[i].y) &#123; free(food_1); goto res; &#125; &#125; &#125; if (mode) &#123; int i = 0; for (i = 0; i &lt; map[0].sz; i++) &#123; if (food_1-&gt;x == map[0].pos[i].x &amp;&amp; food_1-&gt;y == map[0].pos[i].y) &#123; free(food_1); goto res; &#125; &#125; &#125; Pos(food_1-&gt;x, food_1-&gt;y); push(0, food_1-&gt;x, food_1-&gt;y); //color(0); printf("█"); &#125;&#125;//不能穿墙void cantcrosswall()&#123; if (head-&gt;x == 0 || head-&gt;x == MAX_L - 2 || head-&gt;y == 0 || head-&gt;y == MAX_C) &#123; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgamestatus = 1; endgame(); &#125;&#125;//过关void uplevel()&#123; system("cls"); print(); Pos(60, 22); printf("恭喜过关，三秒后切换关卡"); Sleep(3000); system("cls"); endgame(); lenth = 4; creatMap(); initsnake(); createfood(mode); printlevel(); status = R; PlaySound("running.wav", NULL, SND_ASYNC | SND_FILENAME | SND_LOOP);&#125;//蛇移动void snakemove()&#123; int t = 0; snake * nexthead; if (!weisuoyuwei) &#123; cantcrosswall(); &#125; if (run)return; nexthead = (snake*)malloc(sizeof(snake)); if (status == U) &#123; nexthead-&gt;x = head-&gt;x; nexthead-&gt;y = head-&gt;y - 1; &#125; else if (status == D) &#123; nexthead-&gt;x = head-&gt;x; nexthead-&gt;y = head-&gt;y + 1; &#125; else if (status == L) &#123; nexthead-&gt;x = head-&gt;x - 2; nexthead-&gt;y = head-&gt;y; &#125; else if (status == R) &#123; nexthead-&gt;x = head-&gt;x + 2; nexthead-&gt;y = head-&gt;y; &#125; if (weisuoyuwei) &#123; if (nexthead-&gt;x == 0)nexthead-&gt;x = MAX_L - 4; if (nexthead-&gt;x == MAX_L - 2)nexthead-&gt;x = 2; if (nexthead-&gt;y == 0)nexthead-&gt;y = MAX_C - 1; if (nexthead-&gt;y == MAX_C)nexthead-&gt;y = 1; &#125; if (level) &#123; int i = 0; for (i = 0; i &lt; map[level].sz; i++) &#123; if (nexthead-&gt;x == map[level].pos[i].x &amp;&amp; nexthead-&gt;y == map[level].pos[i].y) &#123; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgamestatus = 4; endgame(); &#125; if (run)return; &#125; &#125; if (mode) &#123; int i = 0; for (i = 0; i &lt; map[0].sz;i++) &#123; if (nexthead-&gt;x == map[0].pos[i].x &amp;&amp; nexthead-&gt;y == map[0].pos[i].y) &#123; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgamestatus = 4; endgame(); &#125; if (run)return; &#125; &#125; else; if ((nexthead-&gt;x == food-&gt;x) &amp;&amp; (nexthead-&gt;y == food-&gt;y) )//如果下一个有食物// &#123; nexthead-&gt;next = head; head = nexthead; createfood(1); q = head; Pos(q-&gt;x, q-&gt;y); color(Color); printf("●"); Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); printf("■"); while (q-&gt;next != NULL) &#123; q = q-&gt;next; &#125; Pos(q-&gt;x, q-&gt;y); printf("■"); PlaySound("error.wav", NULL, SND_FILENAME | SND_ASYNC | SND_NOSTOP); score = score + add*(mode+1); lenth++; t = 0; &#125; else //如果没有食物// &#123; nexthead-&gt;next = head; head = nexthead; q = head; Pos(q-&gt;x, q-&gt;y); //color(Color); printf("●"); Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); //color(0); printf("■"); while (q-&gt;next-&gt;next != NULL) &#123; q = q-&gt;next; &#125; Pos(q-&gt;next-&gt;x, q-&gt;next-&gt;y); printf(" "); free(q-&gt;next); q-&gt;next = NULL; &#125; steps++; t++; if (biteself() == 1) //判断是否会咬到自己 &#123; endgamestatus = 2; system("color cf"); Sleep(200); system("color 0f"); Sleep(200); system("color cf"); Sleep(200); system("color 0f"); endgame(); &#125; if (run)return; if (t % 300 == 0) &#123; Pos(food-&gt;x, food-&gt;y); printf(" "); createfood(mode); &#125; Pos(MAX_LL, MAX_CC);&#125;//暂停void pause()&#123; while (1) &#123; Sleep(300); if (GetAsyncKeyState(VK_SPACE)) &#123; break; &#125; &#125;&#125;//控制游戏void gamecircle()&#123; static int tscore = -1; static int tlenth = -1; static int tadd = -1; PlaySound("running.wav", NULL, SND_ASYNC | SND_FILENAME | SND_LOOP); Pos(MAX_L+4, 15); color(0); printf("不能穿墙，不能咬到自己\n"); Pos(MAX_L + 4, 16); color(0); printf("用↑.↓.←.→分别控制蛇的移动."); Pos(MAX_L + 4, 17); color(0); printf("F1 为加速，F2 为减速\n"); Pos(MAX_L + 4, 18); color(0); printf("ESC ：退出游戏.Space：暂停游戏."); Pos(MAX_L + 4, 20); color(0); if (mode) &#123; Pos(MAX_L + 4, 22); printf("躲避模式下也不能碰到障碍！！"); &#125; printf("\n"); status = R; while (1) &#123; if (tscore != score||tadd!=add) &#123; Pos(MAX_L + 6, 10); printf("得分：%d ", score); Pos(MAX_L + 6, 11); printf("每个食物得分：%d分", add*(mode + 1)); &#125; if (GetAsyncKeyState(VK_UP) &amp;&amp; status != D) &#123; status = U; &#125; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; status != U) &#123; status = D; &#125; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; status != R) &#123; status = L; &#125; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; status != L) &#123; status = R; &#125; else if (GetAsyncKeyState(VK_SPACE)) &#123; pause(); &#125; else if (GetAsyncKeyState(VK_ESCAPE)) &#123; endgamestatus = 3; PlaySound(NULL,NULL,NULL); break; &#125; else if (GetAsyncKeyState(VK_F1)) &#123; if (sleeptime &gt;= 50) &#123; sleeptime = sleeptime - 30; add = add + 2; if (sleeptime == 320) &#123; add = 2;//防止减到1之后再加回来有错 &#125; &#125; &#125; else if (GetAsyncKeyState(VK_F2)) &#123; if (sleeptime&lt;350) &#123; sleeptime = sleeptime + 30; add = add - 2; if (sleeptime == 350) &#123; add = 1; //保证最低分为1 &#125; &#125; &#125; if (GetAsyncKeyState(VK_F5)) &#123; weisuoyuwei = 1; &#125; if (GetAsyncKeyState(VK_F6)) &#123; weisuoyuwei = 0; &#125; if (level&amp;&amp;tlenth!=lenth) &#123; Pos(MAX_L + 6, 12); printf("关卡进度：%d/25", (lenth - 4) % 25); if (lenth - 4 == 25 &amp;&amp; level - 5) &#123; level++; endgamestatus = 0; uplevel(); &#125; &#125; Sleep(sleeptime); tscore = score; tlenth = lenth; snakemove(); if (run)return; &#125;&#125;//简介界面void welcometogame()&#123; system("cls"); //int i = 7; //color(13); //Pos(6, 7); //printf("■■■■ ★"); //for (i = 8; i &lt; 20; i++) //&#123; // Pos(6, i); // printf("■"); // Pos(MAX_L + 6, i); // printf("■"); //&#125; //Pos(6, i); //for (i = 6; i &lt;= MAX_L + 6; i+=2) // printf("■"); print(); Pos(MAX_L/2-12, 7); color(15); printf("用"); color(10); printf("↑ ↓ ← →"); color(15); printf("分别控制蛇的移动"); Pos(MAX_L / 2 - 12, 9); color(12); printf("F1 "); color(15); printf("为加速"); color(12); printf(" F2 "); color(15); printf("为减速\n"); Pos(MAX_L / 2 - 12, 11); color(15); printf("可以多点几下"); color(11); printf(" F1 "); color(15); printf("或者"); color(11); printf(" F2 "); color(15); printf("切换到你认为最适合你的难度\n"); Pos(MAX_L/2-12, 13); printf("加速将能得到"); color(13); printf("更高的分数。"); Pos(MAX_L / 2 - 12, 15); color(14); printf("开始进行愉快的贪吃蛇游戏吧 ^_^\n"); Pos(MAX_L / 2-12, 25); color(15);#ifndef TEST system("pause");#endif#ifdef TEST printf("按下空格键返回..."); while (1) &#123; if (GetAsyncKeyState(VK_SPACE)) return; &#125;#endif&#125;//结束游戏void endgame()&#123; char c; system("cls"); Pos(MAX_L/2, 12); if (endgamestatus == 1) &#123; color(12); printf("很遗憾，你撞到了墙。游戏结束."); &#125; else if (endgamestatus == 2) &#123; color(12); printf("很遗憾，你咬到了自己。游戏结束."); &#125; else if (endgamestatus == 3) &#123; color(12); printf("你已经结束了游戏。"); &#125; else if (endgamestatus == 4) &#123; color(12); printf("你撞上了障碍，挂了！！！"); &#125; else &#123; ach.step += steps; ach.score += score; ach.eat += (lenth - 4); saveach(); tfree(head); map[0].sz = 0; return; &#125; print(); PlaySound("death.wav", NULL, SND_FILENAME | SND_ASYNC); Pos(MAX_L / 2, 13); printf("你的得分是:%d,在本局游戏中你一共走了:%d格", score,steps); if (score &gt;= top[(MAX_LL-70)/30*20-1].scores&amp;&amp;endgamestatus) &#123; Pos(MAX_L / 2, 14); system("pause"); top[60].scores = score; sprintf(top[60].len, "%d", lenth); top[60].steps = steps; Pos(MAX_L / 2, 14); printf("恭喜你进入排行榜！！！！"); fflush(stdin); Pos(MAX_L / 2, 15); printf("是否留下你的名字？(y/n)"); scanf("%c", &amp;c); if ('y' == c || 'Y' == c) &#123; Pos(MAX_L / 2, 16); printf("请输入你的昵称:&gt;"); scanf("%s", top[60].name); sorttop(); Pos(MAX_L / 2, 17); printf("排行榜已更新..."); &#125; else &#123; strcpy(top[60].name, "noname"); sorttop(); Pos(MAX_L / 2, 17); printf("排行榜已更新..."); &#125; &#125; ach.step += steps; ach.score += score; ach.eat += (lenth - 4); saveach(); tfree(head); run = 1; Pos(MAX_L / 2, 18); map[0].sz = 0;#ifndef TEST system("pause");#endif#ifdef TEST printf("按下空格键返回..."); while (1) &#123; if (GetAsyncKeyState(VK_SPACE)) return; &#125;#endif&#125;//游戏初始化void gamestart()&#123; char p[50]; sleeptime = 200; score = 0; add = 10; steps = 0; lenth = 4; system("cls"); run = 0; sprintf((char *)p, "mode con cols=%d lines=%d", MAX_LL, MAX_CC); system((const char*)p); creatMap(); initsnake(); createfood(mode); printlevel();&#125;//选择地图界面void mapmenu()&#123; print(); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 5); printf("■■■■■■■■ ★ ■■■■■■■■"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 5); printf("1.地图：小"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 3); printf("2.地图：中"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 1); printf("3.地图：大"); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2+1); printf("选择你的地图大小:&gt;");&#125;//选择地图void selectmap()&#123; int input; do &#123; if (istest) input = Select(Mapmenu)+istest;#ifndef TEST system("cls"); mapmenu(); fflush(stdin); scanf("%d", &amp;input);#endif switch (input) &#123; case 1: MAX_LL = 100; MAX_CC = 30; MAX_L = 64; MAX_C = 29; return; break; case 2: MAX_LL = 130; MAX_CC = 36; MAX_L = 92; MAX_C = 35; return; break; case 3: MAX_LL = 160; MAX_CC = 45; MAX_L = 120; MAX_C = 44; return; break; default: Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 2); printf("输入有误！"); Sleep(500); break; &#125; &#125; while (1);&#125;//打印边框void print()&#123; int i; for (i = 0; i&lt;MAX_LL; i += 2)//打印上下边框 &#123; Pos(i, 0); color(0); printf("■"); Pos(i, MAX_CC - 1); color(0); printf("■"); &#125; for (i = 1; i&lt;MAX_CC; i++)//打印左右边框 &#123; Pos(0, i); color(0); printf("■"); Pos(MAX_LL - 2, i); color(0); printf("■"); &#125;&#125;//主菜单void menu()&#123; print(); Pos((MAX_LL-78)/2-1, MAX_CC / 5); printf("■■■■■■■■ ★ ■■■■■■■■"); Pos(MAX_LL / 2-6, MAX_CC / 2-7); printf("1.开始游戏"); Pos(MAX_LL / 2-6, MAX_CC / 2-5); printf("2.游戏简介"); Pos(MAX_LL / 2 - 6, MAX_CC / 2-3); printf("3.排行榜"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 1); printf("4.成就"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 + 1); printf("0.退出游戏");&#125;//选择模式界面void modemenu()&#123; print(); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 5); printf("■■■■■■■■ ★ ■■■■■■■■"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 5); printf("1.无限模式"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 3); printf("2.障碍无限模式"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 - 1); printf("3.闯关模式"); Pos(MAX_LL / 2 - 6, MAX_CC / 2 + 1); printf("4.障碍闯关模式"); Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 5); printf("选择你的模式:&gt;");&#125;//选择模式void selectmode()&#123; int input; do &#123; if (istest) input = Select(Modemenu)+istest;#ifndef TEST system("cls"); modemenu(); fflush(stdin); scanf("%d", &amp;input);#endif switch (input) &#123; case 2: level = 0; mode = 1; selectmap(); return; case 1: level = 0; mode = 0; selectmap(); return; break; case 4: mode = 1; MAX_LL = 160; MAX_CC = 45; MAX_L = 120; MAX_C = 44; level = 1; return; case 3: mode = 0; MAX_LL = 160; MAX_CC = 45; MAX_L = 120; MAX_C = 44; level = 1; return; default: Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 6); printf("输入有误！"); Sleep(500); break; &#125; &#125; while (1);&#125;//游戏流程控制void game()&#123; //system("color 3f"); selectmode(); gamestart(); gamecircle(); system("cls");&#125;//开始动画void startshow()&#123; int i = 0; int t; PlaySound("show.wav", NULL, SND_ASYNC | SND_FILENAME); Pos((MAX_LL - 56) / 2-6, (MAX_CC - 10) / 2 + i++); Sleep(5); color(0); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(55); printf("██ █ █ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("██ █ █ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(35); printf("██ ██████████ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(25); printf("██ ██████████ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(15); printf("██ ███◣ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(15); printf("██ ██◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(25); printf("██ ██ ◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(35); printf("██ ██ ◥█◣ ██"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(45); printf("█████████ ██ ◥█◣ ████████"); Pos((MAX_LL - 56) / 2 - 6, (MAX_CC - 10) / 2 + i++); //color(0); Sleep(55); printf("█████████ ██ ◥█◣ ████████"); Sleep(500); Pos( MAX_LL/ 2+10, (MAX_CC - 10) / 2 + i+3); color(13); printf("★"); Pos(0, (MAX_CC - 10) / 2 +i+3); t = (MAX_CC - 10) / 2 + i + 3; color(14); for (i = 0; i &lt; MAX_LL; i += 2) &#123; Pos(i, t); printf("■"); if (i&gt;=16) &#123; Pos(i-16, t); printf(" "); &#125; if (i &gt;= (MAX_LL / 2 + 8) &amp;&amp; i &lt;= (MAX_LL / 2 + 10)) &#123; color(13); &#125; Sleep(15); &#125; //system("pause");&#125;//测试食物是否会生成在地图外void test()&#123; int x = 0; int y = 0; system("cls"); creatMap(); color(15); Pos(MAX_L + 4, 15); printf("按下Esc结束测试状态"); while(1) //保证其为偶数，使得食物能与蛇头对其 &#123; x = (rand() % (MAX_L - 4) + 2)/2*2; y = rand() % (MAX_C - 1) + 1; Pos(x,y); color(0); printf("█"); if (GetAsyncKeyState(VK_ESCAPE)) &#123; break; &#125; &#125;&#125;void testlevel()&#123; system("mode con cols=160 lines=45"); level = 5; initlevel(); printlevel(); system("pause");&#125;//主函数int main()&#123; int t = 0; int input; char p[50]; istest = 1; system("title LRS-贪吃蛇"); initlevel(); color(0); srand((unsigned)time(NULL)); inittop(); loadach(); sprintf((char *)p, "mode con cols=%d lines=%d", MAX_LL, MAX_CC); system((const char*)p); startshow(); do&#123; PlaySound("begin.wav", NULL, SND_ASYNC | SND_FILENAME | SND_LOOP | SND_NOSTOP); weisuoyuwei = 0; fflush(stdin); Sleep(300); //keybd_event(VK_ESCAPE, (BYTE)0, 0, 0); //keybd_event(VK_ESCAPE, (BYTE)0, KEYEVENTF_KEYUP, 0); if (GetAsyncKeyState(VK_RETURN) | GetAsyncKeyState(VK_UP) | GetAsyncKeyState(VK_DOWN)); input = (Select(mainmenu)+1)%5;#ifndef TEST system("cls"); menu(); Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 3); printf("请选择:&gt;"); scanf("%d", &amp;input);#endif switch (input) &#123; case 5: test(); break; case 4: showach(); break; case 3: showtop(); break; case 2: welcometogame(); break; case 1: game(); break; case 0: Sleep(100); break; default: Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 4); printf("输入有误请重新输入！\n"); Sleep(500); break; &#125; &#125; while (input); Pos(MAX_LL / 2 - 14, MAX_CC / 2 + 4); printf("感谢你的游玩，再见！"); Sleep(800); return 0;&#125; top.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#define _CRT_SECURE_NO_WARNINGS#define TEST#include "TCS.h"//全局变量//extern int level ; //关卡数，0表示无尽模式extern int score , add ; //总得分与每次吃食物得分extern int status, sleeptime ; //每次运行的时间间隔extern snake *head, *food; //蛇头指针，食物指针extern snake *q; //遍历蛇的时候用到的指针extern int endgamestatus ; //游戏结束的情况，1：撞到墙；2：咬到自己；3：主动退出游戏。extern int run ; //判断游戏是否还能运行extern player top[61]; //排行榜extern int MAX_LL ;extern int MAX_CC ;extern int MAX_L ;extern int MAX_C ;extern int istest;extern List Maptopmenu;//初始化排行void inittop()&#123; int j = 0; for (j = 0; j &lt; 3; j++) &#123; int i = 0; top[20 * j + i].scores = 999; sprintf(top[20 * j + i].len, "%d", 56); top[20 * j + i].steps = 1658; for (i = 1; i &lt; 20; i++) &#123; top[20 * j + i].scores = 480 - 20 * i; sprintf(top[20 * j + i].len ,"%d", 48 - 2 * i); top[20 * j + i].steps = 999 - 20 * i; &#125; for (i = 0; i &lt; 21; i++) &#123; strcpy(top[20 * j + i].name, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"); strcpy(top[20 * j + i].name, "LRS"); &#125; &#125; top[60].scores = 0; loadtop();&#125;//排行菜单int topmenu()&#123; int input; do &#123; if (istest) input = Select(Maptopmenu) + istest;#ifndef TEST system("cls"); mapmenu(); fflush(stdin); scanf("%d", &amp;input);#endif switch (input) &#123; case 1: return 0; break; case 2: return 1; break; case 3: return 2; break; default: Pos((MAX_LL - 78) / 2 - 1, MAX_CC / 2 + 2); printf("输入有误！"); Sleep(500); break; &#125; &#125; while (1);&#125;//显示排行void showtop()&#123; int i = 0; int j = topmenu(); system("cls"); print(); Pos(MAX_LL / 5, i + 3); color(15); printf("%-5s\t%-20s%-6s\t%-3s\t%-8s", "名次", "昵称", "分数","体长","路程"); for (i = 0; i &lt; 20; i++) &#123; Pos(MAX_LL / 5, i + 4); if (i &lt; 20)color(15); if (i &lt; 10)color(10); if (i &lt; 5)color(9); if (i &lt; 3)color(13); if (i &lt; 2)color(14); if (i &lt; 1)color(12); printf("%-5d\t%-20s%-6d\t%-3s\t%-8d", i + 1, top[j * 20 + i].name, top[j * 20 + i].scores, top[j * 20 + i].len, top[j * 20 + i].steps); &#125; Pos(MAX_LL / 5, i + 6);#ifndef TEST system("pause");#endif#ifdef TEST printf("按下空格键返回..."); while (1) &#123; if (GetAsyncKeyState(VK_SPACE)) return; &#125;#endif&#125;//排序排行void sorttop()&#123; int i = 0; int j = 0; int m = (MAX_LL - 100) / 30 * 20; for (i = 0; i &lt; 20; i++) &#123; if (top[60].scores &gt;= top[m + i].scores) &#123; for (j = 19 + m; j &gt;(i + m); j--) &#123; top[j] = top[j - 1]; &#125; top[i + m] = top[60]; break; &#125; &#125; savetop();&#125;//加载void loadtop()&#123; int ret = 0; FILE* c = fopen(Filename,"a+"); FILE* load = fopen(Filename, "rb"); fclose(c); c = NULL; if (load == NULL) &#123; perror("load top"); exit(1); &#125; while(fread(&amp;top[ret++], sizeof(player), 1, load)); //printf("%d", ret); //system("pause"); fclose(load); load = NULL;&#125;//保存void savetop()&#123; int i = 0; FILE* save = fopen(Filename, "w"); if (save == NULL) &#123; perror("save top"); exit(1); &#125; fwrite(&amp;top[0], sizeof(player), 60, save); fclose(save); save = NULL;&#125; ach.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#define _CRT_SECURE_NO_WARNINGS#include "TCS.h"#define TESTextern acheve ach;extern int MAX_LL;struct achname&#123; char name[20]; int num;&#125;name[9] = &#123; &#123; "旅行蛇",10000 &#125;,&#123; "环游中国",100000 &#125; ,&#123;"遨游太空",1000000 &#125;,&#123;"大胃王", 100&#125;,&#123; "上古腐鲸蛇",10000 &#125;,&#123; "宇宙级大蛇", 100000&#125;,&#123; "得分高手",10000 &#125;,&#123; "得分大师",100000 &#125;,&#123;"得分宗师",1000000 &#125;&#125;;//展示成就void showach()&#123; int i = 0; system("cls"); print(); Pos(MAX_LL / 5, i + 3); color(15); printf("%-20s\t %-12s\t", "成就", "状态"); for (i = 0; i &lt; 9; i++) &#123; color(i % 3 + 10);//判断颜色 Pos(MAX_LL / 5, 2 * (i + 1) + 3); printf("%-20s\t", name[i].name); switch (i / 3)//判断类型 &#123; case 0: if (ach.step &gt;= name[i].num) &#123; printf("%10d/%-9d", name[i].num, name[i].num); &#125; else printf("%10d/%-9d", ach.step, name[i].num); break; case 1: if (ach.eat &gt;= name[i].num) &#123; printf("%10d/%-9d", name[i].num, name[i].num); &#125; else printf("%10d/%-9d", ach.eat, name[i].num); break; case 2: if (ach.score &gt;= name[i].num) &#123; printf("%10d/%-9d", name[i].num, name[i].num); &#125; else printf("%10d/%-9d", ach.score, name[i].num); break; &#125; &#125; Pos(MAX_LL / 5, 2 * (i + 1) + 5); printf("走过的总步数:%d步\t吃过的食物总数:%d个\t得到的总分数:%d分", ach.step, ach.eat, ach.score); Pos(MAX_LL / 5, 2 * (i + 1) + 7);#ifndef TEST system("pause");#endif#ifdef TEST printf("按下空格键返回..."); while (1) &#123; if (GetAsyncKeyState(VK_SPACE)) return; &#125;#endif&#125;//加载void loadach()&#123; FILE* c = fopen("ach.52m","a+");//如果没有就新建 FILE* load = fopen("ach.52m", "rb"); fclose(c); c = NULL; if (load == NULL) &#123; perror("load ach"); exit(1); &#125; ach.eat = 0; ach.score = 0; ach.step = 0; fread(&amp;ach, sizeof(acheve), 1, load); fclose(load); load = NULL;&#125;//保存void saveach()&#123; FILE* save = fopen("ach.52m", "wb"); if (save == NULL) &#123; perror("save ach"); exit(1); &#125; fwrite(&amp;ach, sizeof(acheve), 1, save); fclose(save); save = NULL;&#125; 这样我们的贪吃蛇游戏就做好了… 因为本人比较懒，所以用了很多全局变量 &gt; _ &lt; 怎么样？是不是相当…花里胡哨呢？注：2018.6.21之后的版本需要下载对应的音乐文件，下载链接：https://github.com/lrsand52m/tiny_project/tree/master/LRS_Tcs 下载里面的.wav文件放进你程序对应文件夹下就能正常工作了 更新日志： 2018.6.10 增加障碍躲避模式 2018.6.18 增加关卡模式 2018.6.20 增加为所欲为模式 分数计算更加合理 2018.6.21 增加操作优化及界面优化使其玩起来更像是游戏而不是程序]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建动态通讯录]]></title>
    <url>%2F2018%2F05%2F29%2F</url>
    <content type="text"><![CDATA[今天我们用自定义类型和动态内存管理实现一个通讯录程序，能够实现以下要求: 添加联系人信息 删除指定联系人信息 查找指定联系人信息 修改指定联系人信息 显示所有联系人信息 清空所有联系人 以名字排序所有联系人 头文件 Contact.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef __TEST_H__#define __TEST_H__#pragma once //2.实现一个通讯录；//通讯录可以用来存储1000个人的信息，每个人的信息包括://姓名、性别、年龄、电话、住址////提供方法：//1. 添加联系人信息//2. 删除指定联系人信息//3. 查找指定联系人信息//4. 修改指定联系人信息//5. 显示所有联系人信息//6. 清空所有联系人//7. 以名字排序所有联系人#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt;#include &lt;windows.h&gt;#include&lt;time.h&gt;#define Filename "Contact.txt"typedef struct PERSON&#123; char Name[20]; char Sex[5]; int Age; char Tel[20]; char Address[50];&#125;Person;typedef struct BOOK&#123; int max; //当前上限 int count; //当前已存储人数 Person* Data;&#125;Book;void Initbook(Book* people);void Add_person(Book * people);void show_person(Book* people);void Del_person(Book* people);void Find_person(Book* people);void Change_person(Book* people);void BubbleSort_person(Book* people);void Req_mem(Book* people);void Desbook(Book* people);#endif //__TEST_H__ 源文件 Test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357#include "test.h"//仅查找static int find_person(Book* people)&#123; int i = 0; assert(people); char name[20]; printf("\t\t 输入姓名："); scanf("%s", name); for (; i&lt;people-&gt;count; i++) &#123; if (strcmp(people-&gt;Data[i].Name, name) == 0) &#123; return i; &#125; &#125; //printf("没有找到该联系人！\n"); //system("pause"); return -1;&#125;//加载文件void load(Book*people)&#123; FILE* op = fopen(Filename, "a+"); FILE* load = fopen(Filename,"r"); fclose(op); if (load == NULL) &#123; perror("load file,please try again"); exit(1); &#125; while (fread(&amp;(people-&gt;Data[people-&gt;count]), sizeof(Person), 1, load)) &#123; people-&gt;count++; Req_mem(people); &#125; fclose(load); load = NULL;&#125;//保存文件void save(Book*people)&#123; int i = 0; FILE* save = fopen(Filename,"w"); if (save == NULL) &#123; perror("save file"); exit(1); &#125; while (i&lt;people-&gt;count) &#123; fwrite(&amp;(people-&gt;Data[i]), sizeof(Person), 1, save); i++; &#125; //fwrite(people-&gt;Data, sizeof(Person), (size_t)people-&gt;count, save); fclose(save); save = NULL;&#125;//初始化 void Initbook(Book* people)&#123; (people)-&gt;Data = (Person*)malloc(2*sizeof(Person)); (people)-&gt;count = 0; (people)-&gt;max = 2; load(people);&#125;//清空void Desbook(Book* people)&#123; free(people-&gt;Data); people-&gt;Data = NULL; people-&gt;max = 0; people-&gt;count = 0; save(people); printf("\t\t 清空完毕！\n"); Sleep(300);&#125;//打印void show_person(Book* people)&#123; int i = 0; if (people == NULL) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; printf("\t\t |%-15s\t|%-5s\t|%-5s\t|%-15s\t|%-20s\n", "姓名", "性别", "年龄", "电话", "地址"); for (; i&lt;=people-&gt;count-1; ++i) &#123; printf("\t\t |%-15s\t", people-&gt;Data[i].Name); printf("|%-5s\t", people-&gt;Data[i].Sex); printf("|%-5d\t", people-&gt;Data[i].Age); printf("|%-15s\t", people-&gt;Data[i].Tel); printf("|%-20s\n", people-&gt;Data[i].Address); &#125; printf("\n\t\t "); system("pause");&#125;//申请内存void Req_mem(Book *people)&#123; Person* p; if (people-&gt;count &lt; people-&gt;max - 1)return; p = (Person*)realloc((people)-&gt;Data,((people)-&gt;max+=5)*sizeof(Person)); if (p != NULL) &#123; (people)-&gt;Data = p; return; &#125; else &#123; perror("realloc"); exit(EXIT_FAILURE); &#125;&#125;//增加成员 void Add_person(Book *people)&#123; int i = 0; assert(people); if ((people)-&gt;count == 1000) &#123; printf("\t\t 通讯录已满！\n"); return; &#125; Req_mem(people); printf("\t\t 请输入姓名:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Name); printf("\t\t 请输入性别:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Sex); printf("\t\t 请输入年龄:&gt;"); scanf("%d", &amp;((people)-&gt;Data[(people)-&gt;count]).Age); printf("\t\t 请输入联系方式:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Tel); for (; i&lt;(people)-&gt;count; ++i) &#123; if (strcmp((people)-&gt;Data[i].Tel, (people)-&gt;Data[(people)-&gt;count].Tel) == 0) &#123; printf("\t\t 联系人已存在！\n\t\t "); system("pause"); return; &#125; &#125; printf("\t\t 请输入住址:&gt;"); scanf("%s", ((people)-&gt;Data[(people)-&gt;count]).Address); printf("\t\t 增加成功！\n"); Sleep(300); (people)-&gt;count++; //printf("count = %d\n", (*people)-&gt;count);&#125;//删除成员 void Del_person(Book* people)&#123; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; int ret = find_person(people); if (ret != -1) &#123; int i = ret; for (; i&lt;people-&gt;count-1; ++i) &#123; people-&gt;Data[i] = people-&gt;Data[i + 1]; &#125; people-&gt;count--; &#125; else &#123; printf("\t\t 没有该成员！\n"); system("pause"); &#125;&#125;//查找成员 void Find_person(Book* people)&#123; int i = 0; char name[20]; if (people-&gt;count == 0) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; assert(people); printf("\t\t 输入姓名："); scanf("%s", name); for (; i&lt;people-&gt;count; ++i) &#123; if (strcmp(people-&gt;Data[i].Name, name) == 0) &#123; printf("\t\t Name:%s\n\t\t Sex:%s\n\t\t Age:%d\n\t\t Tel:%s\n\t\t Add:%s\n\t\t ", people-&gt;Data[i].Name, people-&gt;Data[i].Sex, people-&gt;Data[i].Age, people-&gt;Data[i].Tel, people-&gt;Data[i].Address); //printf("编号为 %d\n", i); system("pause"); return; &#125; &#125; printf("\t\t 没有找到该联系人！\n\t\t "); system("pause"); return ;&#125;//修改成员 void Change_person(Book* people)&#123; assert(people); int ret = find_person(people); if (ret != -1) &#123; printf("\t\t Name-&gt;:"); scanf("%s", people-&gt;Data[ret].Name); printf("\t\t Sex-&gt;:"); scanf("%s", people-&gt;Data[ret].Sex); printf("\t\t Age-&gt;:"); scanf("%d", &amp;(people-&gt;Data[ret]).Age); printf("\t\t Tel-&gt;:"); scanf("%s", people-&gt;Data[ret].Tel); printf("\t\t Add-&gt;:"); scanf("%s", people-&gt;Data[ret].Address); &#125; else &#123; printf("\t\t 没有该成员！\n"); system("pause"); return; &#125;&#125;//排序void BubbleSort_person(Book* people)&#123; if (people == NULL) &#123; printf("\t\t 空通讯录！\n\t\t "); system("pause"); return; &#125; int i = 0; for (; i&lt;people-&gt;count - 1; ++i) &#123; int j = 0; for (; j&lt;people-&gt;count - 1 - i; ++j) &#123; if (strcmp(people-&gt;Data[j].Name, people-&gt;Data[j + 1].Name) &gt; 0) &#123; Person tmp = people-&gt;Data[j]; people-&gt;Data[j] = people-&gt;Data[j + 1]; people-&gt;Data[j+1] = tmp; &#125; &#125; &#125; show_person(people);&#125;void color() //自定义函根据参数改变颜色 &#123; //static int x = 9; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), rand()%7+9); //只有一个参数，改变字体颜色 //if (x == 16) // x = 9;&#125;//static void change_color()//&#123;// static int i = 0;// char *str[20];// sprintf((char*)str, "color %x%x",0,15 - i);// system((const char*)str);// i++;// if (15 == i)// i = 0;//&#125;void menu()&#123; system("cls"); printf("\t\t ******************************通讯录管理系统*****************************\n\n"); color(); printf("\t\t **************1.添加联系人**********************2.删除联系人*************\n\n"); color(); printf("\t\t **************3.查找联系人**********************4.修改联系人*************\n\n"); color(); printf("\t\t **************5.显示联系人**********************6.清空联系人*************\n\n"); color(); printf("\t\t **************7.排序联系人**********************0.退出此程序*************\n\n"); color(); printf("\t\t *************************************************************************\n\n");&#125;int main()&#123; srand((size_t)time(NULL)); Book people; Initbook(&amp;people); while (1) &#123; //change_color(); menu(); int n = 0; printf("\t\t 请选择:&gt; "); scanf("%d", &amp;n); switch (n) &#123; case 1: Add_person(&amp;people); break; case 2: Del_person(&amp;people); break; case 3: Find_person(&amp;people); break; case 4: Change_person(&amp;people); break; case 5: show_person(&amp;people); break; case 6: Desbook(&amp;people); Initbook(&amp;people); break; case 7: BubbleSort_person(&amp;people); break; case 0: save(&amp;people); free((&amp;people)-&gt;Data); color(); printf("\t\t 感谢您的使用，再见！"); Sleep(800); exit(0); default: &#123; printf("\t\t input error!\n\t\t "); system("pause"); break; &#125; &#125; &#125; return 0;&#125; 这个通讯录我加入了一点花里胡哨的元素：每次操作完毕都会使背景变色，你可以试试哦~~修订信息：于2018.5.31加入文件保存功能。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于自定义类型]]></title>
    <url>%2F2018%2F05%2F28%2F</url>
    <content type="text"><![CDATA[一、结构体类型的创建 1.结构体是一些值的集合，这些值称为成员变量。 2.结构体内的成员可以是不同类型的变量，也可以是标量，数组，指针甚至是其他的结构体。 3.结构体的创建： 例图： 4.结构体内部成员的访问：（1）.结构体变量访问成员(结构变量的成员是通过点操作符(.)访问的.点操作符接受两个操作数.如果s是结构体的具体名称，age是其内部成员，则s.age就可以访问)。（2）结构体访问指向变量的成员（定义一个指向该结构体的结构体类型的指针ps，如果age是该结构体的内部成员，则(*s).age或者ps-&gt;age就可以访问）。 5.结构的自引用：在结构体中可以包含该结构体本身的成员，具体的自引用如下例： 二、结构体的初始化 1. 123456struct Stu &#123; char name[10]; int age; &#125;; struct Stu s=&#123;"lisi",22&#125;;//初始化 2. 1234567struct Node &#123; int data; struct Stu p; struct Node* next; &#125;n=&#123;10,&#123;"wangwu",21&#125;,NULL&#125;;//结构体嵌套初始化 struct Node w=&#123;20,&#123;"liwu",23&#125;,NULL&#125;;//结构体嵌套初始化 三、结构体内存对齐 1.结构体的对齐原则： （1）第一个成员在与结构体变量偏移量为0的地址处。 （2）其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数=编译器默认的一个对齐数与该成员的大小的较小值。VS中默认的值为8， Linux中默认的值为4 （3）结构体总大小为最大对齐数（每个成员变量除了第一个成员都有一个对齐数）的整数倍。 （4）如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍。 总体来说：结构体的内存对齐是拿空间换时间的做法，除此，对于结构体传参的问题，要传结构体的地址（函数传参的时候，参数是需要压栈的，如果传递一个结构体对象时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降）。 四、位段 1.位段的声明和结构是相似的，有两个不同（一、位段的成员必须是int ,unsigned int，char.二，位段的成员名后边有一个冒号和一个数字）如： 12345struct A&#123; int _a:2; int _b:5;&#125;; 2.位段的内存分配 （1）位段的空间上是按照需要以4个字节（int）或者1个字节（char）的方式来开辟的。 （2）位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。 总体来说，跟结构相比，位段可以达到同样的效果，但是可以很好的节约空间，但是有跨平台的问题存在。 五、枚举枚举顾名思义就是一一列举。 1.枚举类型的定义 12345678910enum Day &#123; Mon, Tues, Wed, Thur, Fri, Sat, Sun &#125;; {}中的内容是枚举类型的可能取值，也叫枚举常量。这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值的。如 123456enum color &#123; RED=1, GREEN=2, BLUE=4 &#125;; 六、联合 1.联合类型的定义 联合类型定义的变量包含一系列的成员，特征是这些成员公用同一块空间（联合也称为共用体）。比如： 12345678//联合类型的声明 union Un &#123; char c; int i; &#125;; //联合变量的定义 union Un un; 2.联合的特点联合的成员是共用同一块内存空间的，这样一个联合变量的大小至少是最大成员的大小。 3.联合大小的计算 （1）联合的大小至少是最大成员的大小。 （2）当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>自定义类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next博客进阶攻略]]></title>
    <url>%2F2018%2F05%2F22%2F</url>
    <content type="text"><![CDATA[今天我将在Tim讲解完使用Github+hexo+next初步搭建自己的博客后继续讲解如何美化我们的博客，或者增加实用的（或者花里胡哨的）功能： 什么？你没看Tim的搭建攻略？没事，传送门在此：https://zouchanglin.github.io/2018/05/08/2018050801/ 搭建前先说两句 再看这篇攻略之前确保你搭建好了自己的博客并且能正常使用 最好使用next主题，否则部分功能可能不能正常使用 不要作出改动后忘了保存 不要保存改动之后立即hexo d查看效果，Github服务器离我们远得很，会有延迟，建议使用hexo s在本地预览效果 在进行攻略前最好备份自己的博客，因为代码中少一个符号都可能导致你的博客界面变成空白！！！！ 一定要看上面几句话！！！！ 功能列表 增加用户头像 增加文章字数统计与估计阅读时长和统计站点总字数 实现分享功能 实现博客内点击事件 实现显示访客数量 实现单篇文章统计访问数 实现评论功能 添加Github导航条 实现统计站点运行时间 预览前面所有的效果：http://lrsand52m.top 增加用户头像 在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/img/ 目录下） 比如我的头像图片文件名是：LRS.png 那么我把这个文件放进/img文件夹 然后在博客根目录下_config.yml里加上下面的代码： 12avatar: /img/LRS.png#上面是头像代码，把LRS.png改成你自己的头像文件名即可 最后打开git bash，输入hexo g，然后hexo s在本地服务器查看效果吧~~~ 增加文章字数统计与估计阅读时长和统计站点总字数 我们在实现这个功能前需要安装wordcount插件: 在git bash输入下面的代码即可 1npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： （查看node版本：node -v） 1npm install hexo-wordcount@2 --save NexT 主题默认已经集成了文章【字数统计】、【阅读时长】，【站点总字数】统计功能，如果我们需要使用，只需要在主题配置文件/next目录下的 _config.yml 中打开 wordcount 统计功能即可。如下所示： 你可以开启你自己想要开启的，下面表示全开 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计，如不需要此功能就把前面的true改为false，下同理 min2read: true # 单篇 阅读时长 totalcount: true # 网站 字数统计 separated_meta: true 改动之后我们还要加上说明否则站点的显示只有数字没有单位，所以我们要打开这个文件：/next/layout/_macro/post.swig ,找到下面的代码 123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt; 将它改为 123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 同理，我们修改【阅读时长】，修改后如下： 123&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 总字数统计也同理— — 修改完成后，重新执行启动服务预览就可以了。修改后，效果如下图所示： 感觉如何？ ​ 增加分享功能 关于分享我首先是找到了使用shareSDK的分享功能，最后在实践的过程中发现它添加时步骤比较多，添加完成后效果比较丑（就是一个长条的浅蓝色按钮），而且点击后想要退出分享比较麻烦（它的取消按钮实在太难找了，它在页面最下方的位置，呈现浅灰色，这个设计太反人类了，决定放弃它了）。 在next主题的官方的文档中发现它自身集成了百度分享的功能，所以决定采用百度了。 打开/next目录下的 _config.yml找到下面的代码： 1234567# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare: #type: buttonbaidushare: true 如果没找到也别慌，自己写这么一段就好 把它改成： 12345678910#Sharesharesdk: trueshareSDKappkey: 25ec71ed74ff0# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: type: slide baidushare: true 保存后再hexo g加hexo s在本地看看效果吧~~大概长这样： 实现博客内点击事件 这个功能很花里胡哨，具体看图： 实现之后在你的博客里每点击一次就会生成颜色各异的爱心 要实现点击出现桃心效果，需要在/themes/next/source/js/src里面新建一个love.js文件，在里面粘贴下面的代码：(代码有点乱，但是不影响) 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug），引用love.js ，就是在文档末尾输入一行代码：（就是/body&gt;和/html&gt;的下面） 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 大功告成！保存后再hexo g加hexo s在本地看看效果吧~~ 实现显示访客数量 打开\themes\next\layout_partials\footer.swig文件,在类copyright前加上红箭头指向的这句代码： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 实现单篇文章统计访问数 本段介绍如何实现通过leanCloud统计您网站的文章阅读量，并介绍一些基本实现方法。 值得庆幸的是Next主题默认就支持leanCloud的相关设置，你只需要进行几部操作就可以实现 ： 注册LeanCloud 注册leanCloud,操作过程略 创建应用： 应用名称可随意 点击应用名字进入应用 创建一个叫Counter的class： 操作完成，在左边你会看到Counter的表 获取AppID和AppKey 点击左边的设置 找到应用key选项 获取其中的你的AppID和你的AppKey 设置主题配置文件设置主题配置文件_config.yml相关字段，实现阅读数量的统计添加以下字段 1234leancloud_visitors: enable: true app_id: #此处填你的app_id app_key: #此处填你的的app_key 完成配置并重新编译。到此已经成功设置了阅读量的统计。 注意！！！！！！ 如果完成上述操作你已经正常显示了文章阅读统计那么下面的额外操作就不需要看了，你可以直接跳过。 但是如果你没有实现该功能，那么请仔细阅读下面的额外操作，尽量别把代码抄错了！ 额外操作部分 按照next的代码组成和位置(当然你可以自定你的相关代码位置，本例将以next的位置方式存放对应的代码文件) 要实现leanCloud的相关功能你需要编辑或者新建以下部分代码: _layout.swig -themes\next\layout\_layout.swig:主要是引用leanCloud的代码文件(此文件也是主题全局初始化引用接口) post.swig -themes\next\layout\_macro\post.swig:主要是文章主题的代码文件(包含主题显示阅读数量的代码) lean-analytics.swig -themes\next\layout\_scripts\third-party\lean-analytics.swig:包含leanCloud功能代码文件以上为next的文件解析和位置介绍。你可以不需要按照以上位置设置，但相关文件的代码引用需要您自行修改。如果文件存在请新建。以下贴出相关代码 实现代码 _layout.swig代码 你需要添加以下部分代码：通常如果next集成了leanCloud,你会发现以下代码 代码的作用是引用leanCloud的功能代码。 1&#123;% include &apos;_scripts/third-party/lean-analytics.swig&apos; %&#125; post.swig代码 你需要在合适的位置添加如下代码，同理如果你的NEXT集成了LeanCloud功能，你会发现以下代码 代码主要是在文章显示阅读次数等 1234567891011&#123;# LeanCould PageView #&#125;&#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt; &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; lean-analytic.swig代码 如果你的NEXT集成了leanCloud功能，你会在本文提到的位置看到此文件，若果没有请新建并填入 以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&#123;% if theme.leancloud_visitors.enable %&#125; &#123;# custom analytics part create by xiamo #&#125; &lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt;AV.initialize(&quot;&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;&quot;, &quot;&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;&quot;);&lt;/script&gt; &lt;script&gt; function showTime(Counter) &#123; var query = new AV.Query(Counter); var entries = []; var $visitors = $(&quot;.leancloud_visitors&quot;); $visitors.each(function () &#123; entries.push( $(this).attr(&quot;id&quot;).trim() ); &#125;); query.containedIn(&apos;url&apos;, entries); query.find() .done(function (results) &#123; var COUNT_CONTAINER_REF = &apos;.leancloud-visitors-count&apos;; if (results.length === 0) &#123; $visitors.find(COUNT_CONTAINER_REF).text(0); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var item = results[i]; var url = item.get(&apos;url&apos;); var time = item.get(&apos;time&apos;); var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(time); &#125; &#125;) .fail(function (object, error) &#123; console.log(&quot;Error: &quot; + error.code + &quot; &quot; + error.message); &#125;); &#125; function addCount(Counter) &#123; var $visitors = $(&quot;.leancloud_visitors&quot;); var url = $visitors.attr(&apos;id&apos;).trim(); var title = $visitors.attr(&apos;data-flag-title&apos;).trim(); var query = new AV.Query(Counter); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment(&quot;time&quot;); counter.save(null, &#123; success: function(counter) &#123; var $element = $(document.getElementById(url)); $element.find(&apos;.leancloud-visitors-count&apos;).text(counter.get(&apos;time&apos;)); &#125;, error: function(counter, error) &#123; console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); /* End Set ACL */ newcounter.set(&quot;title&quot;, title); newcounter.set(&quot;url&quot;, url); newcounter.set(&quot;time&quot;, 1); newcounter.save(null, &#123; success: function(newcounter) &#123; var $element = $(document.getElementById(url)); $element.find(&apos;.leancloud-visitors-count&apos;).text(newcounter.get(&apos;time&apos;)); &#125;, error: function(newcounter, error) &#123; console.log(&apos;Failed to create&apos;); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message); &#125; &#125;); &#125; $(function() &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123; addCount(Counter); &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123; showTime(Counter); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125; 修改语言配置文件 主要是添加visitors字段英文网站：修改themes\next\languages\en.yml 12345post: sticky: Sticky posted: Posted on visitors: Views // 增加的字段 ... 中文网站：修改themes\next\languages\zh-Hans.yml 1234post: posted: 发表于 visitors: 阅读次数 ... WEB安全 为了保证应用的统计计数功能仅应用于自己的博客系统，你可以在应用-&gt;设置-&gt;安全中心的Web安全域名 中加入自己的博客域名，以保证数据的调用安全。 设置完成 以上部分设置完成，就可以正常使用leanCloudS实现文章阅读统计。 实现评论功能 评论功能概述 目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。 可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气。） 来必力：https://livere.com （来自韩国，使用邮箱注册。） 畅言： http://changyan.kuaizhan.com （安装需要备案号。不太好用。） Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。） Valine: https://github.com/xCss/Valine (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？） 综上，最终采用了来必力。 注册账号 打开来必力官网注册：https://livere.com （如注册不来请自行科学上网） 安装 点击上方的安装，选择免费的city版本。 并点击现在安装，出现如下界面。 复制其中的uid字段。 打开主题目录下的blog/themes/next/_config.yml配置文件，定位到livere_uid字段，粘贴上刚刚复制的UID。 至此，大功告成。 添加Github导航条 在首页添加github导航条，点击这里选择需要的样式，然后将代码复制到themes/next/layout/_layout.swig 并将href后面的网址改为你的github地址，最终界面如图 ： 实现统计站点运行时间 实时展示你的博客已经运行了多长时间了，我还是蛮喜欢这个功能的，随着时间的增长，和你的博客访问量形成照样，成就感也会增添不少。 在 hexo/themes/[your theme]/layout 文件夹下找到你的 footer 文件，即脚布局文件，在对应的位置添加一下代码。 1234567891011121314151617&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;02/14/2018 12:49:00&quot;);//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 下面是效果图： 结语 功能暂时只添加这么多，后面应该会持续更新些新奇的玩意，想查看所有效果的预览，请直接进：http://lrsand52m.top 感谢你的观看！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主要元素求法及优化]]></title>
    <url>%2F2018%2F05%2F21%2F</url>
    <content type="text"><![CDATA[在一本书中，我看到这样一道题：已知一个数组中有一个元素的出现次数占所有元素个数一半以上，找出这个元素。 我想：真简单！ 是的，两个for循环能解决的问题，的确不能说难。 但是，两个for循环的确有些浪费，效率也奇低，有点儿“拿不出手”，所以我开始思索如何简化算法（日常思索）： 突然我心生一计：既然出现的频率这么高，那我对这个数组排完序，出现在中间的数不就是这个主要元素吗？ 121. 假设数组为：5 4 3 3 3 2 3 1 3 2. 排完序后为：1 2 3 3 3 3 3 4 5 这样这个算法的时间复杂度就完全取决于我排序算法的时间复杂度了 真是令人振奋呢：排序有三种不同时间复杂度的： 排序方法 复杂度 推荐程度 冒泡排序 O(N^2) ** 桶排序 O(N) ** 快速排序 O(NlogN) *** … … … 当然这里只推荐快排，因为我们给出的数值范围不确定，这样桶排序极其容易浪费掉大量内存，也是“拿不出手”的。 但是快排的时间复杂度也不能说是很低，能不能更加简化呢？比如说O(N)或者O(logN)？ 好吧，我们是理智人，O(logN)就有点逆天，毕竟读入数组就不止这个复杂度了。 所以我们重点讨论O(N)的情形： 消除法：因为占的”份额”实在是多，所以主要元素就是与其他元素一一消除，最终剩下的数也绝对是主元素，所以我们可以考虑用这个方法来“消”出这个主要元素。 这样我们就创造一个计数器k，当遇到相同元素+1，不同减一，很容易知道最终结果必为正数。不过中间过程中会遇到为0的情况，这样我们就初始化k的值，并且把他的指向保存到下一位就行了。 在指完整个数组后，最近保存的指向肯定就是主要元素啦！（想想为什么） 代码附上： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main() &#123; int n; int a[100] = &#123;0&#125;; int book = 1;//提供消除依据 int i = 0; int num = 0;//记录当前比较的数 scanf("%d",&amp;n); for(i=0; i&lt;n; i++) &#123; scanf("%d",&amp;a[i]); &#125; i = 1; if(1 == n); else &#123; while(i&lt;n) &#123; if(a[i] == a[num]) &#123; book++;//相等book+1，数组元素向后寻找 i++; &#125; else &#123; book--;//不等-1 if(!book) &#123; i++;//book=0时，标记数也之移动 num = i; &#125; else i++; &#125; &#125; &#125; printf("主元素为：%d\n",a[num]);//主要元素肯定是标记的数，输出就行 return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组运算</tag>
      </tags>
  </entry>
</search>
